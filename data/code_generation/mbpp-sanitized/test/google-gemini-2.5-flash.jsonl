{"benchmark": "mbpp", "task_id": "17", "prompt": "Write a function that returns the perimeter of a square given its side length as input.", "reference_code": "def square_perimeter(a):\n  perimeter=4*a\n  return perimeter", "test_imports": [], "test_list": ["assert square_perimeter(10)==40", "assert square_perimeter(5)==20", "assert square_perimeter(4)==16"], "model_name": "google/gemini-2.5-flash", "generated_code": "def square_perimeter(side_length):\n  \"\"\"\n  Calculates the perimeter of a square given its side length.\n\n  Args:\n    side_length: The length of one side of the square.\n\n  Returns:\n    The perimeter of the square.\n  \"\"\"\n  return 4 * side_length"}
{"benchmark": "mbpp", "task_id": "18", "prompt": "Write a function to remove characters from the first string which are present in the second string.", "reference_code": "NO_OF_CHARS = 256\ndef str_to_list(string): \n\ttemp = [] \n\tfor x in string: \n\t\ttemp.append(x) \n\treturn temp \ndef lst_to_string(List): \n\treturn ''.join(List) \ndef get_char_count_array(string): \n\tcount = [0] * NO_OF_CHARS \n\tfor i in string: \n\t\tcount[ord(i)] += 1\n\treturn count \ndef remove_dirty_chars(string, second_string): \n\tcount = get_char_count_array(second_string) \n\tip_ind = 0\n\tres_ind = 0\n\ttemp = '' \n\tstr_list = str_to_list(string) \n\twhile ip_ind != len(str_list): \n\t\ttemp = str_list[ip_ind] \n\t\tif count[ord(temp)] == 0: \n\t\t\tstr_list[res_ind] = str_list[ip_ind] \n\t\t\tres_ind += 1\n\t\tip_ind+=1\n\treturn lst_to_string(str_list[0:res_ind]) ", "test_imports": [], "test_list": ["assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'", "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'", "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles'"], "model_name": "google/gemini-2.5-flash", "generated_code": "def remove_dirty_chars(string1: str, string2: str) -> str:\n    \"\"\"\n    Removes characters from the first string which are present in the second string.\n\n    Args:\n        string1: The string from which characters will be removed.\n        string2: The string containing characters to be removed from string1.\n\n    Returns:\n        A new string with characters from string2 removed from string1.\n    \"\"\"\n    dirty_chars = set(string2)\n    result_chars = []\n    for char in string1:\n        if char not in dirty_chars:\n            result_chars.append(char)\n    return \"\".join(result_chars)"}
{"benchmark": "mbpp", "task_id": "65", "prompt": "Write a function to flatten a list and sum all of its elements.", "reference_code": "def recursive_list_sum(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + recursive_list_sum(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total", "test_imports": [], "test_list": ["assert recursive_list_sum(([1, 2, [3,4],[5,6]]))==21", "assert recursive_list_sum(([7, 10, [15,14],[19,41]]))==106", "assert recursive_list_sum(([10, 20, [30,40],[50,60]]))==210"], "model_name": "google/gemini-2.5-flash", "generated_code": "def recursive_list_sum(data):\n    \"\"\"\n    Flattens a list (potentially containing nested lists) and sums all of its numeric elements.\n\n    Args:\n        data: A list that may contain numbers or other lists (which may in turn\n              contain numbers or other lists, and so on).\n\n    Returns:\n        The sum of all numeric elements found in the flattened list.\n    \"\"\"\n    total_sum = 0\n    for item in data:\n        if isinstance(item, (int, float)):\n            total_sum += item\n        elif isinstance(item, list):\n            total_sum += recursive_list_sum(item)\n    return total_sum"}
{"benchmark": "mbpp", "task_id": "14", "prompt": "Write a python function to find the volume of a triangular prism.", "reference_code": "def find_Volume(l,b,h) : \n    return ((l * b * h) / 2) ", "test_imports": [], "test_list": ["assert find_Volume(10,8,6) == 240", "assert find_Volume(3,2,2) == 6", "assert find_Volume(1,2,1) == 1"], "model_name": "google/gemini-2.5-flash", "generated_code": "def find_Volume(base_area, height):\n  \"\"\"\n  Calculates the volume of a triangular prism.\n\n  Args:\n    base_area: The area of the triangular base.\n    height: The height of the prism (the distance between the two triangular bases).\n\n  Returns:\n    The volume of the triangular prism.\n  \"\"\"\n  return base_area * height"}
{"benchmark": "mbpp", "task_id": "12", "prompt": "Write a function to sort a given matrix in ascending order according to the sum of its rows.", "reference_code": "def sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result", "test_imports": [], "test_list": ["assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]", "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]", "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.\n    \"\"\"\n    if not matrix:\n        return []\n\n    # Use a custom key for sorting: the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix"}
{"benchmark": "mbpp", "task_id": "57", "prompt": "Write a python function to find the largest number that can be formed with the given list of digits.", "reference_code": "def find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num ", "test_imports": [], "test_list": ["assert find_Max_Num([1,2,3]) == 321", "assert find_Max_Num([4,5,6,1]) == 6541", "assert find_Max_Num([1,2,3,9]) == 9321"], "model_name": "google/gemini-2.5-flash", "generated_code": "from itertools import permutations\n\ndef find_Max_Num(nums):\n    \"\"\"\n    Finds the largest number that can be formed with the given list of digits.\n\n    Args:\n        nums: A list of integers representing the digits.\n\n    Returns:\n        An integer representing the largest number that can be formed,\n        or 0 if the input list is empty.\n    \"\"\"\n    if not nums:\n        return 0\n\n    # Convert numbers to strings to handle multi-digit numbers and for concatenation\n    str_nums = [str(num) for num in nums]\n\n    # Generate all possible permutations of the string digits\n    all_permutations = permutations(str_nums)\n\n    max_num_str = \"\"\n    max_num_val = -1\n\n    for p in all_permutations:\n        current_num_str = \"\".join(p)\n        current_num_val = int(current_num_str)\n\n        if current_num_val > max_num_val:\n            max_num_val = current_num_val\n            max_num_str = current_num_str\n\n    return max_num_val"}
{"benchmark": "mbpp", "task_id": "62", "prompt": "Write a python function to find smallest number in a list.", "reference_code": "def smallest_num(xs):\n  return min(xs)\n", "test_imports": [], "test_list": ["assert smallest_num([10, 20, 1, 45, 99]) == 1", "assert smallest_num([1, 2, 3]) == 1", "assert smallest_num([45, 46, 50, 60]) == 45"], "model_name": "google/gemini-2.5-flash", "generated_code": "def smallest_num(numbers: list) -> int:\n    \"\"\"\n    Finds the smallest number in a list of integers.\n\n    Args:\n        numbers: A list of integers.\n\n    Returns:\n        The smallest integer in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty.\")\n\n    min_val = numbers[0]\n    for num in numbers:\n        if num < min_val:\n            min_val = num\n    return min_val"}
{"benchmark": "mbpp", "task_id": "19", "prompt": "Write a function to find whether a given array of integers contains any duplicate element.", "reference_code": "def test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)     ", "test_imports": [], "test_list": ["assert test_duplicate(([1,2,3,4,5]))==False", "assert test_duplicate(([1,2,3,4, 4]))==True", "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"], "model_name": "google/gemini-2.5-flash", "generated_code": "from typing import List\n\ndef test_duplicate(nums: List[int]) -> bool:\n    \"\"\"\n    Checks if a given array of integers contains any duplicate element.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False"}
{"benchmark": "mbpp", "task_id": "16", "prompt": "Write a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.", "reference_code": "import re\ndef text_lowercase_underscore(text):\n        patterns = '^[a-z]+_[a-z]+$'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False", "test_imports": [], "test_list": ["assert text_lowercase_underscore(\"aab_cbbbc\")==(True)", "assert text_lowercase_underscore(\"aab_Abbbc\")==(False)", "assert text_lowercase_underscore(\"Aaab_abbbc\")==(False)"], "model_name": "google/gemini-2.5-flash", "generated_code": "import re\n\ndef text_lowercase_underscore(text):\n  \"\"\"\n  Checks if the input string contains sequences of lowercase letters joined with an underscore.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    True if the string contains such sequences, False otherwise.\n  \"\"\"\n  pattern = r'[a-z]+_[a-z]+'\n  return bool(re.search(pattern, text))"}
{"benchmark": "mbpp", "task_id": "64", "prompt": "Write a function to sort a list of tuples using the second value of each tuple.", "reference_code": "def subject_marks(subjectmarks):\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks", "test_imports": [], "test_list": ["assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])==[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]", "assert subject_marks([('Telugu',49),('Hindhi',54),('Social',33)])==([('Social',33),('Telugu',49),('Hindhi',54)])", "assert subject_marks([('Physics',96),('Chemistry',97),('Biology',45)])==([('Biology',45),('Physics',96),('Chemistry',97)])"], "model_name": "google/gemini-2.5-flash", "generated_code": "def subject_marks(subject_tuples):\n    \"\"\"\n    Sorts a list of tuples based on the second element of each tuple.\n\n    Args:\n        subject_tuples: A list of tuples, where each tuple contains at least two elements.\n\n    Returns:\n        A new list of tuples, sorted in ascending order based on the second element.\n    \"\"\"\n    return sorted(subject_tuples, key=lambda x: x[1])"}
{"benchmark": "mbpp", "task_id": "58", "prompt": "Write a python function to check whether the given two integers have opposite sign or not.", "reference_code": "def opposite_Signs(x,y): \n    return ((x ^ y) < 0); ", "test_imports": [], "test_list": ["assert opposite_Signs(1,-2) == True", "assert opposite_Signs(3,2) == False", "assert opposite_Signs(-10,-10) == False", "assert opposite_Signs(-2,2) == True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def opposite_Signs(x: int, y: int) -> bool:\n    \"\"\"\n    Checks whether the given two integers have opposite signs.\n\n    Args:\n        x: The first integer.\n        y: The second integer.\n\n    Returns:\n        True if the integers have opposite signs, False otherwise.\n    \"\"\"\n    return (x < 0 and y >= 0) or (x >= 0 and y < 0)"}
{"benchmark": "mbpp", "task_id": "20", "prompt": "Write a function to check if the given number is woodball or not.", "reference_code": "def is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False", "test_imports": [], "test_list": ["assert is_woodall(383) == True", "assert is_woodall(254) == False", "assert is_woodall(200) == False"], "model_name": "google/gemini-2.5-flash", "generated_code": "def is_woodall(n: int) -> bool:\n    \"\"\"\n    Checks if the given number is a Woodall number.\n\n    A Woodall number is a natural number of the form n * 2^n - 1 for some natural number n.\n    The first few Woodall numbers are 1, 7, 23, 63, 159, 383, 895, ...\n\n    Args:\n        n: The integer to check.\n\n    Returns:\n        True if n is a Woodall number, False otherwise.\n    \"\"\"\n    if n <= 0:\n        return False\n\n    # We are looking for an integer 'k' such that k * 2^k - 1 = n\n    # This means k * 2^k = n + 1\n\n    # Since k * 2^k grows very rapidly, we can iterate through possible values of k.\n    # We can stop when k * 2^k exceeds n + 1.\n    k = 1\n    while True:\n        woodall_candidate = k * (2**k) - 1\n        if woodall_candidate == n:\n            return True\n        if woodall_candidate > n:\n            # If the current candidate is already greater than n,\n            # and since k * 2^k - 1 is strictly increasing for k >= 1,\n            # we won't find n for any larger k.\n            return False\n        k += 1"}
{"benchmark": "mbpp", "task_id": "59", "prompt": "Write a function to find the nth octagonal number.", "reference_code": "def is_octagonal(n): \n\treturn 3 * n * n - 2 * n ", "test_imports": [], "test_list": ["assert is_octagonal(5) == 65", "assert is_octagonal(10) == 280", "assert is_octagonal(15) == 645"], "model_name": "google/gemini-2.5-flash", "generated_code": "def is_octagonal(n: int) -> int:\n    \"\"\"\n    Calculates the nth octagonal number.\n\n    An octagonal number is a figurate number that represents the number of dots\n    in a regular octagon with n dots on each side.\n    The formula for the nth octagonal number is O_n = n(3n - 2).\n\n    Args:\n        n: A non-negative integer representing the position of the octagonal number.\n\n    Returns:\n        The nth octagonal number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    return n * (3 * n - 2)"}
{"benchmark": "mbpp", "task_id": "56", "prompt": "Write a python function to check if a given number is one less than twice its reverse.", "reference_code": "def rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \ndef check(n):    \n    return (2 * rev(n) == n + 1)  ", "test_imports": [], "test_list": ["assert check(70) == False", "assert check(23) == False", "assert check(73) == True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def check(n: int) -> bool:\n    \"\"\"\n    Checks if a given number is one less than twice its reverse.\n\n    Args:\n        n: The integer to check.\n\n    Returns:\n        True if the number is one less than twice its reverse, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n\n    s_n = str(n)\n    reversed_s_n = s_n[::-1]\n\n    try:\n        reversed_n = int(reversed_s_n)\n    except ValueError:\n        # This case should ideally not happen if n is an integer,\n        # but good for robustness if input type was less strict.\n        return False\n\n    return n == (2 * reversed_n) - 1"}
{"benchmark": "mbpp", "task_id": "63", "prompt": "Write a function to find the maximum difference between available pairs in the given tuple list.", "reference_code": "def max_difference(test_list):\n  temp = [abs(b - a) for a, b in test_list]\n  res = max(temp)\n  return (res) ", "test_imports": [], "test_list": ["assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7", "assert max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15", "assert max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23"], "model_name": "google/gemini-2.5-flash", "generated_code": "def max_difference(tuple_list):\n    \"\"\"\n    Finds the maximum difference between available pairs in the given tuple list.\n\n    Args:\n        tuple_list: A list of tuples, where each tuple contains two numerical values.\n\n    Returns:\n        The maximum difference found between the two elements of any tuple in the list.\n        Returns 0 if the list is empty or if all tuples have identical elements.\n    \"\"\"\n    if not tuple_list:\n        return 0\n\n    max_diff = 0\n    for tpl in tuple_list:\n        if len(tpl) == 2:\n            diff = abs(tpl[0] - tpl[1])\n            if diff > max_diff:\n                max_diff = diff\n    return max_diff"}
{"benchmark": "mbpp", "task_id": "61", "prompt": "Write a python function to count the number of substrings with the sum of digits equal to their length.", "reference_code": "from collections import defaultdict\ndef count_Substrings(s):\n    n = len(s)\n    count,sum = 0,0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    return count", "test_imports": [], "test_list": ["assert count_Substrings('112112') == 6", "assert count_Substrings('111') == 6", "assert count_Substrings('1101112') == 12"], "model_name": "google/gemini-2.5-flash", "generated_code": "def count_Substrings(s: str) -> int:\n    \"\"\"\n    Counts the number of substrings in a given string 's' where the sum of digits\n    in the substring is equal to the length of the substring.\n\n    Args:\n        s: The input string consisting of digits.\n\n    Returns:\n        The total count of such substrings.\n    \"\"\"\n    n = len(s)\n    count = 0\n\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += int(s[j])\n            current_length = j - i + 1\n            if current_sum == current_length:\n                count += 1\n    return count"}
{"benchmark": "mbpp", "task_id": "66", "prompt": "Write a python function to count the number of positive numbers in a list.", "reference_code": "def pos_count(list):\n  pos_count= 0\n  for num in list: \n    if num >= 0: \n      pos_count += 1\n  return pos_count ", "test_imports": [], "test_list": ["assert pos_count([1,-2,3,-4]) == 2", "assert pos_count([3,4,5,-1]) == 3", "assert pos_count([1,2,3,4]) == 4"], "model_name": "google/gemini-2.5-flash", "generated_code": "def pos_count(num_list: list) -> int:\n    \"\"\"\n    Counts the number of positive numbers in a list.\n\n    Args:\n        num_list: A list of numbers (integers or floats).\n\n    Returns:\n        The count of positive numbers in the list.\n    \"\"\"\n    count = 0\n    for num in num_list:\n        if num > 0:\n            count += 1\n    return count"}
{"benchmark": "mbpp", "task_id": "11", "prompt": "Write a python function to remove first and last occurrence of a given character from the string.", "reference_code": "def remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s ", "test_imports": [], "test_list": ["assert remove_Occ(\"hello\",\"l\") == \"heo\"", "assert remove_Occ(\"abcda\",\"a\") == \"bcd\"", "assert remove_Occ(\"PHP\",\"P\") == \"H\""], "model_name": "google/gemini-2.5-flash", "generated_code": "def remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Args:\n        s: The input string.\n        ch: The character to be removed.\n\n    Returns:\n        The string with the first and last occurrences of 'ch' removed.\n        If 'ch' does not appear or appears only once, the original string is returned.\n    \"\"\"\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        return s\n\n    last_occurrence = s.rfind(ch)\n    if first_occurrence == last_occurrence:  # Character appears only once\n        return s\n\n    # Remove the first occurrence\n    temp_s = s[:first_occurrence] + s[first_occurrence + 1:]\n\n    # Find the new index of the last occurrence in the modified string\n    # The original last_occurrence index might shift if the first_occurrence was before it.\n    if last_occurrence > first_occurrence:\n        new_last_occurrence = last_occurrence - 1\n    else: # This case should not happen if last_occurrence is truly the last one and first_occurrence is the first one.\n          # However, for robustness, we can re-find it.\n        new_last_occurrence = temp_s.rfind(ch)\n        if new_last_occurrence == -1: # Should not happen if ch appeared at least twice\n            return s # Fallback, though logically it means only one was found after first removal\n\n    # Remove the last occurrence from the temp_s\n    return temp_s[:new_last_occurrence] + temp_s[new_last_occurrence + 1:]"}
{"benchmark": "mbpp", "task_id": "70", "prompt": "Write a function to find whether all the given tuples have equal length or not.", "reference_code": "def find_equal_tuple(Input):\n  k = 0 if not Input else len(Input[0])\n  flag = 1\n  for tuple in Input:\n    if len(tuple) != k:\n      flag = 0\n      break\n  return flag\ndef get_equal(Input):\n  return find_equal_tuple(Input) == 1", "test_imports": [], "test_list": ["assert get_equal([(11, 22, 33), (44, 55, 66)]) == True", "assert get_equal([(1, 2, 3), (4, 5, 6, 7)]) == False", "assert get_equal([(1, 2), (3, 4)]) == True"], "model_name": "google/gemini-2.5-flash", "generated_code": "from typing import Iterable, Tuple\n\ndef get_equal(input_tuple: Iterable[Tuple]) -> bool:\n    \"\"\"\n    Checks if all tuples in an iterable of tuples have the same length.\n\n    Args:\n        input_tuple: An iterable of tuples.\n\n    Returns:\n        True if all tuples have equal length, False otherwise.\n        Returns True for an empty iterable or an iterable with a single tuple.\n    \"\"\"\n    if not input_tuple:\n        return True\n\n    # Get the length of the first tuple\n    iterator = iter(input_tuple)\n    try:\n        first_tuple = next(iterator)\n        first_length = len(first_tuple)\n    except StopIteration:\n        # This case handles an empty iterable, which is already covered by the first check,\n        # but good for robustness if the iterable is empty after the first check.\n        return True\n\n    # Compare the length of subsequent tuples with the first one\n    for current_tuple in iterator:\n        if len(current_tuple) != first_length:\n            return False\n\n    return True"}
{"benchmark": "mbpp", "task_id": "68", "prompt": "Write a python function to check whether the given array is monotonic or not.", "reference_code": "def is_Monotonic(A): \n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) ", "test_imports": [], "test_list": ["assert is_Monotonic([6, 5, 4, 4]) == True", "assert is_Monotonic([1, 2, 2, 3]) == True", "assert is_Monotonic([1, 3, 2]) == False"], "model_name": "google/gemini-2.5-flash", "generated_code": "def is_Monotonic(array):\n    \"\"\"\n    Checks whether the given array is monotonic or not.\n\n    An array is monotonic if it is either entirely non-increasing or entirely non-decreasing.\n\n    Args:\n        array: A list of numbers.\n\n    Returns:\n        True if the array is monotonic, False otherwise.\n    \"\"\"\n    if len(array) <= 1:\n        return True\n\n    is_non_decreasing = True\n    is_non_increasing = True\n\n    for i in range(1, len(array)):\n        if array[i] < array[i - 1]:\n            is_non_decreasing = False\n        if array[i] > array[i - 1]:\n            is_non_increasing = False\n\n    return is_non_decreasing or is_non_increasing"}
{"benchmark": "mbpp", "task_id": "69", "prompt": "Write a function to check whether a list contains the given sublist or not.", "reference_code": "def is_sublist(l, s):\n\tsub_set = False\n\tif s == []:\n\t\tsub_set = True\n\telif s == l:\n\t\tsub_set = True\n\telif len(s) > len(l):\n\t\tsub_set = False\n\telse:\n\t\tfor i in range(len(l)):\n\t\t\tif l[i] == s[0]:\n\t\t\t\tn = 1\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\n\t\t\t\t\tn += 1\t\t\t\t\n\t\t\t\tif n == len(s):\n\t\t\t\t\tsub_set = True\n\treturn sub_set", "test_imports": [], "test_list": ["assert is_sublist([2,4,3,5,7],[3,7])==False", "assert is_sublist([2,4,3,5,7],[4,3])==True", "assert is_sublist([2,4,3,5,7],[1,6])==False"], "model_name": "google/gemini-2.5-flash", "generated_code": "def is_sublist(main_list, sub_list):\n    \"\"\"\n    Checks if a sub_list is present within a main_list.\n\n    Args:\n        main_list (list): The list to search within.\n        sub_list (list): The sublist to search for.\n\n    Returns:\n        bool: True if sub_list is found in main_list, False otherwise.\n    \"\"\"\n    n = len(main_list)\n    m = len(sub_list)\n\n    if m == 0:\n        return True  # An empty list is always a sublist\n\n    if m > n:\n        return False # A sublist cannot be longer than the main list\n\n    for i in range(n - m + 1):\n        if main_list[i:i + m] == sub_list:\n            return True\n    return False"}
{"benchmark": "mbpp", "task_id": "75", "prompt": "Write a function to find tuples which have all elements divisible by k from the given list of tuples.", "reference_code": "def find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res", "test_imports": [], "test_list": ["assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]", "assert find_tuples([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == [(5, 25, 30)]", "assert find_tuples([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == [(8, 16, 4)]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n        list_of_tuples: A list of tuples, where each tuple contains integers.\n        k: An integer divisor.\n\n    Returns:\n        A new list containing only the tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for tpl in list_of_tuples:\n        all_divisible = True\n        for element in tpl:\n            if element % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            result.append(tpl)\n    return result"}
{"benchmark": "mbpp", "task_id": "79", "prompt": "Write a python function to check whether the length of the word is odd or not.", "reference_code": "def word_len(s): \n    s = s.split(' ')   \n    for word in s:    \n        if len(word)%2!=0: \n            return True  \n        else:\n          return False", "test_imports": [], "test_list": ["assert word_len(\"Hadoop\") == False", "assert word_len(\"great\") == True", "assert word_len(\"structure\") == True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def word_len(word: str) -> bool:\n    \"\"\"\n    Checks whether the length of the word is odd or not.\n\n    Args:\n        word: The input string.\n\n    Returns:\n        True if the length of the word is odd, False otherwise.\n    \"\"\"\n    return len(word) % 2 != 0"}
{"benchmark": "mbpp", "task_id": "71", "prompt": "Write a function to sort a list of elements.", "reference_code": "def comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i+gaps]:\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums", "test_imports": [], "test_list": ["assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]", "assert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]", "assert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def comb_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Comb Sort algorithm.\n\n    Comb Sort is an improvement over Bubble Sort. It eliminates \"turtles\"\n    (small values near the end of the list) which slow down Bubble Sort.\n    It does this by using a gap that shrinks over time, rather than always\n    comparing adjacent elements.\n\n    Args:\n        arr: The list of elements to be sorted.\n\n    Returns:\n        The sorted list. The sorting is done in-place, but the function\n        also returns the sorted list for convenience.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return arr\n\n    gap = n\n    shrink_factor = 1.3\n    swapped = True\n\n    while gap > 1 or swapped:\n        # Update the gap value\n        gap = int(gap / shrink_factor)\n        if gap < 1:\n            gap = 1\n\n        swapped = False\n        # Perform a bubble sort pass with the current gap\n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n    return arr"}
{"benchmark": "mbpp", "task_id": "72", "prompt": "Write a python function to check whether the given number can be represented as the difference of two squares or not.", "reference_code": "def dif_Square(n): \n    if (n % 4 != 2): \n        return True\n    return False", "test_imports": [], "test_list": ["assert dif_Square(5) == True", "assert dif_Square(10) == False", "assert dif_Square(15) == True"], "model_name": "google/gemini-2.5-flash", "generated_code": "import math\n\ndef dif_Square(n: int) -> bool:\n    \"\"\"\n    Checks whether the given number can be represented as the difference of two squares.\n    A number n can be represented as the difference of two squares (a^2 - b^2)\n    if and only if n is odd or n is a multiple of 4.\n\n    Args:\n        n: The integer to check.\n\n    Returns:\n        True if n can be represented as the difference of two squares, False otherwise.\n    \"\"\"\n    if n < 0:\n        # A difference of two squares (a^2 - b^2) can be negative,\n        # e.g., 1^2 - 2^2 = -3.\n        # The condition for negative numbers is the same as for positive numbers\n        # in terms of absolute value.\n        # If |n| is odd or a multiple of 4, then n can be represented.\n        n = abs(n)\n\n    if n % 2 != 0:  # n is odd\n        return True\n    elif n % 4 == 0:  # n is a multiple of 4\n        return True\n    else:  # n is even but not a multiple of 4 (i.e., n % 4 == 2)\n        return False"}
{"benchmark": "mbpp", "task_id": "74", "prompt": "Write a function to check whether it follows the sequence given in the patterns array.", "reference_code": "def is_samepatterns(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    sdict = {}\n    pset = set()\n    sset = set()    \n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n        if patterns[i] not in sdict.keys():\n            sdict[patterns[i]] = []\n\n        keys = sdict[patterns[i]]\n        keys.append(colors[i])\n        sdict[patterns[i]] = keys\n\n    if len(pset) != len(sset):\n        return False   \n\n    for values in sdict.values():\n\n        for i in range(len(values) - 1):\n            if values[i] != values[i+1]:\n                return False\n\n    return True", "test_imports": [], "test_list": ["assert is_samepatterns([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"b\"])==True", "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\",\"b\"])==False", "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\"])==False"], "model_name": "google/gemini-2.5-flash", "generated_code": "def is_samepatterns(colors, patterns):\n    \"\"\"\n    Checks if the 'colors' list follows the sequence given in the 'patterns' list.\n\n    This means there must be a one-to-one mapping between each unique element in\n    'patterns' and each unique element in 'colors'. If 'patterns[i]' is the same\n    as 'patterns[j]', then 'colors[i]' must be the same as 'colors[j]'.\n    Conversely, if 'colors[i]' is the same as 'colors[j]', then 'patterns[i]'\n    must be the same as 'patterns[j]'.\n\n    Args:\n        colors: A list of strings representing colors.\n        patterns: A list of strings representing patterns.\n\n    Returns:\n        True if the 'colors' list follows the sequence given in the 'patterns' list,\n        False otherwise.\n    \"\"\"\n    if len(colors) != len(patterns):\n        return False\n\n    color_to_pattern = {}\n    pattern_to_color = {}\n\n    for i in range(len(colors)):\n        color = colors[i]\n        pattern = patterns[i]\n\n        # Check mapping from color to pattern\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n\n        # Check mapping from pattern to color\n        if pattern in pattern_to_color:\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            pattern_to_color[pattern] = color\n\n    return True"}
{"benchmark": "mbpp", "task_id": "67", "prompt": "Write a function to find the number of ways to partition a set of Bell numbers.", "reference_code": "def bell_number(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] ", "test_imports": [], "test_list": ["assert bell_number(2)==2", "assert bell_number(10)==115975", "assert bell_number(56)==6775685320645824322581483068371419745979053216268760300"], "model_name": "google/gemini-2.5-flash", "generated_code": "def bell_number(n):\n    \"\"\"\n    Calculates the nth Bell number.\n\n    The Bell number B_n is the number of ways to partition a set of n elements.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The nth Bell number.\n    \"\"\"\n    if n == 0:\n        return 1\n\n    # Create a 2D array (list of lists) to store Stirling numbers of the second kind\n    # S[i][j] will store the number of ways to partition a set of i elements into j non-empty subsets.\n    # The size of the array will be (n+1) x (n+1)\n    stirling = [[0] * (n + 1) for _ in range(n + 1)]\n\n    # Base cases for Stirling numbers of the second kind\n    # S(k, 0) = 0 for k > 0\n    # S(0, 0) = 1\n    stirling[0][0] = 1\n\n    # Fill the Stirling numbers table using the recurrence relation:\n    # S(n, k) = k * S(n-1, k) + S(n-1, k-1)\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):  # k cannot be greater than n\n            stirling[i][j] = j * stirling[i - 1][j] + stirling[i - 1][j - 1]\n\n    # The nth Bell number is the sum of the Stirling numbers of the second kind\n    # for n elements, summed over all possible number of non-empty subsets (k from 0 to n).\n    # B_n = sum(S(n, k) for k from 0 to n)\n    bell_n = sum(stirling[n][k] for k in range(n + 1))\n\n    return bell_n"}
{"benchmark": "mbpp", "task_id": "80", "prompt": "Write a function to find the nth tetrahedral number.", "reference_code": "def tetrahedral_number(n): \n\treturn (n * (n + 1) * (n + 2)) / 6", "test_imports": [], "test_list": ["assert tetrahedral_number(5) == 35", "assert tetrahedral_number(6) == 56", "assert tetrahedral_number(7) == 84"], "model_name": "google/gemini-2.5-flash", "generated_code": "def tetrahedral_number(n: int) -> int:\n    \"\"\"\n    Calculates the nth tetrahedral number.\n\n    A tetrahedral number is a figurate number that represents a pyramid with a triangular base\n    and three sides, called a tetrahedron. The nth tetrahedral number is the sum of the first\n    n triangular numbers.\n\n    The formula for the nth tetrahedral number is T_n = n * (n + 1) * (n + 2) / 6.\n\n    Args:\n        n: A non-negative integer representing the position of the tetrahedral number to find.\n\n    Returns:\n        The nth tetrahedral number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    return n * (n + 1) * (n + 2) // 6"}
{"benchmark": "mbpp", "task_id": "82", "prompt": "Write a function to find the volume of a sphere.", "reference_code": "import math\ndef volume_sphere(r):\n  volume=(4/3)*math.pi*r*r*r\n  return volume", "test_imports": ["import math"], "test_list": ["assert math.isclose(volume_sphere(10), 4188.790204786391, rel_tol=0.001)", "assert math.isclose(volume_sphere(25), 65449.84694978735, rel_tol=0.001)", "assert math.isclose(volume_sphere(20), 33510.32163829113, rel_tol=0.001)"], "model_name": "google/gemini-2.5-flash", "generated_code": "import math\n\ndef volume_sphere(radius: float) -> float:\n    \"\"\"\n    Calculates the volume of a sphere given its radius.\n\n    Args:\n        radius: The radius of the sphere. Must be a non-negative number.\n\n    Returns:\n        The volume of the sphere.\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"Radius cannot be negative.\")\n    return (4/3) * math.pi * (radius ** 3)"}
{"benchmark": "mbpp", "task_id": "77", "prompt": "Write a python function to find whether a number is divisible by 11.", "reference_code": "def is_Diff(n): \n    return (n % 11 == 0) ", "test_imports": [], "test_list": ["assert is_Diff (12345) == False", "assert is_Diff(1212112) == True", "assert is_Diff(1212) == False"], "model_name": "google/gemini-2.5-flash", "generated_code": "def is_Diff(n: int) -> bool:\n    \"\"\"\n    Checks if a number is divisible by 11 using the alternating sum of digits rule.\n\n    The rule states that a number is divisible by 11 if the alternating sum of its\n    digits is divisible by 11. For example, for the number 121, the alternating sum\n    is 1 - 2 + 1 = 0, which is divisible by 11. For 1331, it's 1 - 3 + 3 - 1 = 0.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if n is divisible by 11, False otherwise.\n    \"\"\"\n    if n < 0:\n        n = -n  # Handle negative numbers by checking their absolute value\n\n    # Convert the number to a string to easily access digits\n    s_n = str(n)\n    alternating_sum = 0\n\n    # Iterate through the digits from right to left (or left to right with alternating sign)\n    # For example, for 12345: 5 - 4 + 3 - 2 + 1\n    # Or, for 12345: 1 - 2 + 3 - 4 + 5\n    # Both approaches yield the same result modulo 11.\n    # Let's use the left-to-right approach for simplicity in indexing.\n    for i, digit_char in enumerate(s_n):\n        digit = int(digit_char)\n        if i % 2 == 0:  # Even index (0, 2, 4, ...) corresponds to positive sign\n            alternating_sum += digit\n        else:  # Odd index (1, 3, 5, ...) corresponds to negative sign\n            alternating_sum -= digit\n\n    return alternating_sum % 11 == 0"}
{"benchmark": "mbpp", "task_id": "83", "prompt": "Write a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.", "reference_code": "def get_Char(strr):  \n    summ = 0\n    for i in range(len(strr)): \n        summ += (ord(strr[i]) - ord('a') + 1)  \n    if (summ % 26 == 0): \n        return ord('z') \n    else: \n        summ = summ % 26\n        return chr(ord('a') + summ - 1)", "test_imports": [], "test_list": ["assert get_Char(\"abc\") == \"f\"", "assert get_Char(\"gfg\") == \"t\"", "assert get_Char(\"ab\") == \"c\""], "model_name": "google/gemini-2.5-flash", "generated_code": "def get_Char(s: str) -> str:\n    \"\"\"\n    Finds the character made by adding the ASCII value of all the characters\n    of the given string modulo 26.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The character corresponding to the calculated ASCII value.\n    \"\"\"\n    if not s:\n        return ''\n\n    total_ascii_sum = 0\n    for char in s:\n        total_ascii_sum += ord(char)\n\n    # The result should be an uppercase letter (A-Z).\n    # 'A' has ASCII value 65.\n    # (total_ascii_sum % 26) will give a value from 0 to 25.\n    # Adding this to ord('A') will map 0 to 'A', 1 to 'B', ..., 25 to 'Z'.\n    result_ascii_value = ord('A') + (total_ascii_sum % 26)\n\n    return chr(result_ascii_value)"}
{"benchmark": "mbpp", "task_id": "85", "prompt": "Write a function to find the surface area of a sphere.", "reference_code": "import math\ndef surfacearea_sphere(r):\n  surfacearea=4*math.pi*r*r\n  return surfacearea", "test_imports": ["import math"], "test_list": ["assert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)", "assert math.isclose(surfacearea_sphere(15), 2827.4333882308138, rel_tol=0.001)", "assert math.isclose(surfacearea_sphere(20), 5026.548245743669, rel_tol=0.001)"], "model_name": "google/gemini-2.5-flash", "generated_code": "import math\n\ndef surfacearea_sphere(radius: float) -> float:\n    \"\"\"\n    Calculates the surface area of a sphere given its radius.\n\n    Args:\n        radius: The radius of the sphere. Must be a non-negative number.\n\n    Returns:\n        The surface area of the sphere.\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"Radius cannot be negative.\")\n    return 4 * math.pi * (radius ** 2)"}
{"benchmark": "mbpp", "task_id": "89", "prompt": "Write a function to find the closest smaller number than n.", "reference_code": "def closest_num(N):\n  return (N - 1)", "test_imports": [], "test_list": ["assert closest_num(11) == 10", "assert closest_num(7) == 6", "assert closest_num(12) == 11"], "model_name": "google/gemini-2.5-flash", "generated_code": "def closest_num(n: int) -> int:\n    \"\"\"\n    Finds the closest smaller number than n.\n    This function assumes that \"smaller\" means numerically smaller,\n    and \"closest\" means the smallest difference in absolute value.\n    Since we are looking for a number *smaller* than n, the closest\n    smaller integer is always n - 1.\n    \"\"\"\n    return n - 1"}
{"benchmark": "mbpp", "task_id": "84", "prompt": "Write a function to find the nth number in the newman conway sequence.", "reference_code": "def sequence(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\telse: \n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))", "test_imports": [], "test_list": ["assert sequence(10) == 6", "assert sequence(2) == 1", "assert sequence(3) == 2"], "model_name": "google/gemini-2.5-flash", "generated_code": "def sequence(n: int) -> int:\n    \"\"\"\n    Calculates the nth number in the Newman-Conway sequence.\n\n    The Newman-Conway sequence is defined as:\n    P(1) = 1\n    P(2) = 1\n    P(n) = P(P(n-1)) + P(n-P(n-1)) for n > 2\n\n    Args:\n        n: The index of the number to find (1-indexed).\n\n    Returns:\n        The nth number in the Newman-Conway sequence.\n\n    Raises:\n        ValueError: If n is less than 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n    if n == 1 or n == 2:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n\n    return dp[n]"}
{"benchmark": "mbpp", "task_id": "88", "prompt": "Write a function to get the frequency of all the elements in a list, returned as a dictionary.", "reference_code": "import collections\ndef freq_count(list1):\n  freq_count= collections.Counter(list1)\n  return freq_count", "test_imports": [], "test_list": ["assert freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])==({10: 4, 20: 4, 40: 2, 50: 2, 30: 1})", "assert freq_count([1,2,3,4,3,2,4,1,3,1,4])==({1:3, 2:2,3:3,4:3})", "assert freq_count([5,6,7,4,9,10,4,5,6,7,9,5])==({10:1,5:3,6:2,7:2,4:2,9:2})"], "model_name": "google/gemini-2.5-flash", "generated_code": "def freq_count(data: list) -> dict:\n    \"\"\"\n    Calculates the frequency of each element in a list.\n\n    Args:\n        data: A list of elements.\n\n    Returns:\n        A dictionary where keys are the elements from the input list\n        and values are their corresponding frequencies.\n    \"\"\"\n    frequency = {}\n    for item in data:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency"}
{"benchmark": "mbpp", "task_id": "87", "prompt": "Write a function to merge three dictionaries into a single dictionary.", "reference_code": "import collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict", "test_imports": [], "test_list": ["assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}", "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{\"L\":\"lavender\",\"B\":\"Blue\"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}", "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" },{\"L\":\"lavender\",\"B\":\"Blue\"},{ \"G\": \"Green\", \"W\": \"White\" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}"], "model_name": "google/gemini-2.5-flash", "generated_code": "def merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    \"\"\"\n    Merges three dictionaries into a single dictionary.\n    If there are common keys, the value from the later dictionary in the argument list will be used.\n\n    Args:\n        dict1: The first dictionary.\n        dict2: The second dictionary.\n        dict3: The third dictionary.\n\n    Returns:\n        A new dictionary containing all key-value pairs from the three input dictionaries.\n    \"\"\"\n    merged_dict = {}\n    merged_dict.update(dict1)\n    merged_dict.update(dict2)\n    merged_dict.update(dict3)\n    return merged_dict"}
{"benchmark": "mbpp", "task_id": "90", "prompt": "Write a python function to find the length of the longest word.", "reference_code": "def len_log(list1):\n    max=len(list1[0])\n    for i in list1:\n        if len(i)>max:\n            max=len(i)\n    return max", "test_imports": [], "test_list": ["assert len_log([\"python\",\"PHP\",\"bigdata\"]) == 7", "assert len_log([\"a\",\"ab\",\"abc\"]) == 3", "assert len_log([\"small\",\"big\",\"tall\"]) == 5"], "model_name": "google/gemini-2.5-flash", "generated_code": "def len_log(text):\n    \"\"\"\n    Finds the length of the longest word in a given string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        The length of the longest word. Returns 0 if the string is empty\n        or contains no words.\n    \"\"\"\n    if not text:\n        return 0\n\n    words = text.split()\n    if not words:\n        return 0\n\n    max_length = 0\n    for word in words:\n        max_length = max(max_length, len(word))\n\n    return max_length"}
{"benchmark": "mbpp", "task_id": "86", "prompt": "Write a function to find nth centered hexagonal number.", "reference_code": "def centered_hexagonal_number(n):\n  return 3 * n * (n - 1) + 1", "test_imports": [], "test_list": ["assert centered_hexagonal_number(10) == 271", "assert centered_hexagonal_number(2) == 7", "assert centered_hexagonal_number(9) == 217"], "model_name": "google/gemini-2.5-flash", "generated_code": "def centered_hexagonal_number(n: int) -> int:\n    \"\"\"\n    Calculates the nth centered hexagonal number.\n\n    A centered hexagonal number is a centered figurate number that represents a hexagon\n    with a dot in the center and all other dots surrounding the center in a hexagonal lattice.\n\n    The formula for the nth centered hexagonal number is n^3 - (n-1)^3 = 3n^2 - 3n + 1.\n    Alternatively, it can be expressed as 1 + 3 * n * (n - 1).\n\n    Args:\n        n: A non-negative integer representing the index of the centered hexagonal number.\n           n=1 corresponds to the first centered hexagonal number.\n\n    Returns:\n        The nth centered hexagonal number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input 'n' must be a positive integer.\")\n    return 3 * n * (n - 1) + 1"}
{"benchmark": "mbpp", "task_id": "91", "prompt": "Write a function to check if a string is present as a substring in a given list of string values.", "reference_code": "def find_substring(str1, sub_str):\n   if any(sub_str in s for s in str1):\n       return True\n   return False", "test_imports": [], "test_list": ["assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ack\")==True", "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"abc\")==False", "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ange\")==True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def find_substring(substring: str, string_list: list[str]) -> bool:\n    \"\"\"\n    Checks if a string is present as a substring in any of the strings in a given list.\n\n    Args:\n        substring: The string to search for.\n        string_list: A list of strings to search within.\n\n    Returns:\n        True if the substring is found in any of the strings in the list, False otherwise.\n    \"\"\"\n    for s in string_list:\n        if substring in s:\n            return True\n    return False"}
{"benchmark": "mbpp", "task_id": "93", "prompt": "Write a function to calculate the value of 'a' to the power 'b'.", "reference_code": "def power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)", "test_imports": [], "test_list": ["assert power(3,4) == 81", "assert power(2,3) == 8", "assert power(5,5) == 3125"], "model_name": "google/gemini-2.5-flash", "generated_code": "def power(a: float, b: int) -> float:\n    \"\"\"\n    Calculates the value of 'a' to the power 'b'.\n\n    Args:\n        a: The base (can be a float).\n        b: The exponent (must be an integer).\n\n    Returns:\n        The result of a raised to the power of b.\n    \"\"\"\n    return a ** b"}
{"benchmark": "mbpp", "task_id": "97", "prompt": "Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.", "reference_code": "def frequency_lists(list1):\n    list1 = [item for sublist in list1 for item in sublist]\n    dic_data = {}\n    for num in list1:\n        if num in dic_data.keys():\n            dic_data[num] += 1\n        else:\n            key = num\n            value = 1\n            dic_data[key] = value\n    return dic_data\n", "test_imports": [], "test_list": ["assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])=={1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}", "assert frequency_lists([[1,2,3,4],[5,6,7,8],[9,10,11,12]])=={1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1,10:1,11:1,12:1}", "assert frequency_lists([[20,30,40,17],[18,16,14,13],[10,20,30,40]])=={20:2,30:2,40:2,17: 1,18:1, 16: 1,14: 1,13: 1, 10: 1}"], "model_name": "google/gemini-2.5-flash", "generated_code": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains elements.\n\n    Returns:\n        A dictionary where keys are the elements and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for inner_list in list_of_lists:\n        for item in inner_list:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency"}
{"benchmark": "mbpp", "task_id": "96", "prompt": "Write a python function to find the number of divisors of a given integer.", "reference_code": "def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x", "test_imports": [], "test_list": ["assert divisor(15) == 4", "assert divisor(12) == 6", "assert divisor(9) == 3"], "model_name": "google/gemini-2.5-flash", "generated_code": "def divisor(n: int) -> int:\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n        i += 1\n    return count"}
{"benchmark": "mbpp", "task_id": "94", "prompt": "Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value.", "reference_code": "from operator import itemgetter \ndef index_minimum(test_list):\n  res = min(test_list, key = itemgetter(1))[0]\n  return (res) ", "test_imports": [], "test_list": ["assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'", "assert index_minimum([('Yash', 185), ('Dawood', 125), ('Sanya', 175)]) == 'Dawood'", "assert index_minimum([('Sai', 345), ('Salman', 145), ('Ayesha', 96)]) == 'Ayesha'"], "model_name": "google/gemini-2.5-flash", "generated_code": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples_list: A list of tuples, where each tuple has at least two elements.\n\n    Returns:\n        The first value of the tuple that has the smallest second value.\n        If the list is empty, returns None.\n    \"\"\"\n    if not tuples_list:\n        return None\n\n    min_second_value = float('inf')\n    result_first_value = None\n\n    for item_tuple in tuples_list:\n        if len(item_tuple) < 2:\n            # Handle cases where a tuple might not have a second element,\n            # though the problem implies they do.\n            continue\n\n        current_second_value = item_tuple[1]\n        if current_second_value < min_second_value:\n            min_second_value = current_second_value\n            result_first_value = item_tuple[0]\n    \n    return result_first_value"}
{"benchmark": "mbpp", "task_id": "95", "prompt": "Write a python function to find the length of the smallest list in a list of lists.", "reference_code": "def Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength ", "test_imports": [], "test_list": ["assert Find_Min_Length([[1],[1,2]]) == 1", "assert Find_Min_Length([[1,2],[1,2,3],[1,2,3,4]]) == 2", "assert Find_Min_Length([[3,3,3],[4,4,4,4]]) == 3"], "model_name": "google/gemini-2.5-flash", "generated_code": "def Find_Min_Length(lst):\n    \"\"\"\n    Finds the length of the smallest list in a list of lists.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        An integer representing the length of the smallest list.\n        Returns 0 if the input list is empty or contains only empty lists.\n    \"\"\"\n    if not lst:\n        return 0\n\n    min_length = float('inf')\n    for sublist in lst:\n        min_length = min(min_length, len(sublist))\n\n    # If all sublists were empty, min_length would still be 0.\n    # If the input list was not empty but contained only empty lists,\n    # the result should be 0.\n    return min_length"}
{"benchmark": "mbpp", "task_id": "98", "prompt": "Write a function to multiply all the numbers in a list and divide with the length of the list.", "reference_code": "def multiply_num(numbers):  \n    total = 1\n    for x in numbers:\n        total *= x  \n    return total/len(numbers) ", "test_imports": ["import math"], "test_list": ["assert math.isclose(multiply_num((8, 2, 3, -1, 7)), -67.2, rel_tol=0.001)", "assert math.isclose(multiply_num((-10,-20,-30)), -2000.0, rel_tol=0.001)", "assert math.isclose(multiply_num((19,15,18)), 1710.0, rel_tol=0.001)"], "model_name": "google/gemini-2.5-flash", "generated_code": "def multiply_num(numbers):\n    \"\"\"\n    Multiplies all the numbers in a list and divides the product by the length of the list.\n\n    Args:\n        numbers: A list of numbers (integers or floats).\n\n    Returns:\n        The product of all numbers divided by the length of the list.\n        Returns 0 if the list is empty.\n    \"\"\"\n    if not numbers:\n        return 0\n\n    product = 1\n    for num in numbers:\n        product *= num\n\n    return product / len(numbers)"}
{"benchmark": "mbpp", "task_id": "100", "prompt": "Write a function to find the next smallest palindrome of a specified integer, returned as an integer.", "reference_code": "import sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i", "test_imports": [], "test_list": ["assert next_smallest_palindrome(99)==101", "assert next_smallest_palindrome(1221)==1331", "assert next_smallest_palindrome(120)==121"], "model_name": "google/gemini-2.5-flash", "generated_code": "def next_smallest_palindrome(num: int) -> int:\n    \"\"\"\n    Finds the next smallest palindrome of a specified integer.\n\n    Args:\n        num: The input integer.\n\n    Returns:\n        The next smallest palindrome as an integer.\n    \"\"\"\n\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    num += 1\n    while not is_palindrome(num):\n        num += 1\n    return num"}
{"benchmark": "mbpp", "task_id": "99", "prompt": "Write a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.", "reference_code": "def decimal_to_binary(n): \n    return bin(n).replace(\"0b\",\"\") ", "test_imports": [], "test_list": ["assert decimal_to_binary(8) == '1000'", "assert decimal_to_binary(18) == '10010'", "assert decimal_to_binary(7) == '111'"], "model_name": "google/gemini-2.5-flash", "generated_code": "def decimal_to_binary(decimal_num: int) -> str:\n    \"\"\"\n    Convert a decimal number to its binary equivalent, represented as a string with no leading zeros.\n\n    Args:\n        decimal_num: The decimal number to convert.\n\n    Returns:\n        A string representing the binary equivalent of the decimal number.\n        Returns \"0\" if the input is 0.\n    \"\"\"\n    if decimal_num == 0:\n        return \"0\"\n\n    binary_representation = []\n    temp_num = decimal_num\n\n    while temp_num > 0:\n        remainder = temp_num % 2\n        binary_representation.append(str(remainder))\n        temp_num //= 2\n\n    # The binary digits are collected in reverse order, so we need to reverse the list\n    return \"\".join(binary_representation[::-1])"}
{"benchmark": "mbpp", "task_id": "101", "prompt": "Write a function to find the kth element in the given array using 1-based indexing.", "reference_code": "def kth_element(arr, k):\n  n = len(arr)\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] > arr[j+1]:\n        arr[j], arr[j+1] == arr[j+1], arr[j]\n  return arr[k-1]", "test_imports": [], "test_list": ["assert kth_element([12,3,5,7,19], 2) == 3", "assert kth_element([17,24,8,23], 3) == 8", "assert kth_element([16,21,25,36,4], 4) == 36"], "model_name": "google/gemini-2.5-flash", "generated_code": "def kth_element(arr: list, k: int):\n    \"\"\"\n    Finds the kth element in the given array using 1-based indexing.\n\n    Args:\n        arr: The input list of elements.\n        k: The 1-based index of the element to find.\n\n    Returns:\n        The element at the kth position, or None if k is out of bounds.\n    \"\"\"\n    if not arr or k <= 0 or k > len(arr):\n        return None\n    return arr[k - 1]"}
{"benchmark": "mbpp", "task_id": "102", "prompt": "Write a function to convert a snake case string to camel case string.", "reference_code": "def snake_to_camel(word):\n        import re\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))", "test_imports": [], "test_list": ["assert snake_to_camel('python_program')=='PythonProgram'", "assert snake_to_camel('python_language')==('PythonLanguage')", "assert snake_to_camel('programming_language')==('ProgrammingLanguage')"], "model_name": "google/gemini-2.5-flash", "generated_code": "def snake_to_camel(snake_str: str) -> str:\n    \"\"\"\n    Converts a snake_case string to a camelCase string.\n\n    Args:\n        snake_str: The input string in snake_case.\n\n    Returns:\n        The converted string in camelCase.\n    \"\"\"\n    components = snake_str.split('_')\n    # Capitalize the first letter of each component except the first one\n    # and join them together.\n    # The first component remains as is (lowercase).\n    return components[0] + ''.join(x.title() for x in components[1:])"}
{"benchmark": "mbpp", "task_id": "104", "prompt": "Write a function to sort each sublist of strings in a given list of lists.", "reference_code": "def sort_sublists(input_list):\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \n    return result\n", "test_imports": [], "test_list": ["assert sort_sublists(([\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]))==[['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]", "assert sort_sublists(([\" red \",\"green\" ],[\"blue \",\" black\"],[\" orange\",\"brown\"]))==[[' red ', 'green'], [' black', 'blue '], [' orange', 'brown']]", "assert sort_sublists(([\"zilver\",\"gold\"], [\"magnesium\",\"aluminium\"], [\"steel\", \"bronze\"]))==[['gold', 'zilver'],['aluminium', 'magnesium'], ['bronze', 'steel']]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def sort_sublists(list_of_lists):\n    \"\"\"\n    Sorts each sublist of strings in a given list of lists.\n\n    Args:\n        list_of_lists: A list of lists, where each inner list contains strings.\n\n    Returns:\n        A new list of lists where each sublist is sorted alphabetically.\n    \"\"\"\n    sorted_outer_list = []\n    for sublist in list_of_lists:\n        sorted_outer_list.append(sorted(sublist))\n    return sorted_outer_list"}
{"benchmark": "mbpp", "task_id": "105", "prompt": "Write a python function to count true booleans in the given list.", "reference_code": "def count(lst):   \n    return sum(lst) ", "test_imports": [], "test_list": ["assert count([True,False,True]) == 2", "assert count([False,False]) == 0", "assert count([True,True,True]) == 3"], "model_name": "google/gemini-2.5-flash", "generated_code": "def count(bool_list: list[bool]) -> int:\n    \"\"\"\n    Counts the number of True booleans in the given list.\n\n    Args:\n        bool_list: A list of boolean values.\n\n    Returns:\n        The number of True booleans in the list.\n    \"\"\"\n    true_count = 0\n    for boolean in bool_list:\n        if boolean:\n            true_count += 1\n    return true_count"}
{"benchmark": "mbpp", "task_id": "103", "prompt": "Write a function to find the Eulerian number a(n, m).", "reference_code": "def eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))", "test_imports": [], "test_list": ["assert eulerian_num(3, 1) == 4", "assert eulerian_num(4, 1) == 11", "assert eulerian_num(5, 3) == 26"], "model_name": "google/gemini-2.5-flash", "generated_code": "def eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Calculates the Eulerian number A(n, m), which is the number of permutations\n    of {1, ..., n} having exactly m ascents.\n\n    Args:\n        n: A non-negative integer.\n        m: A non-negative integer.\n\n    Returns:\n        The Eulerian number A(n, m).\n    \"\"\"\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 1 if m == 0 else 0\n    if n == 1:\n        return 1 if m == 0 else 0\n\n    # Initialize a 2D array for dynamic programming\n    # dp[i][j] will store A(i, j)\n    dp = [[0] * n for _ in range(n + 1)]\n\n    # Base case: A(1, 0) = 1\n    dp[1][0] = 1\n\n    # Fill the DP table\n    for i in range(2, n + 1):\n        for j in range(i):  # m can go from 0 to i-1\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] * (i - j)\n            else:\n                dp[i][j] = dp[i - 1][j] * (i - j) + dp[i - 1][j - 1] * (j + 1)\n\n    return dp[n][m]"}
{"benchmark": "mbpp", "task_id": "106", "prompt": "Write a function to append the given list to the given tuples.", "reference_code": "def add_lists(test_list, test_tup):\n  res = tuple(list(test_tup) + test_list)\n  return (res) ", "test_imports": [], "test_list": ["assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)", "assert add_lists([6, 7, 8], (10, 11)) == (10, 11, 6, 7, 8)", "assert add_lists([7, 8, 9], (11, 12)) == (11, 12, 7, 8, 9)"], "model_name": "google/gemini-2.5-flash", "generated_code": "def add_lists(list_of_tuples, list_to_add):\n    \"\"\"\n    Appends the given list to each tuple in the list of tuples.\n\n    Args:\n        list_of_tuples: A list of tuples.\n        list_to_add: The list to append to each tuple.\n\n    Returns:\n        A new list of tuples, where each original tuple has the elements\n        of list_to_add appended to it.\n    \"\"\"\n    result = []\n    for tpl in list_of_tuples:\n        result.append(tpl + tuple(list_to_add))\n    return result"}
{"benchmark": "mbpp", "task_id": "108", "prompt": "Write a function to merge three lists into a single sorted list.", "reference_code": "import heapq\ndef merge_sorted_list(num1,num2,num3):\n  num1=sorted(num1)\n  num2=sorted(num2)\n  num3=sorted(num3)\n  result = heapq.merge(num1,num2,num3)\n  return list(result)", "test_imports": [], "test_list": ["assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])==[4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]", "assert merge_sorted_list([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12])==[1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]", "assert merge_sorted_list([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1],[25, 35, 22, 85, 14, 65, 75, 25, 58],[12, 74, 9, 50, 61, 41])==[1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def merge_sorted_list(list1: list, list2: list, list3: list) -> list:\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        list3: The third list of numbers.\n\n    Returns:\n        A new list containing all elements from the three input lists, sorted in ascending order.\n    \"\"\"\n    merged_list = []\n    merged_list.extend(list1)\n    merged_list.extend(list2)\n    merged_list.extend(list3)\n    merged_list.sort()\n    return merged_list"}
{"benchmark": "mbpp", "task_id": "111", "prompt": "Write a function to find the common elements in given nested lists.", "reference_code": "def common_in_nested_lists(nestedlist):\n    result = list(set.intersection(*map(set, nestedlist)))\n    return result", "test_imports": [], "test_list": ["assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]))==set([18, 12])", "assert set(common_in_nested_lists([[12, 5, 23, 25, 45], [7, 11, 5, 23, 28], [1, 5, 8, 18, 23, 16]]))==set([5,23])", "assert set(common_in_nested_lists([[2, 3,4, 1], [4, 5], [6,4, 8],[4, 5], [6, 8,4]]))==set([4])"], "model_name": "google/gemini-2.5-flash", "generated_code": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n        nested_lists: A list of lists, where each inner list contains elements.\n\n    Returns:\n        A list of elements that are common to all inner lists.\n        Returns an empty list if nested_lists is empty or if there are no common elements.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Convert the first list to a set for efficient intersection operations\n    common_elements_set = set(nested_lists[0])\n\n    # Iterate through the rest of the lists and find the intersection\n    for i in range(1, len(nested_lists)):\n        current_list_set = set(nested_lists[i])\n        common_elements_set = common_elements_set.intersection(current_list_set)\n        # If at any point the common_elements_set becomes empty,\n        # it means there are no common elements across all lists,\n        # so we can stop early.\n        if not common_elements_set:\n            return []\n\n    return sorted(list(common_elements_set))"}
{"benchmark": "mbpp", "task_id": "92", "prompt": "Write a function to check whether the given number is undulating or not.", "reference_code": "def is_undulating(n): \n\tn = str(n)\n\tif (len(n) <= 2): \n\t\treturn False\n\tfor i in range(2, len(n)): \n\t\tif (n[i - 2] != n[i]): \n\t\t\treturn False\n\treturn True", "test_imports": [], "test_list": ["assert is_undulating(1212121) == True", "assert is_undulating(1991) == False", "assert is_undulating(121) == True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def is_undulating(n: int) -> bool:\n    \"\"\"\n    Checks if a given number is undulating.\n\n    An undulating number is a number with at least three digits where the digits\n    alternate between two distinct values. For example, 12121, 303030, 98989.\n\n    Args:\n        n: The integer number to check.\n\n    Returns:\n        True if the number is undulating, False otherwise.\n    \"\"\"\n    s = str(n)\n\n    if len(s) < 3:\n        return False\n\n    # Check if digits alternate between two distinct values\n    # s[0] and s[1] must be different\n    # s[0] == s[2] == s[4] ...\n    # s[1] == s[3] == s[5] ...\n    if s[0] == s[1]:\n        return False\n\n    for i in range(2, len(s)):\n        if i % 2 == 0:  # Even index, should be same as s[0]\n            if s[i] != s[0]:\n                return False\n        else:  # Odd index, should be same as s[1]\n            if s[i] != s[1]:\n                return False\n\n    return True"}
{"benchmark": "mbpp", "task_id": "115", "prompt": "Write a function to check whether all dictionaries in a list are empty or not.", "reference_code": "def empty_dit(list1):\n empty_dit=all(not d for d in list1)\n return empty_dit", "test_imports": [], "test_list": ["assert empty_dit([{},{},{}])==True", "assert empty_dit([{1,2},{},{}])==False", "assert empty_dit({})==True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def empty_dit(list_of_dicts: list) -> bool:\n    \"\"\"\n    Checks whether all dictionaries in a list are empty or not.\n\n    Args:\n        list_of_dicts: A list of dictionaries.\n\n    Returns:\n        True if all dictionaries in the list are empty, False otherwise.\n    \"\"\"\n    if not list_of_dicts:\n        return True  # An empty list of dictionaries can be considered as all empty\n\n    for d in list_of_dicts:\n        if d:  # If any dictionary is not empty\n            return False\n    return True"}
{"benchmark": "mbpp", "task_id": "118", "prompt": "Write a function to convert a string to a list of strings split on the space character.", "reference_code": "def string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst", "test_imports": [], "test_list": ["assert string_to_list(\"python programming\")==['python','programming']", "assert string_to_list(\"lists tuples strings\")==['lists','tuples','strings']", "assert string_to_list(\"write a program\")==['write','a','program']"], "model_name": "google/gemini-2.5-flash", "generated_code": "def string_to_list(input_string: str) -> list[str]:\n    \"\"\"\n    Converts a string to a list of strings split on the space character.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        A list of strings, where the original string has been split by spaces.\n    \"\"\"\n    return input_string.split(' ')"}
{"benchmark": "mbpp", "task_id": "113", "prompt": "Write a function to check if a string represents an integer or not.", "reference_code": "def check_integer(text):\n text = text.strip()\n if len(text) < 1:\n    return None\n else:\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\n          return True\n     elif (text[0] in \"+-\") and \\\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\n         return True\n     else:\n        return False", "test_imports": [], "test_list": ["assert check_integer(\"python\")==False", "assert check_integer(\"1\")==True", "assert check_integer(\"12345\")==True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def check_integer(s: str) -> bool:\n    \"\"\"\n    Checks if a string represents an integer.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        True if the string represents an integer, False otherwise.\n    \"\"\"\n    if not isinstance(s, str):\n        return False\n\n    s = s.strip()\n\n    if not s:\n        return False\n\n    # Check for optional sign\n    start_index = 0\n    if s[0] == '+' or s[0] == '-':\n        start_index = 1\n\n    # After the sign, all characters must be digits\n    if start_index == len(s):  # Only a sign, e.g., \"+\" or \"-\"\n        return False\n\n    for i in range(start_index, len(s)):\n        if not ('0' <= s[i] <= '9'):\n            return False\n\n    return True"}
{"benchmark": "mbpp", "task_id": "117", "prompt": "Write a function to convert all possible convertible elements in a list of lists to floats.", "reference_code": "def list_to_float(test_list):\n  res = []\n  for tup in test_list:\n    temp = []\n    for ele in tup:\n      if ele.isalpha():\n        temp.append(ele)\n      else:\n        temp.append(float(ele))\n    res.append((temp[0],temp[1])) \n  return res", "test_imports": [], "test_list": ["assert list_to_float( [(\"3\", \"4\"), (\"1\", \"26.45\"), (\"7.32\", \"8\"), (\"4\", \"8\")] ) == [(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]", "assert list_to_float( [(\"4\", \"4\"), (\"2\", \"27\"), (\"4.12\", \"9\"), (\"7\", \"11\")] ) == [(4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)]", "assert list_to_float( [(\"6\", \"78\"), (\"5\", \"26.45\"), (\"1.33\", \"4\"), (\"82\", \"13\")] ) == [(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def list_to_float(data):\n    \"\"\"\n    Converts all possible convertible elements in a list of lists to floats.\n\n    Args:\n        data: A list of lists, where inner elements can be of various types.\n\n    Returns:\n        A new list of lists with convertible elements transformed to floats.\n    \"\"\"\n    result = []\n    for inner_list in data:\n        new_inner_list = []\n        for item in inner_list:\n            try:\n                new_inner_list.append(float(item))\n            except (ValueError, TypeError):\n                new_inner_list.append(item)\n        result.append(new_inner_list)\n    return result"}
{"benchmark": "mbpp", "task_id": "116", "prompt": "Write a function to convert a given tuple of positive integers into a single integer.", "reference_code": "def tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result", "test_imports": [], "test_list": ["assert tuple_to_int((1,2,3))==123", "assert tuple_to_int((4,5,6))==456", "assert tuple_to_int((5,6,7))==567"], "model_name": "google/gemini-2.5-flash", "generated_code": "def tuple_to_int(t: tuple) -> int:\n    \"\"\"\n    Converts a given tuple of positive integers into a single integer.\n\n    For example:\n    tuple_to_int((1, 2, 3)) == 123\n    tuple_to_int((5,)) == 5\n    tuple_to_int((0, 0, 7)) == 7\n    tuple_to_int(()) == 0\n    \"\"\"\n    if not t:\n        return 0\n\n    result_str = \"\".join(str(x) for x in t)\n    return int(result_str)"}
{"benchmark": "mbpp", "task_id": "124", "prompt": "Write a function to get the angle of a complex number.", "reference_code": "import cmath\ndef angle_complex(a,b):\n  cn=complex(a,b)\n  angle=cmath.phase(a+b)\n  return angle", "test_imports": ["import math"], "test_list": ["assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)", "assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)", "assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)"], "model_name": "google/gemini-2.5-flash", "generated_code": "import cmath\n\ndef angle_complex(z: complex) -> float:\n  \"\"\"\n  Calculates the angle (phase) of a complex number.\n\n  Args:\n    z: The complex number.\n\n  Returns:\n    The angle of the complex number in radians, in the range (-pi, pi].\n  \"\"\"\n  return cmath.phase(z)"}
{"benchmark": "mbpp", "task_id": "119", "prompt": "Write a python function to find the element that appears only once in a sorted array.", "reference_code": "def search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)", "test_imports": [], "test_list": ["assert search([1,1,2,2,3]) == 3", "assert search([1,1,3,3,4,4,5,5,7,7,8]) == 8", "assert search([1,2,2,3,3,4,4]) == 1"], "model_name": "google/gemini-2.5-flash", "generated_code": "def search(arr):\n    \"\"\"\n    Finds the element that appears only once in a sorted array where all other elements\n    appear exactly twice.\n\n    Args:\n        arr: A sorted list of integers where all elements except one appear twice.\n\n    Returns:\n        The integer that appears only once.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n\n        # If mid is the first or last element, or if its neighbors are different,\n        # then arr[mid] is the single element.\n        if (mid == 0 or arr[mid] != arr[mid - 1]) and \\\n           (mid == len(arr) - 1 or arr[mid] != arr[mid + 1]):\n            return arr[mid]\n\n        # If mid is part of a pair\n        if mid % 2 == 0:  # mid is at an even index\n            if arr[mid] == arr[mid + 1]:\n                low = mid + 2\n            else:\n                high = mid - 1\n        else:  # mid is at an odd index\n            if arr[mid] == arr[mid - 1]:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n    return -1  # Should not be reached if input is valid"}
{"benchmark": "mbpp", "task_id": "120", "prompt": "Write a function to find the maximum absolute product between numbers in pairs of tuples within a given list.", "reference_code": "def max_product_tuple(list1):\n    result_max = max([abs(x * y) for x, y in list1] )\n    return result_max", "test_imports": [], "test_list": ["assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36", "assert max_product_tuple([(10,20), (15,2), (5,10)] )==200", "assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484"], "model_name": "google/gemini-2.5-flash", "generated_code": "def max_product_tuple(data):\n    \"\"\"\n    Finds the maximum absolute product between numbers in pairs of tuples within a given list.\n\n    Args:\n        data: A list of tuples, where each tuple contains two numbers (integers or floats).\n              Example: [(1, 2), (-3, 4), (5, -6)]\n\n    Returns:\n        The maximum absolute product found. Returns 0 if the input list is empty.\n    \"\"\"\n    if not data:\n        return 0\n\n    max_abs_product = 0\n\n    for i in range(len(data)):\n        for j in range(i + 1, len(data)):\n            tuple1 = data[i]\n            tuple2 = data[j]\n\n            # Calculate products for all combinations of elements between the two tuples\n            products = [\n                tuple1[0] * tuple2[0],\n                tuple1[0] * tuple2[1],\n                tuple1[1] * tuple2[0],\n                tuple1[1] * tuple2[1]\n            ]\n\n            for prod in products:\n                abs_prod = abs(prod)\n                if abs_prod > max_abs_product:\n                    max_abs_product = abs_prod\n\n    return max_abs_product"}
{"benchmark": "mbpp", "task_id": "127", "prompt": "Write a function to multiply two integers.", "reference_code": "def multiply_int(x, y):\n    if y < 0:\n        return -multiply_int(x, -y)\n    elif y == 0:\n        return 0\n    elif y == 1:\n        return x\n    else:\n        return x + multiply_int(x, y - 1)", "test_imports": [], "test_list": ["assert multiply_int(10,20)==200", "assert multiply_int(5,10)==50", "assert multiply_int(4,8)==32"], "model_name": "google/gemini-2.5-flash", "generated_code": "def multiply_int(a: int, b: int) -> int:\n    \"\"\"\n    Multiplies two integers.\n\n    Args:\n        a: The first integer.\n        b: The second integer.\n\n    Returns:\n        The product of a and b.\n    \"\"\"\n    return a * b"}
{"benchmark": "mbpp", "task_id": "123", "prompt": "Write a function to sum all amicable numbers from 1 to a specified number.", "reference_code": "def amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    amicables = set()\n    for num in range(2, limit+1):\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)", "test_imports": [], "test_list": ["assert amicable_numbers_sum(999)==504", "assert amicable_numbers_sum(9999)==31626", "assert amicable_numbers_sum(99)==0"], "model_name": "google/gemini-2.5-flash", "generated_code": "def amicable_numbers_sum(limit: int) -> int:\n    \"\"\"\n    Calculates the sum of all amicable numbers up to a specified limit.\n\n    An amicable pair (m, n) is a pair of distinct positive integers such that\n    the sum of the proper divisors of m (divisors excluding m itself) equals n,\n    and the sum of the proper divisors of n equals m.\n\n    Args:\n        limit: The upper bound (inclusive) for searching amicable numbers.\n\n    Returns:\n        The sum of all amicable numbers found within the range [1, limit].\n    \"\"\"\n\n    def sum_proper_divisors(n: int) -> int:\n        \"\"\"Calculates the sum of proper divisors of a given number.\"\"\"\n        if n <= 1:\n            return 0\n        s = 1  # 1 is always a proper divisor\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                s += i\n                if i * i != n:\n                    s += n // i\n        return s\n\n    amicable_sum = 0\n    found_amicable_numbers = set()\n\n    for a in range(1, limit + 1):\n        if a in found_amicable_numbers:\n            continue\n\n        sum_div_a = sum_proper_divisors(a)\n\n        if sum_div_a > a and sum_div_a <= limit:  # Check if b is within the limit and distinct\n            b = sum_div_a\n            sum_div_b = sum_proper_divisors(b)\n\n            if sum_div_b == a:\n                # Found an amicable pair (a, b)\n                amicable_sum += a + b\n                found_amicable_numbers.add(a)\n                found_amicable_numbers.add(b)\n\n    return amicable_sum"}
{"benchmark": "mbpp", "task_id": "126", "prompt": "Write a python function to find the sum of common divisors of two given numbers.", "reference_code": "def sum(a,b): \n    sum = 0\n    for i in range (1,min(a,b)): \n        if (a % i == 0 and b % i == 0): \n            sum += i \n    return sum", "test_imports": [], "test_list": ["assert sum(10,15) == 6", "assert sum(100,150) == 93", "assert sum(4,6) == 3"], "model_name": "google/gemini-2.5-flash", "generated_code": "def sum(a: int, b: int) -> int:\n    \"\"\"\n    Calculates the sum of common divisors of two given numbers.\n\n    Args:\n        a: The first integer.\n        b: The second integer.\n\n    Returns:\n        The sum of common divisors of a and b.\n    \"\"\"\n    if a == 0 and b == 0:\n        return 0  # Or handle as an error case depending on requirements\n    if a == 0:\n        return _sum_divisors(abs(b))\n    if b == 0:\n        return _sum_divisors(abs(a))\n\n    common_divisors_sum = 0\n    min_val = min(abs(a), abs(b))\n\n    for i in range(1, min_val + 1):\n        if a % i == 0 and b % i == 0:\n            common_divisors_sum += i\n    return common_divisors_sum\n\ndef _sum_divisors(n: int) -> int:\n    \"\"\"Helper function to calculate the sum of all divisors of a single number.\"\"\"\n    if n == 0:\n        return 0\n    total_sum = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total_sum += i\n            if i * i != n:\n                total_sum += n // i\n    return total_sum"}
{"benchmark": "mbpp", "task_id": "132", "prompt": "Write a function to convert a tuple to a string.", "reference_code": "def tup_string(tup1):\n  str =  ''.join(tup1)\n  return str", "test_imports": [], "test_list": ["assert tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's'))==(\"exercises\")", "assert tup_string(('p','y','t','h','o','n'))==(\"python\")", "assert tup_string(('p','r','o','g','r','a','m'))==(\"program\")"], "model_name": "google/gemini-2.5-flash", "generated_code": "def tup_string(tup):\n    \"\"\"\n    Converts a tuple to a string representation.\n\n    Args:\n        tup: The input tuple.\n\n    Returns:\n        A string representation of the tuple.\n    \"\"\"\n    return str(tup)"}
{"benchmark": "mbpp", "task_id": "131", "prompt": "Write a python function to reverse only the vowels of a given string (where y is not a vowel).", "reference_code": "def reverse_vowels(str1):\n\tvowels = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tvowels += char\n\tresult_string = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tresult_string += vowels[-1]\n\t\t\tvowels = vowels[:-1]\n\t\telse:\n\t\t\tresult_string += char\n\treturn result_string", "test_imports": [], "test_list": ["assert reverse_vowels(\"Python\") == \"Python\"", "assert reverse_vowels(\"USA\") == \"ASU\"", "assert reverse_vowels(\"ab\") == \"ab\""], "model_name": "google/gemini-2.5-flash", "generated_code": "def reverse_vowels(s: str) -> str:\n    \"\"\"\n    Reverses only the vowels of a given string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The string with only its vowels reversed.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    s_list = list(s)\n    left = 0\n    right = len(s_list) - 1\n\n    while left < right:\n        while left < right and s_list[left] not in vowels:\n            left += 1\n        while left < right and s_list[right] not in vowels:\n            right -= 1\n\n        if left < right:\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left += 1\n            right -= 1\n\n    return \"\".join(s_list)"}
{"benchmark": "mbpp", "task_id": "130", "prompt": "Write a function to find the item with maximum frequency in a given list.", "reference_code": "from collections import defaultdict\ndef max_occurrences(nums):\n    dict = defaultdict(int)\n    for i in nums:\n        dict[i] += 1\n    result = max(dict.items(), key=lambda x: x[1]) \n    return result[0]", "test_imports": [], "test_list": ["assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2", "assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8", "assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20"], "model_name": "google/gemini-2.5-flash", "generated_code": "from collections import Counter\n\ndef max_occurrences(input_list):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n\n    Args:\n        input_list: A list of items.\n\n    Returns:\n        The item with the highest frequency. If there's a tie, the item\n        that appears first in the original list among the tied items is returned.\n        If the input list is empty, returns None.\n    \"\"\"\n    if not input_list:\n        return None\n\n    # Use Counter to get frequencies of all items\n    counts = Counter(input_list)\n\n    # Find the maximum frequency\n    max_freq = 0\n    if counts: # Ensure counts is not empty, though it won't be if input_list is not empty\n        max_freq = max(counts.values())\n\n    # Iterate through the original list to find the first item with max_freq\n    for item in input_list:\n        if counts[item] == max_freq:\n            return item"}
{"benchmark": "mbpp", "task_id": "133", "prompt": "Write a function to calculate the sum of the negative numbers of a given list of numbers.", "reference_code": "def sum_negativenum(nums):\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\n  return sum(sum_negativenum)", "test_imports": [], "test_list": ["assert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17])==-32", "assert sum_negativenum([10,15,-14,13,-18,12,-20])==-52", "assert sum_negativenum([19, -65, 57, 39, 152,-639, 121, 44, 90, -190])==-894"], "model_name": "google/gemini-2.5-flash", "generated_code": "def sum_negativenum(nums: list[int]) -> int:\n    \"\"\"\n    Calculates the sum of the negative numbers in a given list of integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The sum of the negative numbers in the list.\n    \"\"\"\n    total_negative_sum = 0\n    for num in nums:\n        if num < 0:\n            total_negative_sum += num\n    return total_negative_sum"}
{"benchmark": "mbpp", "task_id": "129", "prompt": "Write a function to calculate whether the matrix is a magic square.", "reference_code": "def magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True", "test_imports": [], "test_list": ["assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True", "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]])==True", "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 7]])==False"], "model_name": "google/gemini-2.5-flash", "generated_code": "def magic_square_test(matrix):\n    \"\"\"\n    Calculates whether the given matrix is a magic square.\n\n    A magic square is a square matrix where the sum of the numbers in each row,\n    each column, and both main diagonals are the same.\n\n    Args:\n        matrix: A list of lists representing the square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n\n    if n == 0:\n        return True  # An empty matrix can be considered a magic square\n\n    # Check if it's a square matrix and contains only numbers\n    for row in matrix:\n        if len(row) != n:\n            return False\n        for x in row:\n            if not isinstance(x, (int, float)):\n                return False\n\n    # Calculate the sum of the first row to establish the magic constant\n    magic_sum = sum(matrix[0])\n\n    # Check row sums\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check column sums\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != magic_sum:\n            return False\n\n    # Check main diagonal sum (top-left to bottom-right)\n    diag1_sum = 0\n    for i in range(n):\n        diag1_sum += matrix[i][i]\n    if diag1_sum != magic_sum:\n        return False\n\n    # Check anti-diagonal sum (top-right to bottom-left)\n    diag2_sum = 0\n    for i in range(n):\n        diag2_sum += matrix[i][n - 1 - i]\n    if diag2_sum != magic_sum:\n        return False\n\n    return True"}
{"benchmark": "mbpp", "task_id": "109", "prompt": "Write a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.", "reference_code": "def odd_Equivalent(s,n): \n    count=0\n    for i in range(0,n): \n        if (s[i] == '1'): \n            count = count + 1\n    return count ", "test_imports": [], "test_list": ["assert odd_Equivalent(\"011001\",6) == 3", "assert odd_Equivalent(\"11011\",5) == 4", "assert odd_Equivalent(\"1010\",4) == 2"], "model_name": "google/gemini-2.5-flash", "generated_code": "def odd_Equivalent(s: str, k: int) -> int:\n    \"\"\"\n    Finds the number of numbers with an odd value when rotating a binary string\n    the given number of times.\n\n    Args:\n        s: The binary string.\n        k: The number of rotations.\n\n    Returns:\n        The count of odd numbers generated by rotations.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # A binary number is odd if its last digit is '1'.\n    # We need to count how many times '1' appears at the last position\n    # after k rotations.\n\n    # The effective number of rotations is k % n.\n    # This is because rotating n times brings the string back to its original state.\n    effective_k = k % n\n\n    odd_count = 0\n    for i in range(n):\n        # Simulate the rotation for the current starting position\n        # The character at index `i` in the original string will move to\n        # index `(i - effective_k + n) % n` after `effective_k` left rotations.\n        # Or, equivalently, the character at index `(i + effective_k) % n`\n        # in the original string will move to index `i` after `effective_k` left rotations.\n\n        # We are interested in the character that ends up at the last position (index n-1).\n        # If the string is s_0 s_1 ... s_{n-1}\n        # After effective_k left rotations, the string becomes\n        # s_{effective_k} s_{effective_k+1} ... s_{n-1} s_0 ... s_{effective_k-1}\n\n        # The last character of the rotated string will be s_{(effective_k - 1 + n) % n}\n        # if effective_k is 0, it's s_{n-1}\n        # if effective_k is 1, it's s_0\n        # if effective_k is 2, it's s_1\n        # ...\n        # if effective_k is n-1, it's s_{n-2}\n\n        # More generally, the character at index `(n - 1 + effective_k) % n` in the original string\n        # will be at the last position (index n-1) after `effective_k` left rotations.\n\n        # Let's consider the string after `i` left rotations.\n        # The character at the last position (index n-1) of this rotated string\n        # will be the character originally at index `(n - 1 + i) % n`.\n        # We need to check if this character is '1'.\n\n        # The problem asks for the number of numbers with an odd value when rotating\n        # a binary string *the given number of times*. This implies we perform\n        # k rotations, then check the value. Then perform k rotations again, etc.\n        # This interpretation means we are checking the string s rotated by k, 2k, 3k, ..., nk times.\n\n        # Let's re-read carefully: \"number of numbers with an odd value when rotating a binary string the given number of times.\"\n        # This usually means we consider all possible rotations *up to* k, or all possible rotations *after* k rotations.\n        # The phrasing \"the given number of times\" suggests we apply k rotations, then check.\n        # Then we apply k rotations again to the *original* string, and check.\n        # This interpretation doesn't make sense for \"number of numbers\".\n\n        # A more common interpretation for such problems is:\n        # Consider the string `s`.\n        # Rotate it by 1 position, check if odd.\n        # Rotate it by 2 positions, check if odd.\n        # ...\n        # Rotate it by `k` positions, check if odd.\n        # And count how many of these `k` resulting numbers are odd.\n\n        # Let's assume the interpretation is:\n        # We perform `i` left rotations for `i` from 1 to `k`.\n        # For each such rotated string, we check if its decimal equivalent is odd.\n        # A binary number is odd if and only if its last digit is '1'.\n\n        # So, for each `i` from 1 to `k`:\n        # 1. Calculate the string after `i` left rotations.\n        # 2. Check its last character. If it's '1', increment count.\n\n        # The character at the last position (index n-1) after `j` left rotations\n        # is the character originally at index `(n - 1 + j) % n`.\n\n        rotation_index = (n - 1 + i) % n\n        if s[rotation_index] == '1':\n            odd_count += 1\n\n    return odd_count"}
{"benchmark": "mbpp", "task_id": "135", "prompt": "Write a function to find the nth hexagonal number.", "reference_code": "def hexagonal_num(n): \n\treturn n*(2*n - 1) ", "test_imports": [], "test_list": ["assert hexagonal_num(10) == 190", "assert hexagonal_num(5) == 45", "assert hexagonal_num(7) == 91"], "model_name": "google/gemini-2.5-flash", "generated_code": "def hexagonal_num(n: int) -> int:\n    \"\"\"\n    Calculates the nth hexagonal number.\n\n    A hexagonal number is a figurate number that represents the number of dots\n    in a hexagon with n dots on each side.\n\n    The formula for the nth hexagonal number is H_n = n * (2n - 1).\n\n    Args:\n        n: A non-negative integer representing the position of the hexagonal number.\n\n    Returns:\n        The nth hexagonal number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    return n * (2 * n - 1)"}
{"benchmark": "mbpp", "task_id": "139", "prompt": "Write a function to find the circumference of a circle.", "reference_code": "def circle_circumference(r):\n  perimeter=2*3.1415*r\n  return perimeter", "test_imports": ["import math"], "test_list": ["assert math.isclose(circle_circumference(10), 62.830000000000005, rel_tol=0.001)", "assert math.isclose(circle_circumference(5), 31.415000000000003, rel_tol=0.001)", "assert math.isclose(circle_circumference(4), 25.132, rel_tol=0.001)"], "model_name": "google/gemini-2.5-flash", "generated_code": "import math\n\ndef circle_circumference(radius):\n  \"\"\"\n  Calculates the circumference of a circle given its radius.\n\n  Args:\n    radius: The radius of the circle (a non-negative number).\n\n  Returns:\n    The circumference of the circle.\n  \"\"\"\n  if radius < 0:\n    raise ValueError(\"Radius cannot be negative.\")\n  return 2 * math.pi * radius"}
{"benchmark": "mbpp", "task_id": "138", "prompt": "Write a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.", "reference_code": "def is_Sum_Of_Powers_Of_Two(n): \n    if (n % 2 == 1): \n        return False\n    else: \n        return True", "test_imports": [], "test_list": ["assert is_Sum_Of_Powers_Of_Two(10) == True", "assert is_Sum_Of_Powers_Of_Two(7) == False", "assert is_Sum_Of_Powers_Of_Two(14) == True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    \"\"\"\n    Checks whether the given number can be represented as a sum of non-zero powers of 2.\n    This is equivalent to checking if the number is greater than 0.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the number can be represented as a sum of non-zero powers of 2,\n        False otherwise.\n    \"\"\"\n    return n > 0"}
{"benchmark": "mbpp", "task_id": "137", "prompt": "Write a function to find the ratio of zeroes to non-zeroes in an array of integers.", "reference_code": "from array import array\ndef zero_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x == 0:\n            n1 += 1\n        else:\n          None\n    return n1/(n-n1)", "test_imports": ["import math"], "test_list": ["assert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)", "assert math.isclose(zero_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.00, rel_tol=0.001)", "assert math.isclose(zero_count([2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.00, rel_tol=0.001)"], "model_name": "google/gemini-2.5-flash", "generated_code": "def zero_count(arr: list[int]) -> float:\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in an array of integers.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The ratio of zeroes to non-zeroes. Returns 0.0 if there are no non-zeroes\n        and no zeroes. Returns float('inf') if there are zeroes but no non-zeroes.\n    \"\"\"\n    num_zeroes = 0\n    num_non_zeroes = 0\n\n    for x in arr:\n        if x == 0:\n            num_zeroes += 1\n        else:\n            num_non_zeroes += 1\n\n    if num_non_zeroes == 0:\n        if num_zeroes == 0:\n            return 0.0  # No elements in the array, or all elements are non-zero (but num_non_zeroes is 0, so this case is for empty array)\n        else:\n            return float('inf')  # Zeroes present, but no non-zeroes\n    else:\n        return num_zeroes / num_non_zeroes"}
{"benchmark": "mbpp", "task_id": "128", "prompt": "Write a function to find words that are longer than n characters from a given list of words.", "reference_code": "def long_words(n, str):\n    word_len = []\n    txt = str.split(\" \")\n    for x in txt:\n        if len(x) > n:\n            word_len.append(x)\n    return word_len\t", "test_imports": [], "test_list": ["assert long_words(3,\"python is a programming language\")==['python','programming','language']", "assert long_words(2,\"writing a program\")==['writing','program']", "assert long_words(5,\"sorting list\")==['sorting']"], "model_name": "google/gemini-2.5-flash", "generated_code": "def long_words(words: list[str], n: int) -> list[str]:\n    \"\"\"\n    Finds words that are longer than n characters from a given list of words.\n\n    Args:\n        words: A list of strings.\n        n: An integer representing the minimum length a word must exceed.\n\n    Returns:\n        A list of strings where each word is longer than n characters.\n    \"\"\"\n    return [word for word in words if len(word) > n]"}
{"benchmark": "mbpp", "task_id": "140", "prompt": "Write a function to flatten the list of lists into a single set of numbers.", "reference_code": "def extract_singly(test_list):\n  res = []\n  temp = set()\n  for inner in test_list:\n    for ele in inner:\n      if not ele in temp:\n        temp.add(ele)\n        res.append(ele)\n  return (res) ", "test_imports": [], "test_list": ["assert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([3, 4, 5, 7, 1])", "assert set(extract_singly([(1, 2, 3), (4, 2, 3), (7, 8)])) == set([1, 2, 3, 4, 7, 8])", "assert set(extract_singly([(7, 8, 9), (10, 11, 12), (10, 11)])) == set([7, 8, 9, 10, 11, 12])"], "model_name": "google/gemini-2.5-flash", "generated_code": "def extract_singly(list_of_lists: list) -> set:\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists: A list where each element is expected to be a list of numbers.\n\n    Returns:\n        A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    result_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            result_set.add(item)\n    return result_set"}
{"benchmark": "mbpp", "task_id": "143", "prompt": "Write a function to find number of lists present in the given tuple.", "reference_code": "def find_lists(Input): \n\tif isinstance(Input, list): \n\t\treturn 1\n\telse: \n\t\treturn len(Input) ", "test_imports": [], "test_list": ["assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2", "assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3", "assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1"], "model_name": "google/gemini-2.5-flash", "generated_code": "def find_lists(tup: tuple) -> int:\n    \"\"\"\n    Finds the number of lists present in the given tuple.\n\n    Args:\n        tup: The input tuple.\n\n    Returns:\n        The number of lists found within the tuple.\n    \"\"\"\n    count = 0\n    for item in tup:\n        if isinstance(item, list):\n            count += 1\n    return count"}
{"benchmark": "mbpp", "task_id": "142", "prompt": "Write a function to count number items that are identical in the same position of three given lists.", "reference_code": "def count_samepair(list1,list2,list3):\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\n    return result", "test_imports": [], "test_list": ["assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9])==3", "assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==4", "assert count_samepair([1,2,3,4,2,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==5"], "model_name": "google/gemini-2.5-flash", "generated_code": "def count_samepair(list1, list2, list3):\n    \"\"\"\n    Counts the number of items that are identical in the same position of three given lists.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        The number of positions where all three lists have identical items.\n    \"\"\"\n    count = 0\n    min_length = min(len(list1), len(list2), len(list3))\n\n    for i in range(min_length):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    return count"}
{"benchmark": "mbpp", "task_id": "145", "prompt": "Write a python function to find the maximum difference between any two elements in a given array.", "reference_code": "def max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) ", "test_imports": [], "test_list": ["assert max_Abs_Diff((2,1,5,3)) == 4", "assert max_Abs_Diff((9,3,2,5,1)) == 8", "assert max_Abs_Diff((3,2,1)) == 2"], "model_name": "google/gemini-2.5-flash", "generated_code": "def max_Abs_Diff(arr: list[int]) -> int:\n    \"\"\"\n    Finds the maximum absolute difference between any two elements in a given array.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The maximum absolute difference between any two elements in the array.\n        Returns 0 if the array has fewer than two elements.\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n\n    min_val = arr[0]\n    max_val = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < min_val:\n            min_val = arr[i]\n        if arr[i] > max_val:\n            max_val = arr[i]\n\n    return max_val - min_val"}
{"benchmark": "mbpp", "task_id": "141", "prompt": "Write a function to sort a list of elements.", "reference_code": "def pancake_sort(nums):\n    arr_len = len(nums)\n    while arr_len > 1:\n        mi = nums.index(max(nums[0:arr_len]))\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\n        arr_len -= 1\n    return nums", "test_imports": [], "test_list": ["assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]", "assert pancake_sort([98, 12, 54, 36, 85]) == [12, 36, 54, 85, 98]", "assert pancake_sort([41, 42, 32, 12, 23]) == [12, 23, 32, 41, 42]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Pancake Sort algorithm.\n\n    Pancake sort is a sorting algorithm that sorts a list of elements\n    by repeatedly flipping prefixes of the list. The only allowed operation\n    is to reverse the prefix of the list.\n\n    Args:\n        arr: The list of elements to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n\n    for i in range(n, 1, -1):\n        # Find the index of the maximum element in the current unsorted part\n        max_idx = arr.index(max(arr[:i]))\n\n        # If the maximum element is not already at its correct position (i-1)\n        if max_idx != i - 1:\n            # Flip the prefix up to max_idx to bring the maximum element to the front\n            if max_idx != 0:\n                arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n\n            # Flip the prefix up to i-1 to move the maximum element to its correct position\n            arr[:i] = arr[:i][::-1]\n    return arr"}
{"benchmark": "mbpp", "task_id": "164", "prompt": "Write a function to determine if the sum of the divisors of two integers are the same.", "reference_code": "import math \ndef div_sum(n): \n  total = 1\n  i = 2\n\n  while i * i <= n:\n    if (n % i == 0):\n      total = (total + i + math.floor(n / i))\n    i += 1\n\n  return total\n\ndef are_equivalent(num1, num2): \n    return div_sum(num1) == div_sum(num2); ", "test_imports": [], "test_list": ["assert are_equivalent(36, 57) == False", "assert are_equivalent(2, 4) == False", "assert are_equivalent(23, 47) == True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def are_equivalent(a: int, b: int) -> bool:\n    \"\"\"\n    Determines if the sum of the divisors of two integers are the same.\n\n    Args:\n        a: The first integer.\n        b: The second integer.\n\n    Returns:\n        True if the sum of the divisors of a and b are the same, False otherwise.\n    \"\"\"\n\n    def sum_divisors(n: int) -> int:\n        \"\"\"Calculates the sum of the divisors of a given integer.\"\"\"\n        if n <= 0:\n            return 0  # Or raise an error, depending on desired behavior for non-positive numbers\n        total_sum = 0\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                total_sum += i\n                if i * i != n:\n                    total_sum += n // i\n        return total_sum\n\n    return sum_divisors(a) == sum_divisors(b)"}
{"benchmark": "mbpp", "task_id": "161", "prompt": "Write a function to remove all elements from a given list present in another list.", "reference_code": "def remove_elements(list1, list2):\n    result = [x for x in list1 if x not in list2]\n    return result", "test_imports": [], "test_list": ["assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]", "assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 3, 5, 7]) == [2, 4, 6, 8, 9, 10]", "assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [5, 7]) == [1, 2, 3, 4, 6, 8, 9, 10]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def remove_elements(list_to_modify: list, elements_to_remove: list) -> list:\n    \"\"\"\n    Removes all elements from list_to_modify that are present in elements_to_remove.\n\n    Args:\n        list_to_modify: The list from which elements will be removed.\n        elements_to_remove: The list containing elements to be removed.\n\n    Returns:\n        A new list with elements removed. The original list_to_modify is not modified.\n    \"\"\"\n    # Convert elements_to_remove to a set for efficient lookup (O(1) average time complexity)\n    # This is much faster than repeatedly checking 'in' a list (O(n) for each check).\n    remove_set = set(elements_to_remove)\n\n    # Use a list comprehension to build the new list, including only elements\n    # from list_to_modify that are not in the remove_set.\n    return [item for item in list_to_modify if item not in remove_set]"}
{"benchmark": "mbpp", "task_id": "167", "prompt": "Write a python function to find the smallest power of 2 greater than or equal to n.", "reference_code": "def next_power_of_2(n): \n  if n and not n & (n - 1):\n    return n\n\n  count = 0\n  while n != 0: \n    n >>= 1\n    count += 1\n\n  return 1 << count; ", "test_imports": [], "test_list": ["assert next_power_of_2(0) == 1", "assert next_power_of_2(5) == 8", "assert next_power_of_2(17) == 32"], "model_name": "google/gemini-2.5-flash", "generated_code": "def next_power_of_2(n: int) -> int:\n    \"\"\"\n    Finds the smallest power of 2 greater than or equal to n.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The smallest power of 2 greater than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 1\n    \n    power = 1\n    while power < n:\n        power <<= 1  # Equivalent to power = power * 2\n    return power"}
{"benchmark": "mbpp", "task_id": "163", "prompt": "Write a function to calculate the area of a regular polygon given the length and number of its sides.", "reference_code": "from math import tan, pi\ndef area_polygon(s, l):\n  area = s * (l ** 2) / (4 * tan(pi / s))\n  return area", "test_imports": ["import math"], "test_list": ["assert math.isclose(area_polygon(4, 20), 400., rel_tol=0.001)", "assert math.isclose(area_polygon(10, 15), 1731.197, rel_tol=0.001)", "assert math.isclose(area_polygon(9, 7), 302.909, rel_tol=0.001)"], "model_name": "google/gemini-2.5-flash", "generated_code": "import math\n\ndef area_polygon(side_length: float, num_sides: int) -> float:\n    \"\"\"\n    Calculates the area of a regular polygon given the length and number of its sides.\n\n    Args:\n        side_length: The length of one side of the regular polygon.\n        num_sides: The number of sides of the regular polygon.\n\n    Returns:\n        The area of the regular polygon.\n    \"\"\"\n    if num_sides < 3:\n        raise ValueError(\"A polygon must have at least 3 sides.\")\n    if side_length <= 0:\n        raise ValueError(\"Side length must be a positive number.\")\n\n    # Formula for the area of a regular polygon:\n    # Area = (n * s^2) / (4 * tan(pi/n))\n    # where n is the number of sides and s is the side length.\n\n    # Calculate the angle in radians\n    angle_radians = math.pi / num_sides\n\n    # Calculate the tangent of the angle\n    tan_angle = math.tan(angle_radians)\n\n    # Calculate the area\n    area = (num_sides * side_length**2) / (4 * tan_angle)\n\n    return area"}
{"benchmark": "mbpp", "task_id": "160", "prompt": "Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.", "reference_code": "def find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None", "test_imports": [], "test_list": ["assert find_solution(2, 3, 7) == (2, 1)", "assert find_solution(4, 2, 7) == None", "assert find_solution(1, 13, 17) == (4, 1)"], "model_name": "google/gemini-2.5-flash", "generated_code": "def find_solution(a: int, b: int, n: int) -> tuple[int, int] | None:\n    \"\"\"\n    Finds integers x and y that satisfy ax + by = n.\n\n    This function implements the extended Euclidean algorithm to find a particular\n    solution to the Diophantine equation ax + by = n. If no solution exists,\n    it returns None.\n\n    Args:\n        a: The coefficient of x.\n        b: The coefficient of y.\n        n: The constant term.\n\n    Returns:\n        A tuple (x, y) representing a particular solution, or None if no solution exists.\n    \"\"\"\n\n    # Extended Euclidean Algorithm to find gcd(a, b) and x0, y0 such that a*x0 + b*y0 = gcd(a, b)\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n\n    gcd_val, x0, y0 = extended_gcd(a, b)\n\n    # If n is not divisible by gcd(a, b), then no integer solution exists.\n    if n % gcd_val != 0:\n        return None\n\n    # Calculate the scaling factor\n    k = n // gcd_val\n\n    # A particular solution (x, y)\n    x = x0 * k\n    y = y0 * k\n\n    return (x, y)"}
{"benchmark": "mbpp", "task_id": "162", "prompt": "Write a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).", "reference_code": "def sum_series(n):\n  if n < 1:\n    return 0\n  else:\n    return n + sum_series(n - 2)", "test_imports": [], "test_list": ["assert sum_series(6) == 12", "assert sum_series(10) == 30", "assert sum_series(9) == 25"], "model_name": "google/gemini-2.5-flash", "generated_code": "def sum_series(n: int) -> int:\n    \"\"\"\n    Calculates the sum (n - 2*i) from i=0 to n // 2.\n\n    For example:\n    If n = 5, the terms are:\n    i=0: 5 - 2*0 = 5\n    i=1: 5 - 2*1 = 3\n    i=2: 5 - 2*2 = 1\n    The sum is 5 + 3 + 1 = 9\n\n    If n = 6, the terms are:\n    i=0: 6 - 2*0 = 6\n    i=1: 6 - 2*1 = 4\n    i=2: 6 - 2*2 = 2\n    i=3: 6 - 2*3 = 0\n    The sum is 6 + 4 + 2 + 0 = 12\n    \"\"\"\n    total_sum = 0\n    for i in range(n // 2 + 1):\n        term = n - 2 * i\n        total_sum += term\n    return total_sum"}
{"benchmark": "mbpp", "task_id": "168", "prompt": "Write a function to count the number of occurrences of a number in a given list.", "reference_code": "def frequency(a,x): \n    count = 0  \n    for i in a: \n      if i == x: \n        count += 1\n\n    return count ", "test_imports": [], "test_list": ["assert frequency([1,2,3], 4) == 0", "assert frequency([1,2,2,3,3,3,4], 3) == 3", "assert frequency([0,1,2,3,1,2], 1) == 2"], "model_name": "google/gemini-2.5-flash", "generated_code": "def frequency(arr, x):\n  \"\"\"\n  Counts the number of occurrences of a number in a given list.\n\n  Args:\n    arr: The list of numbers.\n    x: The number to count.\n\n  Returns:\n    The number of times x appears in arr.\n  \"\"\"\n  count = 0\n  for item in arr:\n    if item == x:\n      count += 1\n  return count"}
{"benchmark": "mbpp", "task_id": "171", "prompt": "Write a function to find the perimeter of a regular pentagon from the length of its sides.", "reference_code": "import math\ndef perimeter_pentagon(a):\n  perimeter=(5*a)\n  return perimeter", "test_imports": [], "test_list": ["assert perimeter_pentagon(5) == 25", "assert perimeter_pentagon(10) == 50", "assert perimeter_pentagon(15) == 75"], "model_name": "google/gemini-2.5-flash", "generated_code": "def perimeter_pentagon(side_length: float) -> float:\n    \"\"\"\n    Calculates the perimeter of a regular pentagon given the length of its sides.\n\n    A regular pentagon has 5 equal sides. The perimeter is the sum of the lengths of its sides.\n\n    Args:\n        side_length: The length of one side of the regular pentagon.\n\n    Returns:\n        The perimeter of the regular pentagon.\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"Side length cannot be negative.\")\n    return 5 * side_length"}
{"benchmark": "mbpp", "task_id": "170", "prompt": "Write a function to find the sum of numbers in a list within a range specified by two indices.", "reference_code": "def sum_range_list(list1, m, n):                                                                                                                                                                                                \n    sum_range = 0                                                                                                                                                                                                         \n    for i in range(m, n+1, 1):                                                                                                                                                                                        \n        sum_range += list1[i]                                                                                                                                                                                                  \n    return sum_range   ", "test_imports": [], "test_list": ["assert sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 8, 10) == 29", "assert sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 5, 7) == 16", "assert sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 7, 10) == 38"], "model_name": "google/gemini-2.5-flash", "generated_code": "def sum_range_list(numbers: list, start_index: int, end_index: int) -> int:\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range.\n\n    Args:\n        numbers: A list of integers.\n        start_index: The starting index of the range (inclusive).\n        end_index: The ending index of the range (inclusive).\n\n    Returns:\n        The sum of the numbers within the specified range.\n    \"\"\"\n    if not numbers:\n        return 0\n\n    # Ensure indices are within valid bounds\n    start_index = max(0, start_index)\n    end_index = min(len(numbers) - 1, end_index)\n\n    # If the start index is greater than the end index after adjustment,\n    # it means the range is invalid or empty.\n    if start_index > end_index:\n        return 0\n\n    total_sum = 0\n    for i in range(start_index, end_index + 1):\n        total_sum += numbers[i]\n    return total_sum"}
{"benchmark": "mbpp", "task_id": "165", "prompt": "Write a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).", "reference_code": "def count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars ", "test_imports": [], "test_list": ["assert count_char_position(\"xbcefg\") == 2", "assert count_char_position(\"ABcED\") == 3", "assert count_char_position(\"AbgdeF\") == 5"], "model_name": "google/gemini-2.5-flash", "generated_code": "def count_char_position(text: str) -> int:\n    \"\"\"\n    Counts the number of characters in a string that occur at the same position\n    in the string as in the English alphabet (case insensitive).\n\n    For example:\n    - 'Abc' -> 'A' is the 1st letter, and it's at index 0 (1st position). 'b' is the 2nd letter,\n               and it's at index 1 (2nd position). 'c' is the 3rd letter, and it's at index 2 (3rd position).\n               So, all 3 characters match their alphabetical position.\n               Result: 3\n    - 'abc' -> Result: 3\n    - 'ABC' -> Result: 3\n    - 'aBc' -> Result: 3\n    - 'xyz' -> Result: 0 (x is 24th letter, not at index 0; y is 25th, not at index 1; z is 26th, not at index 2)\n    - 'abCdefg' -> Result: 7\n    - 'abCdefG' -> Result: 7\n    - ' ' -> Result: 0\n    - '' -> Result: 0\n    \"\"\"\n    count = 0\n    for i, char in enumerate(text):\n        # Convert character to lowercase for case-insensitive comparison\n        lower_char = char.lower()\n\n        # Check if the character is an English alphabet letter\n        if 'a' <= lower_char <= 'z':\n            # Calculate the 0-based alphabetical position\n            # 'a' is 0, 'b' is 1, ..., 'z' is 25\n            alphabetical_position = ord(lower_char) - ord('a')\n\n            # Compare with the character's 0-based index in the string\n            if alphabetical_position == i:\n                count += 1\n    return count"}
{"benchmark": "mbpp", "task_id": "166", "prompt": "Write a function that counts the number of pairs of integers in a list that xor to an even number.", "reference_code": "def find_even_pair(A): \n  count = 0\n  for i in range(0, len(A)): \n    for j in range(i+1, len(A)): \n        if ((A[i] ^ A[j]) % 2 == 0): \n          count += 1\n\n  return count", "test_imports": [], "test_list": ["assert find_even_pair([5, 4, 7, 2, 1]) == 4", "assert find_even_pair([7, 2, 8, 1, 0, 5, 11]) == 9", "assert find_even_pair([1, 2, 3]) == 1"], "model_name": "google/gemini-2.5-flash", "generated_code": "def find_even_pair(numbers: list[int]) -> int:\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n        numbers: A list of integers.\n\n    Returns:\n        The number of pairs (i, j) such that numbers[i] ^ numbers[j] is even,\n        where i < j.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n\n    for num in numbers:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    # A ^ B is even if and only if A and B have the same parity.\n    # Case 1: Both A and B are even.\n    # Number of pairs = even_count * (even_count - 1) / 2\n    \n    # Case 2: Both A and B are odd.\n    # Number of pairs = odd_count * (odd_count - 1) / 2\n\n    return (even_count * (even_count - 1) // 2) + \\\n           (odd_count * (odd_count - 1) // 2)"}
{"benchmark": "mbpp", "task_id": "172", "prompt": "Write a function to count the number of occurence of the string 'std' in a given string.", "reference_code": "def count_occurance(s):\n  count = 0\n  for i in range(len(s) - 2):\n    if (s[i] == 's' and s[i+1] == 't' and s[i+2] == 'd'):\n      count = count + 1\n  return count", "test_imports": [], "test_list": ["assert count_occurance(\"letstdlenstdporstd\") == 3", "assert count_occurance(\"truststdsolensporsd\") == 1", "assert count_occurance(\"makestdsostdworthit\") == 2", "assert count_occurance(\"stds\") == 1", "assert count_occurance(\"\") == 0"], "model_name": "google/gemini-2.5-flash", "generated_code": "def count_occurance(main_string: str) -> int:\n    \"\"\"\n    Counts the number of occurrences of the substring 'std' in a given string.\n\n    Args:\n        main_string: The string to search within.\n\n    Returns:\n        The number of times 'std' appears in the main_string.\n    \"\"\"\n    return main_string.count('std')"}
{"benchmark": "mbpp", "task_id": "222", "prompt": "Write a function to check if all the elements in tuple have same data type or not.", "reference_code": "def check_type(test_tuple):\n  res = True\n  for ele in test_tuple:\n    if not isinstance(ele, type(test_tuple[0])):\n      res = False\n      break\n  return (res) ", "test_imports": [], "test_list": ["assert check_type((5, 6, 7, 3, 5, 6) ) == True", "assert check_type((1, 2, \"4\") ) == False", "assert check_type((3, 2, 1, 4, 5) ) == True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def check_type(input_tuple: tuple) -> bool:\n    \"\"\"\n    Checks if all elements in a tuple have the same data type.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if all elements have the same data type, False otherwise.\n        Returns True for an empty tuple or a tuple with a single element.\n    \"\"\"\n    if not input_tuple or len(input_tuple) == 1:\n        return True\n\n    first_type = type(input_tuple[0])\n    for i in range(1, len(input_tuple)):\n        if type(input_tuple[i]) != first_type:\n            return False\n    return True"}
{"benchmark": "mbpp", "task_id": "224", "prompt": "Write a python function to count the number of set bits (binary digits with value 1) in a given number.", "reference_code": "def count_Set_Bits(n): \n    count = 0\n    while (n): \n        count += n & 1\n        n >>= 1\n    return count ", "test_imports": [], "test_list": ["assert count_Set_Bits(2) == 1", "assert count_Set_Bits(4) == 1", "assert count_Set_Bits(6) == 2"], "model_name": "google/gemini-2.5-flash", "generated_code": "def count_Set_Bits(n: int) -> int:\n    \"\"\"\n    Counts the number of set bits (binary digits with value 1) in a given number.\n\n    Args:\n        n: The integer number.\n\n    Returns:\n        The number of set bits in the given number.\n    \"\"\"\n    count = 0\n    while n > 0:\n        n &= (n - 1)  # This operation clears the least significant set bit\n        count += 1\n    return count"}
{"benchmark": "mbpp", "task_id": "226", "prompt": "Write a python function to remove the characters which have odd index values of a given string.", "reference_code": "def odd_values_string(str):\n  result = \"\" \n  for i in range(len(str)):\n    if i % 2 == 0:\n      result = result + str[i]\n  return result", "test_imports": [], "test_list": ["assert odd_values_string('abcdef') == 'ace'", "assert odd_values_string('python') == 'pto'", "assert odd_values_string('data') == 'dt'", "assert odd_values_string('lambs') == 'lms'"], "model_name": "google/gemini-2.5-flash", "generated_code": "def odd_values_string(s):\n    \"\"\"\n    Removes characters which have odd index values from a given string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:  # Keep characters at even indices\n            result += s[i]\n    return result"}
{"benchmark": "mbpp", "task_id": "227", "prompt": "Write a function to find minimum of three numbers.", "reference_code": "def min_of_three(a,b,c): \n      if (a <= b) and (a <= c): \n        smallest = a \n      elif (b <= a) and (b <= c): \n        smallest = b \n      else: \n        smallest = c \n      return smallest ", "test_imports": [], "test_list": ["assert min_of_three(10,20,0)==0", "assert min_of_three(19,15,18)==15", "assert min_of_three(-10,-20,-30)==-30"], "model_name": "google/gemini-2.5-flash", "generated_code": "def min_of_three(num1: float, num2: float, num3: float) -> float:\n    \"\"\"\n    Finds the minimum of three numbers.\n\n    Args:\n        num1: The first number.\n        num2: The second number.\n        num3: The third number.\n\n    Returns:\n        The minimum of the three numbers.\n    \"\"\"\n    return min(num1, num2, num3)"}
{"benchmark": "mbpp", "task_id": "230", "prompt": "Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.", "reference_code": "def replace_blank(str1,char):\n str2 = str1.replace(' ', char)\n return str2", "test_imports": [], "test_list": ["assert replace_blank(\"hello people\",'@')==(\"hello@people\")", "assert replace_blank(\"python program language\",'$')==(\"python$program$language\")", "assert replace_blank(\"blank space\",\"-\")==(\"blank-space\")"], "model_name": "google/gemini-2.5-flash", "generated_code": "def replace_blank(text: str, char: str) -> str:\n    \"\"\"\n    Replaces blank spaces in the string with the given character.\n\n    Args:\n        text: The input string.\n        char: The character to replace blank spaces with.\n\n    Returns:\n        The string with blank spaces replaced by the character.\n    \"\"\"\n    return text.replace(' ', char)"}
{"benchmark": "mbpp", "task_id": "223", "prompt": "Write a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)", "reference_code": "def is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1), x)\n\treturn -1", "test_imports": [], "test_list": ["assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True", "assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False", "assert is_majority([1, 1, 1, 2, 2], 5, 1) == True", "assert is_majority([1, 1, 2, 2], 5, 1) == False"], "model_name": "google/gemini-2.5-flash", "generated_code": "def is_majority(arr: list, n: int, x: int) -> bool:\n    \"\"\"\n    Checks if a given element x is the majority element in a sorted array arr.\n\n    A majority element is an element that occurs more than n/2 times.\n\n    Args:\n        arr: The sorted input array.\n        n: The length of the array.\n        x: The element to check for majority.\n\n    Returns:\n        True if x is the majority element, False otherwise.\n    \"\"\"\n    if n == 0:\n        return False\n\n    # Find the first occurrence of x\n    first_occurrence_index = -1\n    low, high = 0, n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            first_occurrence_index = mid\n            high = mid - 1  # Try to find an even earlier occurrence\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    if first_occurrence_index == -1:\n        return False  # x is not in the array\n\n    # Check if x occurs more than n/2 times\n    # If x is a majority element, its (first_occurrence_index + n/2)th element\n    # must also be x.\n    if first_occurrence_index + n // 2 < n and arr[first_occurrence_index + n // 2] == x:\n        return True\n    else:\n        return False"}
{"benchmark": "mbpp", "task_id": "233", "prompt": "Write a function to find the lateral surface area of a cylinder.", "reference_code": "def lateralsuface_cylinder(r,h):\n  lateralsurface= 2*3.1415*r*h\n  return lateralsurface", "test_imports": ["import math"], "test_list": ["assert math.isclose(lateralsuface_cylinder(10,5), 314.15000000000003, rel_tol=0.001)", "assert math.isclose(lateralsuface_cylinder(4,5), 125.66000000000001, rel_tol=0.001)", "assert math.isclose(lateralsuface_cylinder(4,10), 251.32000000000002, rel_tol=0.001)"], "model_name": "google/gemini-2.5-flash", "generated_code": "import math\n\ndef lateralsuface_cylinder(radius, height):\n  \"\"\"\n  Calculates the lateral surface area of a cylinder.\n\n  Args:\n    radius: The radius of the cylinder's base.\n    height: The height of the cylinder.\n\n  Returns:\n    The lateral surface area of the cylinder.\n  \"\"\"\n  return 2 * math.pi * radius * height"}
{"benchmark": "mbpp", "task_id": "234", "prompt": "Write a function to find the volume of a cube given its side length.", "reference_code": "def volume_cube(l):\n  volume = l * l * l\n  return volume", "test_imports": [], "test_list": ["assert volume_cube(3)==27", "assert volume_cube(2)==8", "assert volume_cube(5)==125"], "model_name": "google/gemini-2.5-flash", "generated_code": "def volume_cube(side_length):\n  \"\"\"\n  Calculates the volume of a cube given its side length.\n\n  Args:\n    side_length: The length of one side of the cube.\n\n  Returns:\n    The volume of the cube.\n  \"\"\"\n  return side_length ** 3"}
{"benchmark": "mbpp", "task_id": "228", "prompt": "Write a python function to check whether all the bits are unset in the given range or not.", "reference_code": "def all_Bits_Set_In_The_Given_Range(n,l,r):  \n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \n    new_num = n & num\n    if (new_num == 0): \n        return True\n    return False", "test_imports": [], "test_list": ["assert all_Bits_Set_In_The_Given_Range(4,1,2) == True", "assert all_Bits_Set_In_The_Given_Range(17,2,4) == True", "assert all_Bits_Set_In_The_Given_Range(39,4,6) == False"], "model_name": "google/gemini-2.5-flash", "generated_code": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    \"\"\"\n    Checks if all bits in the given range [l, r] (1-indexed) are unset (0) in the number n.\n\n    Args:\n        n (int): The number to check.\n        l (int): The left boundary of the range (1-indexed).\n        r (int): The right boundary of the range (1-indexed).\n\n    Returns:\n        bool: True if all bits in the range [l, r] are unset, False otherwise.\n    \"\"\"\n    # Create a mask for the given range.\n    # The mask will have 1s in the range [l, r] and 0s elsewhere.\n    # (1 << r) - 1 creates a number with r set bits from the right.\n    # (1 << (l - 1)) - 1 creates a number with (l-1) set bits from the right.\n    # Subtracting them gives a mask with 1s from bit l to bit r.\n    mask = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1)\n\n    # Perform a bitwise AND operation between n and the mask.\n    # If all bits in the range [l, r] are unset in n, then the result of\n    # this AND operation will be 0.\n    return (n & mask) == 0"}
{"benchmark": "mbpp", "task_id": "229", "prompt": "Write a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.", "reference_code": "def re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr", "test_imports": [], "test_list": ["assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]", "assert re_arrange_array([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]", "assert re_arrange_array([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def re_arrange_array(arr: list, n: int) -> None:\n    \"\"\"\n    Re-arranges the first n elements of the given array so that all negative elements\n    appear before positive ones, and where the relative order among negative and\n    positive elements is preserved.\n\n    Args:\n        arr: The input list of numbers.\n        n: The number of elements to consider for re-arrangement.\n    \"\"\"\n    if n <= 0 or n > len(arr):\n        return\n\n    # Create two temporary lists to store negative and positive numbers\n    # from the first n elements, preserving their relative order.\n    negatives = []\n    positives = []\n\n    for i in range(n):\n        if arr[i] < 0:\n            negatives.append(arr[i])\n        else:\n            positives.append(arr[i])\n\n    # Overwrite the first n elements of the original array with\n    # the collected negative numbers followed by positive numbers.\n    current_index = 0\n    for num in negatives:\n        arr[current_index] = num\n        current_index += 1\n    for num in positives:\n        arr[current_index] = num\n        current_index += 1"}
{"benchmark": "mbpp", "task_id": "237", "prompt": "Write a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.", "reference_code": "from collections import Counter \ndef check_occurences(test_list):\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\n  return  (res) ", "test_imports": [], "test_list": ["assert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)] ) == {(1, 3): 2, (2, 5): 2, (3, 6): 1}", "assert check_occurences([(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)] ) == {(2, 4): 2, (3, 6): 2, (4, 7): 1}", "assert check_occurences([(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)] ) == {(2, 13): 1, (11, 23): 1, (12, 25): 2, (16, 23): 1}"], "model_name": "google/gemini-2.5-flash", "generated_code": "from collections import defaultdict\n\ndef check_occurences(list_of_tuples):\n    \"\"\"\n    Takes in a list of tuples and returns a dictionary mapping each unique tuple\n    to the number of times it occurs in the list.\n\n    Args:\n        list_of_tuples: A list of tuples.\n\n    Returns:\n        A dictionary where keys are unique tuples from the input list and\n        values are their respective counts.\n    \"\"\"\n    occurrence_counts = defaultdict(int)\n    for item_tuple in list_of_tuples:\n        occurrence_counts[item_tuple] += 1\n    return dict(occurrence_counts)"}
{"benchmark": "mbpp", "task_id": "125", "prompt": "Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.", "reference_code": "def find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0", "test_imports": [], "test_list": ["assert find_length(\"11000010001\") == 6", "assert find_length(\"10111\") == 1", "assert find_length(\"11011101100101\") == 2"], "model_name": "google/gemini-2.5-flash", "generated_code": "def find_length(s: str) -> int:\n    \"\"\"\n    Finds the maximum difference between the number of 0s and number of 1s\n    in any sub-string of the given binary string.\n\n    Args:\n        s: The input binary string.\n\n    Returns:\n        The maximum difference.\n    \"\"\"\n    max_diff = 0\n    current_diff = 0\n\n    for char in s:\n        if char == '0':\n            current_diff += 1\n        else:  # char == '1'\n            current_diff -= 1\n\n        if current_diff < 0:\n            current_diff = 0\n        \n        max_diff = max(max_diff, current_diff)\n    \n    # If all characters are '1', max_diff will be 0.\n    # In this case, the problem implies we should return -1 for a single '1'\n    # or the maximum difference for a substring of '0's.\n    # However, the problem statement \"maximum difference between the number of 0s and number of 1s\"\n    # implies that if there are no 0s, the max difference would be 0 - count_of_1s, which is negative.\n    # Kadane's algorithm for max subarray sum handles this by returning 0 if all elements are negative.\n    # If the problem implies that a substring must contain at least one '0' to contribute positively,\n    # or if the difference can be negative, the interpretation changes.\n    # Given the standard interpretation of \"maximum difference\" in similar problems,\n    # we are looking for the maximum positive difference.\n    # If the string contains only '1's, the maximum difference of (0s - 1s) will be negative.\n    # The problem statement is a bit ambiguous for the all '1's case.\n    # Assuming we want the maximum positive difference, if all are '1's, the max_diff will be 0.\n    # If the problem implies that if there are no '0's, the answer should be -1 (e.g., for \"111\"),\n    # then we need an additional check.\n    # Let's assume the standard Kadane's application where we want the maximum sum,\n    # and if all sums are negative, the max sum is the largest negative sum.\n    # But here, we reset current_diff to 0 if it goes negative, which means we are looking for\n    # the maximum positive difference.\n\n    # If the string contains only '1's, max_diff will be 0.\n    # The problem statement implies that if there are no '0's, the difference is negative.\n    # For example, for \"111\", the difference for any substring is negative (e.g., \"1\" -> -1, \"11\" -> -2).\n    # If the expected output for \"111\" is -1, then we need to handle this.\n    # A common interpretation for \"maximum difference\" when 0s are positive and 1s are negative\n    # is to return the maximum positive difference. If no positive difference is possible,\n    # then the maximum difference would be the smallest (least negative) difference.\n    # However, the Kadane's modification (resetting to 0) typically finds the max sum of a subarray\n    # that must be non-negative.\n\n    # Let's re-evaluate based on typical competitive programming problem interpretations.\n    # If the string is \"111\", the differences are -1, -2, -3. The max is -1.\n    # If the string is \"000\", the differences are 1, 2, 3. The max is 3.\n    # If the string is \"101\", \"0\" -> 1, \"10\" -> 0, \"01\" -> 0. Max is 1.\n    # The current Kadane's approach finds the maximum sum of a subarray where elements are 1 for '0' and -1 for '1'.\n    # If all elements are -1 (string \"111\"), current_diff will always be reset to 0, and max_diff will remain 0.\n    # This is usually not the desired behavior if the actual maximum difference is negative.\n\n    # A more robust Kadane's for maximum subarray sum (allowing negative results):\n    # max_so_far = -infinity\n    # current_max = 0\n    # for x in array:\n    #   current_max += x\n    #   max_so_far = max(max_so_far, current_max)\n    #   if current_max < 0:\n    #     current_max = 0\n    # This version still returns 0 if all elements are negative.\n\n    # To handle cases where all differences are negative (e.g., \"111\"),\n    # we need to ensure max_diff can be negative.\n    # Let's re-implement Kadane's to correctly handle all negative sums.\n    # We convert '0' to 1 and '1' to -1.\n    \n    if not s:\n        return 0 # Or raise an error, depending on problem constraints for empty string.\n\n    arr = []\n    for char in s:\n        if char == '0':\n            arr.append(1)\n        else:\n            arr.append(-1)\n\n    max_so_far = float('-inf')\n    current_max = 0\n    \n    # Flag to check if there was at least one '0' in the string\n    # This is to handle the specific case where the problem might want -1 for all '1's.\n    has_zero = False\n    for x in arr:\n        if x == 1:\n            has_zero = True\n        \n        current_max += x\n        max_so_far = max(max_so_far, current_max)\n        if current_max < 0:\n            current_max = 0\n            \n    # The above Kadane's (resetting to 0) will return 0 if all elements are -1.\n    # If the problem expects -1 for \"111\", then we need to adjust.\n    # If the problem expects the maximum actual difference (which can be negative),\n    # then a different Kadane's is needed.\n\n    # Let's assume the problem implies that if there are no '0's, the answer is -1.\n    # This is a common edge case handling for this specific problem.\n    if not has_zero:\n        return -1\n    \n    # If there is at least one '0', the max_so_far from the Kadane's (resetting to 0)\n    # will correctly give the maximum positive difference.\n    # For example, \"101\", arr = [-1, 1, -1].\n    # current_max = 0, max_so_far = -inf\n    # x = -1: current_max = -1, max_so_far = -1. current_max < 0, current_max = 0.\n    # x = 1: current_max = 1, max_so_far = 1.\n    # x = -1: current_max = 0, max_so_far = 1. current_max < 0, current_max = 0.\n    # Result: 1. This is correct for \"101\" (substring \"0\").\n\n    # Example \"000\", arr = [1, 1, 1]\n    # x = 1: current_max = 1, max_so_far = 1\n    # x = 1: current_max = 2, max_so_far = 2\n    # x = 1: current_max = 3, max_so_far = 3\n    # Result: 3. Correct.\n\n    # The only remaining ambiguity is if the string contains only '1's.\n    # If `has_zero` is False, we return -1. Otherwise, we return `max_so_far`.\n    return max_so_far"}
{"benchmark": "mbpp", "task_id": "232", "prompt": "Write a function that takes in a list and an integer n and returns a list containing the n largest items from the list.", "reference_code": "import heapq\ndef larg_nnum(list1,n):\n largest=heapq.nlargest(n,list1)\n return largest", "test_imports": [], "test_list": ["assert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2))==set([100,90])", "assert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],5))==set([100,90,80,70,60])", "assert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],3))==set([100,90,80])"], "model_name": "google/gemini-2.5-flash", "generated_code": "def larg_nnum(lst, n):\n    \"\"\"\n    Returns a list containing the n largest items from the input list.\n\n    Args:\n        lst (list): The input list of numbers.\n        n (int): The number of largest items to retrieve.\n\n    Returns:\n        list: A new list containing the n largest items from the input list,\n              sorted in ascending order. If n is greater than or equal to\n              the length of the list, the entire sorted list is returned.\n              If n is 0 or negative, an empty list is returned.\n    \"\"\"\n    if not lst or n <= 0:\n        return []\n\n    # Sort the list in descending order and take the first n elements\n    # Then sort these n elements in ascending order as per typical interpretation\n    # of \"largest items\" often implying a sorted sublist.\n    # If the problem implies just the n largest in any order,\n    # then `sorted_lst[:n]` would suffice.\n    # However, \"n largest items from the list\" usually means the items themselves,\n    # and returning them sorted is a common and useful convention.\n    sorted_lst = sorted(lst, reverse=True)\n    return sorted(sorted_lst[:n])"}
{"benchmark": "mbpp", "task_id": "242", "prompt": "Write a function to count the total number of characters in a string.", "reference_code": "def count_charac(str1):\n total = 0\n for i in str1:\n    total = total + 1\n return total", "test_imports": [], "test_list": ["assert count_charac(\"python programming\")==18", "assert count_charac(\"language\")==8", "assert count_charac(\"words\")==5"], "model_name": "google/gemini-2.5-flash", "generated_code": "def count_charac(text):\n  \"\"\"\n  Counts the total number of characters in a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The total number of characters in the string.\n  \"\"\"\n  return len(text)"}
{"benchmark": "mbpp", "task_id": "240", "prompt": "Write a function that takes in two lists and replaces the last element of the first list with the elements of the second list.", "reference_code": "def replace_list(list1,list2):\n list1[-1:] = list2\n replace_list=list1\n return replace_list\n", "test_imports": [], "test_list": ["assert replace_list([1, 3, 5, 7, 9, 10],[2, 4, 6, 8])==[1, 3, 5, 7, 9, 2, 4, 6, 8]", "assert replace_list([1,2,3,4,5],[5,6,7,8])==[1,2,3,4,5,6,7,8]", "assert replace_list([\"red\",\"blue\",\"green\"],[\"yellow\"])==[\"red\",\"blue\",\"yellow\"]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def replace_list(list1: list, list2: list) -> list:\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        A new list with the last element of list1 replaced by the elements of list2.\n        If list1 is empty, it returns list2.\n    \"\"\"\n    if not list1:\n        return list2[:]  # Return a copy of list2 if list1 is empty\n\n    return list1[:-1] + list2"}
{"benchmark": "mbpp", "task_id": "238", "prompt": "Write a python function to count the number of non-empty substrings of a given string.", "reference_code": "def number_of_substrings(str): \n\tstr_len = len(str); \n\treturn int(str_len * (str_len + 1) / 2); ", "test_imports": [], "test_list": ["assert number_of_substrings(\"abc\") == 6", "assert number_of_substrings(\"abcd\") == 10", "assert number_of_substrings(\"abcde\") == 15"], "model_name": "google/gemini-2.5-flash", "generated_code": "def number_of_substrings(s: str) -> int:\n    \"\"\"\n    Counts the number of non-empty substrings of a given string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The total number of non-empty substrings.\n    \"\"\"\n    n = len(s)\n    # The number of non-empty substrings of a string of length n is given by the formula n * (n + 1) / 2.\n    # This is because for each starting position i (from 0 to n-1),\n    # there are (n - i) possible ending positions, leading to (n - i) substrings.\n    # Summing (n - i) for i from 0 to n-1 gives n + (n-1) + ... + 1, which is n * (n + 1) / 2.\n    return n * (n + 1) // 2"}
{"benchmark": "mbpp", "task_id": "235", "prompt": "Write a python function to set all even bits of a given number.", "reference_code": "def even_bit_set_number(n): \n    count = 0;res = 0;temp = n \n    while(temp > 0): \n        if (count % 2 == 1): \n            res |= (1 << count)\n        count+=1\n        temp >>= 1\n    return (n | res) ", "test_imports": [], "test_list": ["assert even_bit_set_number(10) == 10", "assert even_bit_set_number(20) == 30", "assert even_bit_set_number(30) == 30"], "model_name": "google/gemini-2.5-flash", "generated_code": "def even_bit_set_number(number: int) -> int:\n    \"\"\"\n    Sets all even bits of a given number.\n\n    An even bit is a bit at an even position (0, 2, 4, ...).\n    The least significant bit is at position 0.\n\n    Args:\n        number: The input integer.\n\n    Returns:\n        The integer with all its even bits set to 1.\n    \"\"\"\n    # Create a mask with all even bits set to 1.\n    # We can achieve this by starting with 1 (bit 0 set),\n    # then shifting it left by 2, ORing with the previous, and so on.\n    # A more efficient way is to use a precomputed mask or generate it\n    # based on the maximum possible bit length for an integer.\n    # For typical Python integers, they can be arbitrarily large.\n    # We need to determine the highest bit set in the input number\n    # to know how far the mask needs to extend.\n\n    # Find the highest bit position in the number\n    if number == 0:\n        return 1  # If number is 0, only bit 0 needs to be set.\n\n    temp_num = number\n    highest_bit_pos = -1\n    while temp_num > 0:\n        highest_bit_pos += 1\n        temp_num >>= 1\n\n    # Create the mask\n    mask = 0\n    for i in range(0, highest_bit_pos + 2, 2):  # +2 to ensure we cover the highest bit and potentially one more even bit\n        mask |= (1 << i)\n\n    # OR the number with the mask to set all even bits\n    return number | mask"}
{"benchmark": "mbpp", "task_id": "239", "prompt": "Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.", "reference_code": "def get_total_number_of_sequences(m,n): \n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \n\tfor i in range(m+1): \n\t\tfor j in range(n+1): \n\t\t\tif i==0 or j==0: \n\t\t\t\tT[i][j]=0\n\t\t\telif i<j: \n\t\t\t\tT[i][j]=0\n\t\t\telif j==1: \n\t\t\t\tT[i][j]=i \n\t\t\telse: \n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \n\treturn T[m][n]", "test_imports": [], "test_list": ["assert get_total_number_of_sequences(10, 4) == 4", "assert get_total_number_of_sequences(5, 2) == 6", "assert get_total_number_of_sequences(16, 3) == 84"], "model_name": "google/gemini-2.5-flash", "generated_code": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Calculates the number of possible sequences of length n, such that each element\n    is a positive integer and is greater than or equal to twice the previous element\n    but less than or equal to m.\n\n    Args:\n        m: The maximum allowed value for any element in the sequence.\n        n: The desired length of the sequence.\n\n    Returns:\n        The total number of such sequences.\n    \"\"\"\n\n    # dp[i][j] will store the number of sequences of length i ending with j.\n    # The first dimension is for sequence length (from 1 to n).\n    # The second dimension is for the last element's value (from 1 to m).\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    # Base case: Sequences of length 1.\n    # Any number from 1 to m can be the first element.\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n\n    # Fill the DP table for sequences of length 2 to n.\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):  # Current element value\n            # The previous element (k) must satisfy k * 2 <= j.\n            # So, k can range from 1 up to j // 2.\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n\n    # The total number of sequences of length n is the sum of all\n    # dp[n][j] for j from 1 to m.\n    total_sequences = sum(dp[n][j] for j in range(1, m + 1))\n\n    return total_sequences"}
{"benchmark": "mbpp", "task_id": "249", "prompt": "Write a function to find the intersection of two arrays.", "reference_code": "def intersection_array(array_nums1,array_nums2):\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \n return result", "test_imports": [], "test_list": ["assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[1, 2, 4, 8, 9])==[1, 2, 8, 9]", "assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[3,5,7,9])==[3,5,7,9]", "assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[10,20,30,40])==[10]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def intersection_array(arr1: list[int], arr2: list[int]) -> list[int]:\n    \"\"\"\n    Finds the intersection of two arrays.\n\n    Args:\n        arr1: The first input array of integers.\n        arr2: The second input array of integers.\n\n    Returns:\n        A list containing the common elements present in both arrays.\n        The order of elements in the result is not guaranteed.\n    \"\"\"\n    set1 = set(arr1)\n    set2 = set(arr2)\n    return list(set1.intersection(set2))"}
{"benchmark": "mbpp", "task_id": "246", "prompt": "Write a function for computing square roots using the babylonian method.", "reference_code": "def babylonian_squareroot(number):\n    if(number == 0):\n        return 0;\n    g = number/2.0;\n    g2 = g + 1;\n    while(g != g2):\n        n = number/ g;\n        g2 = g;\n        g = (g + n)/2;\n    return g;", "test_imports": ["import math"], "test_list": ["assert math.isclose(babylonian_squareroot(10), 3.162277660168379, rel_tol=0.001)", "assert math.isclose(babylonian_squareroot(2), 1.414213562373095, rel_tol=0.001)", "assert math.isclose(babylonian_squareroot(9), 3.0, rel_tol=0.001)"], "model_name": "google/gemini-2.5-flash", "generated_code": "def babylonian_squareroot(number, tolerance=0.00001):\n    \"\"\"\n    Computes the square root of a non-negative number using the Babylonian method.\n\n    Args:\n        number (float or int): The non-negative number for which to compute the square root.\n        tolerance (float): The desired level of accuracy for the square root.\n\n    Returns:\n        float: The approximate square root of the number.\n\n    Raises:\n        ValueError: If the input number is negative.\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Cannot compute the square root of a negative number.\")\n    if number == 0:\n        return 0.0\n\n    guess = number / 2.0  # Initial guess\n    if guess == 0: # Handle cases where number is very small but not zero\n        guess = 1.0\n\n    while True:\n        next_guess = 0.5 * (guess + number / guess)\n        if abs(next_guess - guess) < tolerance:\n            return next_guess\n        guess = next_guess"}
{"benchmark": "mbpp", "task_id": "248", "prompt": "Write a function that takes in an integer n and calculates the harmonic sum of n-1.", "reference_code": "def harmonic_sum(n):\n  if n < 2:\n    return 1\n  else:\n    return 1 / n + (harmonic_sum(n - 1)) ", "test_imports": ["import math"], "test_list": ["assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)", "assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)", "assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)"], "model_name": "google/gemini-2.5-flash", "generated_code": "def harmonic_sum(n: int) -> float:\n    \"\"\"\n    Calculates the harmonic sum of n-1.\n    The harmonic sum H_k is defined as 1 + 1/2 + 1/3 + ... + 1/k.\n    If n-1 is 0 or negative, the harmonic sum is 0.0.\n\n    Args:\n        n: An integer. The harmonic sum will be calculated for (n-1).\n\n    Returns:\n        The harmonic sum of (n-1) as a float.\n    \"\"\"\n    k = n - 1\n    if k <= 0:\n        return 0.0\n    \n    s = 0.0\n    for i in range(1, k + 1):\n        s += 1 / i\n    return s"}
{"benchmark": "mbpp", "task_id": "247", "prompt": "Write a function to find the length of the longest palindromic subsequence in the given string.", "reference_code": "def lps(str): \n\tn = len(str) \n\tL = [[0 for x in range(n)] for x in range(n)] \n\tfor i in range(n): \n\t\tL[i][i] = 1\n\tfor cl in range(2, n+1): \n\t\tfor i in range(n-cl+1): \n\t\t\tj = i+cl-1\n\t\t\tif str[i] == str[j] and cl == 2: \n\t\t\t\tL[i][j] = 2\n\t\t\telif str[i] == str[j]: \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\n\t\t\telse: \n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\treturn L[0][n-1]", "test_imports": [], "test_list": ["assert lps(\"TENS FOR TENS\") == 5", "assert lps(\"CARDIO FOR CARDS\") == 7", "assert lps(\"PART OF THE JOURNEY IS PART\") == 9"], "model_name": "google/gemini-2.5-flash", "generated_code": "def lps(s: str) -> int:\n    \"\"\"\n    Finds the length of the longest palindromic subsequence in the given string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The length of the longest palindromic subsequence.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # dp[i][j] stores the length of the longest palindromic subsequence\n    # of the substring s[i...j]\n    dp = [[0] * n for _ in range(n)]\n\n    # All substrings of length 1 are palindromes of length 1\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Fill the dp table for lengths from 2 to n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                if length == 2:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]"}
{"benchmark": "mbpp", "task_id": "250", "prompt": "Write a python function that takes in a tuple and an element and counts the occcurences of the element in the tuple.", "reference_code": "def count_X(tup, x): \n    count = 0\n    for ele in tup: \n        if (ele == x): \n            count = count + 1\n    return count ", "test_imports": [], "test_list": ["assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),4) == 0", "assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),10) == 3", "assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),8) == 4"], "model_name": "google/gemini-2.5-flash", "generated_code": "def count_X(tup, x):\n    \"\"\"\n    Counts the occurrences of an element in a tuple.\n\n    Args:\n        tup: The input tuple.\n        x: The element to count.\n\n    Returns:\n        The number of times x appears in tup.\n    \"\"\"\n    count = 0\n    for item in tup:\n        if item == x:\n            count += 1\n    return count"}
{"benchmark": "mbpp", "task_id": "253", "prompt": "Write a python function that returns the number of integer elements in a given list.", "reference_code": "def count_integer(list1):\n    ctr = 0\n    for i in list1:\n        if isinstance(i, int):\n            ctr = ctr + 1\n    return ctr", "test_imports": [], "test_list": ["assert count_integer([1,2,'abc',1.2]) == 2", "assert count_integer([1,2,3]) == 3", "assert count_integer([1,1.2,4,5.1]) == 2"], "model_name": "google/gemini-2.5-flash", "generated_code": "def count_integer(data_list: list) -> int:\n    \"\"\"\n    Counts the number of integer elements in a given list.\n\n    Args:\n        data_list: A list containing elements of various types.\n\n    Returns:\n        The number of integer elements in the list.\n    \"\"\"\n    count = 0\n    for item in data_list:\n        if isinstance(item, int):\n            count += 1\n    return count"}
{"benchmark": "mbpp", "task_id": "251", "prompt": "Write a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.", "reference_code": "def insert_element(list,element):\n list = [v for elt in list for v in (element, elt)]\n return list", "test_imports": [], "test_list": ["assert insert_element(['Red', 'Green', 'Black'] ,'c')==['c', 'Red', 'c', 'Green', 'c', 'Black']", "assert insert_element(['python', 'java'] ,'program')==['program', 'python', 'program', 'java']", "assert insert_element(['happy', 'sad'] ,'laugh')==['laugh', 'happy', 'laugh', 'sad']"], "model_name": "google/gemini-2.5-flash", "generated_code": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in the given list.\n\n    Args:\n        lst: The original list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result"}
{"benchmark": "mbpp", "task_id": "252", "prompt": "Write a python function to convert complex numbers to polar coordinates.", "reference_code": "import cmath  \ndef convert(numbers):    \n  num = cmath.polar(numbers)  \n  return (num) ", "test_imports": [], "test_list": ["assert convert(1) == (1.0, 0.0)", "assert convert(4) == (4.0,0.0)", "assert convert(5) == (5.0,0.0)"], "model_name": "google/gemini-2.5-flash", "generated_code": "import cmath\n\ndef convert(complex_num: complex) -> tuple[float, float]:\n    \"\"\"\n    Converts a complex number to its polar coordinates (magnitude, phase).\n\n    Args:\n        complex_num: The complex number to convert.\n\n    Returns:\n        A tuple containing:\n            - The magnitude (r) of the complex number.\n            - The phase (phi) in radians of the complex number.\n    \"\"\"\n    magnitude = abs(complex_num)\n    phase = cmath.phase(complex_num)\n    return (magnitude, phase)"}
{"benchmark": "mbpp", "task_id": "255", "prompt": "Write a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a tuple for each combination.", "reference_code": "from itertools import combinations_with_replacement \ndef combinations_colors(l, n):\n    return list(combinations_with_replacement(l,n))\n", "test_imports": [], "test_list": ["assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],1)==[('Red',), ('Green',), ('Blue',)]", "assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],2)==[('Red', 'Red'), ('Red', 'Green'), ('Red', 'Blue'), ('Green', 'Green'), ('Green', 'Blue'), ('Blue', 'Blue')]", "assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],3)==[('Red', 'Red', 'Red'), ('Red', 'Red', 'Green'), ('Red', 'Red', 'Blue'), ('Red', 'Green', 'Green'), ('Red', 'Green', 'Blue'), ('Red', 'Blue', 'Blue'), ('Green', 'Green', 'Green'), ('Green', 'Green', 'Blue'), ('Green', 'Blue', 'Blue'), ('Blue', 'Blue', 'Blue')]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def combinations_colors(colors, n):\n    \"\"\"\n    Generates all combinations (with repetition) of the elements of the given list\n    and returns a list with a tuple for each combination.\n\n    Args:\n        colors: A list of elements.\n        n: The length of each combination.\n\n    Returns:\n        A list of tuples, where each tuple is a combination with repetition.\n    \"\"\"\n    if n < 0:\n        return []\n    if n == 0:\n        return [()]\n\n    result = []\n    \n    def backtrack(current_combination, start_index):\n        if len(current_combination) == n:\n            result.append(tuple(current_combination))\n            return\n\n        for i in range(start_index, len(colors)):\n            current_combination.append(colors[i])\n            backtrack(current_combination, i)  # Allow repetition by starting from i\n            current_combination.pop()\n\n    backtrack([], 0)\n    return result"}
{"benchmark": "mbpp", "task_id": "256", "prompt": "Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.", "reference_code": "def count_Primes_nums(n):\n    ctr = 0\n    for num in range(n):\n        if num <= 1:\n            continue\n        for i in range(2,num):\n            if (num % i) == 0:\n                break\n        else:\n            ctr += 1\n    return ctr", "test_imports": [], "test_list": ["assert count_Primes_nums(5) == 2", "assert count_Primes_nums(10) == 4", "assert count_Primes_nums(100) == 25"], "model_name": "google/gemini-2.5-flash", "generated_code": "def count_Primes_nums(num: int) -> int:\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number.\n\n    Args:\n        num: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than 'num'.\n    \"\"\"\n    if num <= 2:\n        return 0\n\n    is_prime = [True] * num\n    is_prime[0] = is_prime[1] = False\n\n    for p in range(2, int(num**0.5) + 1):\n        if is_prime[p]:\n            for multiple in range(p * p, num, p):\n                is_prime[multiple] = False\n\n    count = 0\n    for i in range(num):\n        if is_prime[i]:\n            count += 1\n    return count"}
{"benchmark": "mbpp", "task_id": "257", "prompt": "Write a function that takes in two numbers and returns a tuple with the second number and then the first number.", "reference_code": "def swap_numbers(a,b):\n temp = a\n a = b\n b = temp\n return (a,b)", "test_imports": [], "test_list": ["assert swap_numbers(10,20)==(20,10)", "assert swap_numbers(15,17)==(17,15)", "assert swap_numbers(100,200)==(200,100)"], "model_name": "google/gemini-2.5-flash", "generated_code": "def swap_numbers(num1: int, num2: int) -> tuple[int, int]:\n    \"\"\"\n    Swaps two numbers and returns them as a tuple.\n\n    Args:\n        num1: The first number.\n        num2: The second number.\n\n    Returns:\n        A tuple containing the second number followed by the first number.\n    \"\"\"\n    return (num2, num1)"}
{"benchmark": "mbpp", "task_id": "259", "prompt": "Write a function to maximize the given two tuples.", "reference_code": "def maximize_elements(test_tup1, test_tup2):\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "test_imports": [], "test_list": ["assert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))", "assert maximize_elements(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((7, 8), (5, 10), (3, 10), (8, 11))", "assert maximize_elements(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((8, 9), (6, 11), (4, 11), (9, 12))"], "model_name": "google/gemini-2.5-flash", "generated_code": "def maximize_elements(tuple1, tuple2):\n    \"\"\"\n    Maximizes elements of two tuples by taking the maximum of corresponding elements.\n    If tuples have different lengths, the shorter tuple is padded with its last element\n    to match the length of the longer tuple before comparison.\n\n    Args:\n        tuple1 (tuple): The first input tuple.\n        tuple2 (tuple): The second input tuple.\n\n    Returns:\n        tuple: A new tuple where each element is the maximum of the corresponding\n               elements from the (potentially padded) input tuples.\n    \"\"\"\n    len1 = len(tuple1)\n    len2 = len(tuple2)\n\n    if len1 == 0 and len2 == 0:\n        return ()\n    elif len1 == 0:\n        return tuple2\n    elif len2 == 0:\n        return tuple1\n\n    max_len = max(len1, len2)\n    result = []\n\n    for i in range(max_len):\n        val1 = tuple1[i] if i < len1 else tuple1[len1 - 1]\n        val2 = tuple2[i] if i < len2 else tuple2[len2 - 1]\n        result.append(max(val1, val2))\n\n    return tuple(result)"}
{"benchmark": "mbpp", "task_id": "262", "prompt": "Write a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.", "reference_code": "def split_two_parts(list1, L):\n    return list1[:L], list1[L:]", "test_imports": [], "test_list": ["assert split_two_parts([1,1,2,3,4,4,5,1],3)==([1, 1, 2], [3, 4, 4, 5, 1])", "assert split_two_parts(['a', 'b', 'c', 'd'],2)==(['a', 'b'], ['c', 'd'])", "assert split_two_parts(['p', 'y', 't', 'h', 'o', 'n'],4)==(['p', 'y', 't', 'h'], ['o', 'n'])"], "model_name": "google/gemini-2.5-flash", "generated_code": "def split_two_parts(list_data: list, L: int) -> tuple:\n    \"\"\"\n    Splits the given list into two parts where the length of the first part of the list is L,\n    and returns the resulting lists in a tuple.\n\n    Args:\n        list_data: The input list to be split.\n        L: The desired length of the first part of the list.\n\n    Returns:\n        A tuple containing two lists: (first_part, second_part).\n    \"\"\"\n    first_part = list_data[:L]\n    second_part = list_data[L:]\n    return (first_part, second_part)"}
{"benchmark": "mbpp", "task_id": "244", "prompt": "Write a python function to find the next perfect square greater than a given number.", "reference_code": "import math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN ", "test_imports": [], "test_list": ["assert next_Perfect_Square(35) == 36", "assert next_Perfect_Square(6) == 9", "assert next_Perfect_Square(9) == 16"], "model_name": "google/gemini-2.5-flash", "generated_code": "import math\n\ndef next_Perfect_Square(num: int) -> int:\n    \"\"\"\n    Finds the next perfect square greater than a given number.\n\n    Args:\n        num: An integer.\n\n    Returns:\n        The next perfect square greater than 'num'.\n    \"\"\"\n    if num < 0:\n        # For negative numbers, the smallest perfect square is 0.\n        # The next perfect square greater than a negative number would be 0\n        # if num is -1, -2, etc.\n        # However, the problem implies finding a square *greater* than num.\n        # The smallest non-negative perfect square is 0.\n        # If num is -5, sqrt(0) = 0, next is 1.\n        # If num is -1, sqrt(0) = 0, next is 1.\n        # The logic below handles this correctly by taking ceil(sqrt(num+1))\n        # For num = -5, num+1 = -4, sqrt(-4) is complex.\n        # Let's consider the smallest perfect square to be 0.\n        # If num is negative, the next perfect square greater than it\n        # would be the square of ceil(sqrt(0)) which is 0, or 1 if 0 is not strictly greater.\n        # The problem implies finding a square *greater* than num.\n        # The smallest perfect square is 0. If num is negative, 0 is greater than num.\n        # The next perfect square after 0 is 1.\n        # So, if num is negative, the smallest perfect square greater than it is 0.\n        # The *next* perfect square after that would be 1.\n        # Let's re-evaluate: if num = -5, next perfect square > -5 is 0.\n        # If num = -1, next perfect square > -1 is 0.\n        # The problem asks for *the* next perfect square, implying a unique one.\n        # The standard interpretation for \"next perfect square\" usually starts from non-negative integers.\n        # Let's assume the input 'num' can be negative, but we are looking for a non-negative perfect square.\n        # The smallest perfect square is 0. If num < 0, then 0 is a perfect square greater than num.\n        # The *next* perfect square after 0 is 1.\n        # So, if num is negative, the smallest perfect square greater than it is 0.\n        # The *next* perfect square after that would be 1.\n        # This interpretation seems to align with the general understanding of \"next\".\n        # However, a simpler interpretation is to just find the smallest integer 'x' such that x*x > num.\n        # If num = -5, sqrt(-5) is complex.\n        # Let's consider the smallest non-negative integer whose square is greater than num.\n        # If num = -5, 0*0 = 0 > -5. So 0 is the first. The next would be 1*1 = 1.\n        # If num = -1, 0*0 = 0 > -1. So 0 is the first. The next would be 1*1 = 1.\n        # This means for any negative num, the answer is 1.\n        # Let's stick to the positive number logic and see if it naturally handles negative.\n        # If num is negative, we want the smallest perfect square k*k such that k*k > num.\n        # The smallest perfect square is 0. If num < 0, then 0 > num.\n        # So, the smallest perfect square greater than a negative num is 0.\n        # The *next* perfect square after that would be 1.\n        # This seems to be the most consistent interpretation.\n        return 1\n\n    # Calculate the square root of num\n    sqrt_num = math.isqrt(num)\n\n    # If num is a perfect square, the next perfect square is (sqrt_num + 1)^2\n    if sqrt_num * sqrt_num == num:\n        return (sqrt_num + 1) ** 2\n    else:\n        # If num is not a perfect square, the next perfect square is (floor(sqrt_num) + 1)^2\n        # math.isqrt already gives floor(sqrt_num)\n        return (sqrt_num + 1) ** 2"}
{"benchmark": "mbpp", "task_id": "261", "prompt": "Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.", "reference_code": "def division_elements(test_tup1, test_tup2):\n  res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) ", "test_imports": [], "test_list": ["assert division_elements((10, 4, 6, 9),(5, 2, 3, 3)) == (2, 2, 2, 3)", "assert division_elements((12, 6, 8, 16),(6, 3, 4, 4)) == (2, 2, 2, 4)", "assert division_elements((20, 14, 36, 18),(5, 7, 6, 9)) == (4, 2, 6, 2)"], "model_name": "google/gemini-2.5-flash", "generated_code": "def division_elements(tuple1, tuple2):\n    \"\"\"\n    Performs element-wise division of two tuples.\n\n    Args:\n        tuple1 (tuple): The first tuple (numerator).\n        tuple2 (tuple): The second tuple (denominator).\n\n    Returns:\n        tuple: A new tuple containing the results of the element-wise division.\n               If the tuples have different lengths, the result tuple's length\n               will be the minimum of the two input tuple lengths.\n               If an element in tuple2 is zero, a ZeroDivisionError will be raised.\n    \"\"\"\n    min_len = min(len(tuple1), len(tuple2))\n    result = []\n    for i in range(min_len):\n        if tuple2[i] == 0:\n            raise ZeroDivisionError(\"Cannot divide by zero.\")\n        result.append(tuple1[i] / tuple2[i])\n    return tuple(result)"}
{"benchmark": "mbpp", "task_id": "264", "prompt": "Write a function to calculate a dog's age in dog's years.", "reference_code": "def dog_age(h_age):\n if h_age < 0:\n \texit()\n elif h_age <= 2:\n\t d_age = h_age * 10.5\n else:\n\t d_age = 21 + (h_age - 2)*4\n return d_age", "test_imports": [], "test_list": ["assert dog_age(12)==61", "assert dog_age(15)==73", "assert dog_age(24)==109"], "model_name": "google/gemini-2.5-flash", "generated_code": "def dog_age(human_age):\n    \"\"\"\n    Calculates a dog's age in dog years based on human years.\n\n    The first two human years count as 10.5 dog years each.\n    Every human year after that counts as 4 dog years.\n\n    Args:\n        human_age: The dog's age in human years (a non-negative number).\n\n    Returns:\n        The dog's age in dog years.\n    \"\"\"\n    if human_age < 0:\n        raise ValueError(\"Human age cannot be negative.\")\n    elif human_age <= 2:\n        return human_age * 10.5\n    else:\n        return (2 * 10.5) + ((human_age - 2) * 4)"}
{"benchmark": "mbpp", "task_id": "266", "prompt": "Write a function to find the lateral surface area of a cube given its side length.", "reference_code": "def lateralsurface_cube(l):\n  LSA = 4 * (l * l)\n  return LSA", "test_imports": [], "test_list": ["assert lateralsurface_cube(5)==100", "assert lateralsurface_cube(9)==324", "assert lateralsurface_cube(10)==400"], "model_name": "google/gemini-2.5-flash", "generated_code": "def lateralsurface_cube(side_length):\n  \"\"\"\n  Calculates the lateral surface area of a cube given its side length.\n\n  The lateral surface area of a cube is the sum of the areas of its four side faces.\n  Each face is a square with an area of side_length * side_length.\n\n  Args:\n    side_length: The length of one side of the cube.\n\n  Returns:\n    The lateral surface area of the cube.\n  \"\"\"\n  return 4 * (side_length * side_length)"}
{"benchmark": "mbpp", "task_id": "267", "prompt": "Write a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.", "reference_code": "def square_Sum(n):  \n    return int(n*(4*n*n-1)/3) ", "test_imports": [], "test_list": ["assert square_Sum(2) == 10", "assert square_Sum(3) == 35", "assert square_Sum(4) == 84"], "model_name": "google/gemini-2.5-flash", "generated_code": "def square_Sum(n: int) -> int:\n    \"\"\"\n    Calculates the sum of the squares of the first n odd natural numbers.\n\n    Args:\n        n: An integer representing the number of odd natural numbers.\n\n    Returns:\n        The sum of the squares of the first n odd natural numbers.\n    \"\"\"\n    if n <= 0:\n        return 0\n\n    total_sum = 0\n    for i in range(1, n + 1):\n        odd_number = 2 * i - 1\n        total_sum += odd_number * odd_number\n    return total_sum"}
{"benchmark": "mbpp", "task_id": "265", "prompt": "Write a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.", "reference_code": "def list_split(S, step):\n    return [S[i::step] for i in range(step)]", "test_imports": [], "test_list": ["assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'],3)==[['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]", "assert list_split([1,2,3,4,5,6,7,8,9,10,11,12,13,14],3)==[[1,4,7,10,13], [2,5,8,11,14], [3,6,9,12]]", "assert list_split(['python','java','C','C++','DBMS','SQL'],2)==[['python', 'C', 'DBMS'], ['java', 'C++', 'SQL']]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def list_split(input_list: list, n: int) -> list:\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n\n    Args:\n        input_list: The list to be split.\n        n: The interval at which to split the list.\n\n    Returns:\n        A list of lists, where each inner list is a segment of the original list.\n    \"\"\"\n    if not isinstance(input_list, list):\n        raise TypeError(\"input_list must be a list\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    result = []\n    for i in range(0, len(input_list), n):\n        result.append(input_list[i:i + n])\n    return result"}
{"benchmark": "mbpp", "task_id": "269", "prompt": "Write a function to find the ascii value of a character.", "reference_code": "def ascii_value(k):\n  ch=k\n  return ord(ch)", "test_imports": [], "test_list": ["assert ascii_value('A')==65", "assert ascii_value('R')==82", "assert ascii_value('S')==83"], "model_name": "google/gemini-2.5-flash", "generated_code": "def ascii_value(char: str) -> int:\n    \"\"\"\n    Finds the ASCII value of a given character.\n\n    Args:\n        char: A single character string.\n\n    Returns:\n        An integer representing the ASCII value of the character.\n    \"\"\"\n    if not isinstance(char, str) or len(char) != 1:\n        raise ValueError(\"Input must be a single character string.\")\n    return ord(char)"}
{"benchmark": "mbpp", "task_id": "268", "prompt": "Write a function to find the n'th star number.", "reference_code": "def find_star_num(n): \n\treturn (6 * n * (n - 1) + 1) ", "test_imports": [], "test_list": ["assert find_star_num(3) == 37", "assert find_star_num(4) == 73", "assert find_star_num(5) == 121"], "model_name": "google/gemini-2.5-flash", "generated_code": "def find_star_num(n: int) -> int:\n    \"\"\"\n    Finds the n'th star number.\n\n    A star number is a centered figurate number that represents a centered hexagram (six-pointed star).\n    The formula for the n'th star number is 6n(n-1) + 1.\n\n    Args:\n        n: The index of the star number to find (n >= 1).\n\n    Returns:\n        The n'th star number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer (n >= 1)\")\n\n    return 6 * n * (n - 1) + 1"}
{"benchmark": "mbpp", "task_id": "271", "prompt": "Write a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.", "reference_code": "def even_Power_Sum(n): \n    sum = 0; \n    for i in range(1,n+1): \n        j = 2*i; \n        sum = sum + (j*j*j*j*j); \n    return sum; ", "test_imports": [], "test_list": ["assert even_Power_Sum(2) == 1056", "assert even_Power_Sum(3) == 8832", "assert even_Power_Sum(1) == 32"], "model_name": "google/gemini-2.5-flash", "generated_code": "def even_Power_Sum(n: int) -> int:\n    \"\"\"\n    Calculates the sum of the first n even natural numbers raised to the fifth power.\n\n    Args:\n        n: An integer representing the number of even natural numbers to consider.\n\n    Returns:\n        The sum of the first n even natural numbers raised to the fifth power.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input n must be a non-negative integer.\")\n\n    total_sum = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total_sum += even_number ** 5\n    return total_sum"}
{"benchmark": "mbpp", "task_id": "270", "prompt": "Write a python function to find the sum of even numbers at even positions of a list.", "reference_code": "def sum_even_and_even_index(arr):  \n    i = 0\n    sum = 0\n    for i in range(0, len(arr),2): \n        if (arr[i] % 2 == 0) : \n            sum += arr[i]  \n    return sum", "test_imports": [], "test_list": ["assert sum_even_and_even_index([5, 6, 12, 1, 18, 8]) == 30", "assert sum_even_and_even_index([3, 20, 17, 9, 2, 10, 18, 13, 6, 18]) == 26", "assert sum_even_and_even_index([5, 6, 12, 1]) == 12"], "model_name": "google/gemini-2.5-flash", "generated_code": "def sum_even_and_even_index(input_list: list) -> int:\n    \"\"\"\n    Calculates the sum of even numbers that are located at even positions (0-indexed)\n    within the input list.\n\n    Args:\n        input_list: A list of numbers.\n\n    Returns:\n        The sum of even numbers at even positions.\n    \"\"\"\n    total_sum = 0\n    for i in range(0, len(input_list), 2):  # Iterate through even indices\n        if input_list[i] % 2 == 0:  # Check if the number at the even index is even\n            total_sum += input_list[i]\n    return total_sum"}
{"benchmark": "mbpp", "task_id": "273", "prompt": "Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.", "reference_code": "def substract_elements(test_tup1, test_tup2):\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\n  return (res) ", "test_imports": [], "test_list": ["assert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)", "assert substract_elements((11, 2, 3), (24, 45 ,16)) == (-13, -43, -13)", "assert substract_elements((7, 18, 9), (10, 11, 12)) == (-3, 7, -3)"], "model_name": "google/gemini-2.5-flash", "generated_code": "def substract_elements(tuple1: tuple, tuple2: tuple) -> tuple:\n    \"\"\"\n    Subtracts the elements of the first tuple by the elements of the second tuple\n    with the same index.\n\n    Args:\n        tuple1: The first tuple.\n        tuple2: The second tuple.\n\n    Returns:\n        A new tuple containing the results of the subtraction.\n        If the tuples have different lengths, the resulting tuple will have\n        the length of the shorter tuple.\n    \"\"\"\n    return tuple(a - b for a, b in zip(tuple1, tuple2))"}
{"benchmark": "mbpp", "task_id": "272", "prompt": "Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.", "reference_code": "def rear_extract(test_list):\n  res = [lis[-1] for lis in test_list]\n  return (res) ", "test_imports": [], "test_list": ["assert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]", "assert rear_extract([(1, 'Sai', 36), (2, 'Ayesha', 25), (3, 'Salman', 45)]) == [36, 25, 45]", "assert rear_extract([(1, 'Sudeep', 14), (2, 'Vandana', 36), (3, 'Dawood', 56)]) == [14, 36, 56]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def rear_extract(list_of_tuples: list) -> list:\n    \"\"\"\n    Takes in a list of tuples and returns a list containing the rear element of each tuple.\n\n    Args:\n        list_of_tuples: A list of tuples.\n\n    Returns:\n        A list containing the rear element of each tuple.\n        If a tuple is empty, it is skipped.\n    \"\"\"\n    rear_elements = []\n    for tpl in list_of_tuples:\n        if tpl:  # Check if the tuple is not empty\n            rear_elements.append(tpl[-1])\n    return rear_elements"}
{"benchmark": "mbpp", "task_id": "276", "prompt": "Write a function that takes in the radius and height of a cylinder and returns the the volume.", "reference_code": "def volume_cylinder(r,h):\n  volume=3.1415*r*r*h\n  return volume", "test_imports": ["import math"], "test_list": ["assert math.isclose(volume_cylinder(10,5), 1570.7500000000002, rel_tol=0.001)", "assert math.isclose(volume_cylinder(4,5), 251.32000000000002, rel_tol=0.001)", "assert math.isclose(volume_cylinder(4,10), 502.64000000000004, rel_tol=0.001)"], "model_name": "google/gemini-2.5-flash", "generated_code": "import math\n\ndef volume_cylinder(radius: float, height: float) -> float:\n    \"\"\"\n    Calculates the volume of a cylinder given its radius and height.\n\n    Args:\n        radius: The radius of the cylinder's base.\n        height: The height of the cylinder.\n\n    Returns:\n        The volume of the cylinder.\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"Radius and height cannot be negative.\")\n    return math.pi * (radius ** 2) * height"}
{"benchmark": "mbpp", "task_id": "277", "prompt": "Write a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.", "reference_code": "def dict_filter(dict,n):\n result = {key:value for (key, value) in dict.items() if value >=n}\n return result", "test_imports": [], "test_list": ["assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},170)=={'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190}", "assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},180)=={ 'Alden Cantrell': 180, 'Pierre Cox': 190}", "assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},190)=={ 'Pierre Cox': 190}"], "model_name": "google/gemini-2.5-flash", "generated_code": "def dict_filter(data: dict, n: int) -> dict:\n    \"\"\"\n    Filters a dictionary to only include entries with values greater than or equal to n.\n\n    Args:\n        data: The input dictionary.\n        n: The minimum value for an entry to be included.\n\n    Returns:\n        A new dictionary containing only the entries from the input dictionary\n        whose values are greater than or equal to n.\n    \"\"\"\n    return {key: value for key, value in data.items() if value >= n}"}
{"benchmark": "mbpp", "task_id": "279", "prompt": "Write a function to find the nth decagonal number.", "reference_code": "def is_num_decagonal(n): \n\treturn 4 * n * n - 3 * n ", "test_imports": [], "test_list": ["assert is_num_decagonal(3) == 27", "assert is_num_decagonal(7) == 175", "assert is_num_decagonal(10) == 370"], "model_name": "google/gemini-2.5-flash", "generated_code": "def is_num_decagonal(n: int) -> int:\n    \"\"\"\n    Calculates the nth decagonal number.\n\n    A decagonal number is a figurate number that represents a decagon.\n    The formula for the nth decagonal number is n * (4n - 3).\n\n    Args:\n        n: A non-negative integer representing the position of the decagonal number.\n\n    Returns:\n        The nth decagonal number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input 'n' must be a non-negative integer.\")\n    return n * (4 * n - 3)"}
{"benchmark": "mbpp", "task_id": "274", "prompt": "Write a python function that takes in a positive integer n and finds the sum of even index binomial coefficients.", "reference_code": "import math  \ndef even_binomial_Coeff_Sum( n): \n    return (1 << (n - 1)) ", "test_imports": [], "test_list": ["assert even_binomial_Coeff_Sum(4) == 8", "assert even_binomial_Coeff_Sum(6) == 32", "assert even_binomial_Coeff_Sum(2) == 2"], "model_name": "google/gemini-2.5-flash", "generated_code": "def even_binomial_Coeff_Sum(n: int) -> int:\n    \"\"\"\n    Calculates the sum of even-indexed binomial coefficients for a given n.\n\n    The binomial coefficients are given by C(n, k), where k ranges from 0 to n.\n    We need to find the sum C(n, 0) + C(n, 2) + C(n, 4) + ...\n\n    It is a known property that the sum of all binomial coefficients for a given n is 2^n.\n    That is, C(n, 0) + C(n, 1) + C(n, 2) + ... + C(n, n) = 2^n.\n\n    Also, the alternating sum of binomial coefficients is 0 for n > 0:\n    C(n, 0) - C(n, 1) + C(n, 2) - ... + (-1)^n * C(n, n) = 0.\n\n    Let S_even = C(n, 0) + C(n, 2) + C(n, 4) + ...\n    Let S_odd = C(n, 1) + C(n, 3) + C(n, 5) + ...\n\n    From the first property: S_even + S_odd = 2^n.\n    From the second property: S_even - S_odd = 0 (for n > 0).\n    This implies S_even = S_odd.\n\n    Substituting S_odd with S_even in the first equation:\n    S_even + S_even = 2^n\n    2 * S_even = 2^n\n    S_even = 2^n / 2\n    S_even = 2^(n-1)\n\n    This formula holds for n > 0.\n    For n = 0, C(0, 0) = 1. The sum of even-indexed coefficients is 1.\n    Using the formula 2^(0-1) = 2^(-1) = 0.5, which is incorrect.\n    So, for n=0, the result is 1.\n    For n > 0, the result is 2^(n-1).\n\n    Args:\n        n: A positive integer.\n\n    Returns:\n        The sum of even-indexed binomial coefficients.\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return 1 << (n - 1)  # Equivalent to 2**(n-1)"}
{"benchmark": "mbpp", "task_id": "260", "prompt": "Write a function to find the nth newmanshankswilliams prime number.", "reference_code": "def newman_prime(n): \n\tif n == 0 or n == 1: \n\t\treturn 1\n\treturn 2 * newman_prime(n - 1) + newman_prime(n - 2)", "test_imports": [], "test_list": ["assert newman_prime(3) == 7", "assert newman_prime(4) == 17", "assert newman_prime(5) == 41"], "model_name": "google/gemini-2.5-flash", "generated_code": "def newman_prime(n: int) -> int:\n    \"\"\"\n    Finds the nth Newman-Shanks-Williams prime number.\n\n    The Newman-Shanks-Williams (NSW) numbers are defined by the recurrence relation:\n    S_0 = 1\n    S_1 = 1\n    S_n = 2 * S_{n-1} + S_{n-2} for n >= 2\n\n    A Newman-Shanks-Williams prime is an NSW number that is also a prime number.\n\n    Args:\n        n: The index of the desired NSW prime number (1-indexed).\n\n    Returns:\n        The nth Newman-Shanks-Williams prime number.\n\n    Raises:\n        ValueError: If n is less than 1 or if the nth NSW prime does not exist\n                    within a reasonable computational limit (e.g., first few primes).\n    \"\"\"\n\n    if n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        i = 3\n        while i * i <= num:\n            if num % i == 0:\n                return False\n            i += 2\n        return True\n\n    s_prev_prev = 1  # S_0\n    s_prev = 1      # S_1\n    \n    found_primes_count = 0\n    current_nsw_index = 0\n\n    # The first few NSW numbers are:\n    # S_0 = 1 (not prime)\n    # S_1 = 1 (not prime)\n    # S_2 = 2*1 + 1 = 3 (prime, 1st NSW prime)\n    # S_3 = 2*3 + 1 = 7 (prime, 2nd NSW prime)\n    # S_4 = 2*7 + 3 = 17 (prime, 3rd NSW prime)\n    # S_5 = 2*17 + 7 = 41 (prime, 4th NSW prime)\n    # S_6 = 2*41 + 17 = 99 (not prime)\n    # S_7 = 2*99 + 41 = 239 (prime, 5th NSW prime)\n    # S_8 = 2*239 + 99 = 577 (prime, 6th NSW prime)\n    # S_9 = 2*577 + 239 = 1393 (not prime)\n    # S_10 = 2*1393 + 577 = 3363 (not prime)\n    # S_11 = 2*3363 + 1393 = 8119 (prime, 7th NSW prime)\n\n    # Handle the first two NSW numbers (S_0 and S_1) which are 1 and not prime.\n    # We start checking from S_2.\n    \n    # S_0 = 1\n    # S_1 = 1\n    # S_2 = 3 (1st prime)\n    # S_3 = 7 (2nd prime)\n    # S_4 = 17 (3rd prime)\n    # S_5 = 41 (4th prime)\n    # S_6 = 99 (not prime)\n    # S_7 = 239 (5th prime)\n    # S_8 = 577 (6th prime)\n    # S_9 = 1393 (not prime)\n    # S_10 = 3363 (not prime)\n    # S_11 = 8119 (7th prime)\n\n    # We need to find the nth prime, so we iterate through NSW numbers\n    # starting from S_2.\n    \n    # Initialize for S_2\n    current_nsw_index = 2\n    current_nsw_number = 3 # S_2\n\n    while found_primes_count < n:\n        if is_prime(current_nsw_number):\n            found_primes_count += 1\n            if found_primes_count == n:\n                return current_nsw_number\n\n        # Calculate the next NSW number\n        # S_n = 2 * S_{n-1} + S_{n-2}\n        if current_nsw_index == 0: # S_0\n            s_prev_prev = 1\n            s_prev = 1\n            current_nsw_number = 1\n        elif current_nsw_index == 1: # S_1\n            s_prev_prev = 1\n            s_prev = 1\n            current_nsw_number = 1\n        else:\n            next_nsw_number = 2 * s_prev + s_prev_prev\n            s_prev_prev = s_prev\n            s_prev = next_nsw_number\n            current_nsw_number = next_nsw_number\n        \n        current_nsw_index += 1\n\n        # Safety break to prevent infinite loops for very large n if primes are sparse\n        if current_nsw_index > 1000: # Arbitrary limit, adjust if more primes are needed\n            raise ValueError(f\"Could not find the {n}th NSW prime within a reasonable limit.\")\n\n    return -1 # Should not be reached"}
{"benchmark": "mbpp", "task_id": "280", "prompt": "Write a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).", "reference_code": "def sequential_search(dlist, item):\n    pos = 0\n    found = False\n    while pos < len(dlist) and not found:\n        if dlist[pos] == item:\n            found = True\n        else:\n            pos = pos + 1\n    return found, pos", "test_imports": [], "test_list": ["assert sequential_search([11,23,58,31,56,77,43,12,65,19],31) == (True, 3)", "assert sequential_search([12, 32, 45, 62, 35, 47, 44, 61],61) == (True, 7)", "assert sequential_search([9, 10, 17, 19, 22, 39, 48, 56],48) == (True, 6)"], "model_name": "google/gemini-2.5-flash", "generated_code": "def sequential_search(arr, element):\n    \"\"\"\n    Performs a sequential search on an array to find an element.\n\n    Args:\n        arr (list): The list of elements to search through.\n        element: The element to search for.\n\n    Returns:\n        tuple: A tuple containing:\n               - bool: True if the element is found, False otherwise.\n               - int: The index of the element if found, -1 otherwise.\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return (True, i)\n    return (False, -1)"}
{"benchmark": "mbpp", "task_id": "245", "prompt": "Write a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, where a sequence is bitonic if it is first increasing and then decreasing.", "reference_code": "def max_sum(arr): \n\tMSIBS = arr[:] \n\tfor i in range(len(arr)): \n\t\tfor j in range(0, i): \n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \n\tMSDBS = arr[:] \n\tfor i in range(1, len(arr) + 1): \n\t\tfor j in range(1, i): \n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \n\tmax_sum = float(\"-Inf\") \n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \n\t\tmax_sum = max(max_sum, i + j - k) \n\treturn max_sum", "test_imports": [], "test_list": ["assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194", "assert max_sum([80, 60, 30, 40, 20, 10]) == 210", "assert max_sum([2, 3 ,14, 16, 21, 23, 29, 30]) == 138"], "model_name": "google/gemini-2.5-flash", "generated_code": ""}
{"benchmark": "mbpp", "task_id": "281", "prompt": "Write a python function to check if the elements of a given list are unique or not.", "reference_code": "def all_unique(test_list):\n    if len(test_list) > len(set(test_list)):\n        return False\n    return True", "test_imports": [], "test_list": ["assert all_unique([1,2,3]) == True", "assert all_unique([1,2,1,2]) == False", "assert all_unique([1,2,3,4,5]) == True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def all_unique(input_list: list) -> bool:\n    \"\"\"\n    Checks if all elements in the given list are unique.\n\n    Args:\n        input_list: The list to check.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(input_list) == len(set(input_list))"}
{"benchmark": "mbpp", "task_id": "285", "prompt": "Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.", "reference_code": "import re\ndef text_match_two_three(text):\n        patterns = 'ab{2,3}'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False", "test_imports": [], "test_list": ["assert text_match_two_three(\"ac\")==(False)", "assert text_match_two_three(\"dc\")==(False)", "assert text_match_two_three(\"abbbba\")==(True)"], "model_name": "google/gemini-2.5-flash", "generated_code": "import re\n\ndef text_match_two_three(text):\n  \"\"\"\n  Checks whether a string contains the 'a' character followed by two or three 'b' characters.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    True if the pattern is found, False otherwise.\n  \"\"\"\n  pattern = 'ab{2,3}'\n  if re.search(pattern, text):\n    return True\n  else:\n    return False"}
{"benchmark": "mbpp", "task_id": "284", "prompt": "Write a function that takes in a list and element and checks whether all items in the list are equal to the given element.", "reference_code": "def check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element", "test_imports": [], "test_list": ["assert check_element([\"green\", \"orange\", \"black\", \"white\"],'blue')==False", "assert check_element([1,2,3,4],7)==False", "assert check_element([\"green\", \"green\", \"green\", \"green\"],'green')==True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def check_element(input_list: list, element) -> bool:\n    \"\"\"\n    Checks whether all items in the list are equal to the given element.\n\n    Args:\n        input_list: The list to check.\n        element: The element to compare against.\n\n    Returns:\n        True if all items in the list are equal to the element, False otherwise.\n    \"\"\"\n    if not input_list:\n        return True  # An empty list is considered to have all its (zero) elements equal to anything.\n\n    for item in input_list:\n        if item != element:\n            return False\n    return True"}
{"benchmark": "mbpp", "task_id": "282", "prompt": "Write a function to subtract two lists element-wise.", "reference_code": "def sub_list(nums1,nums2):\n  result = map(lambda x, y: x - y, nums1, nums2)\n  return list(result)", "test_imports": [], "test_list": ["assert sub_list([1, 2, 3],[4,5,6])==[-3,-3,-3]", "assert sub_list([1,2],[3,4])==[-2,-2]", "assert sub_list([90,120],[50,70])==[40,50]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def sub_list(list1: list, list2: list) -> list:\n    \"\"\"\n    Subtracts two lists element-wise.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n\n    Returns:\n        A new list containing the element-wise differences.\n        If the lists have different lengths, the resulting list\n        will have the length of the shorter list.\n    \"\"\"\n    result = []\n    min_len = min(len(list1), len(list2))\n    for i in range(min_len):\n        result.append(list1[i] - list2[i])\n    return result"}
{"benchmark": "mbpp", "task_id": "290", "prompt": "Write a function to find the list of maximum length in a list of lists.", "reference_code": "def max_length(list1):\n    max_length = max(len(x) for x in  list1 )  \n    max_list = max((x) for x in   list1)\n    return(max_length, max_list)", "test_imports": [], "test_list": ["assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])", "assert max_length([[1], [5, 7], [10, 12, 14,15]])==(4, [10, 12, 14,15])", "assert max_length([[5], [15,20,25]])==(3, [15,20,25])"], "model_name": "google/gemini-2.5-flash", "generated_code": "def max_length(list_of_lists):\n    \"\"\"\n    Finds the list of maximum length in a list of lists.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        The list with the maximum length. If the input list is empty,\n        it returns an empty list. If there are multiple lists with the\n        same maximum length, it returns the first one encountered.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    max_len_list = list_of_lists[0]\n    for sublist in list_of_lists:\n        if len(sublist) > len(max_len_list):\n            max_len_list = sublist\n    return max_len_list"}
{"benchmark": "mbpp", "task_id": "292", "prompt": "Write a python function to find quotient of two numbers (rounded down to the nearest integer).", "reference_code": "def find(n,m):  \n    q = n//m \n    return (q)", "test_imports": [], "test_list": ["assert find(10,3) == 3", "assert find(4,2) == 2", "assert find(20,5) == 4"], "model_name": "google/gemini-2.5-flash", "generated_code": "def find(num1: int, num2: int) -> int:\n    \"\"\"\n    Finds the quotient of two numbers, rounded down to the nearest integer.\n\n    Args:\n        num1: The dividend.\n        num2: The divisor.\n\n    Returns:\n        The quotient of num1 and num2, rounded down to the nearest integer.\n    \"\"\"\n    if num2 == 0:\n        raise ZeroDivisionError(\"Cannot divide by zero.\")\n    return num1 // num2"}
{"benchmark": "mbpp", "task_id": "278", "prompt": "Write a function to find the number of elements that occurs before the tuple element in the given tuple.", "reference_code": "def count_first_elements(test_tup):\n  for count, ele in enumerate(test_tup):\n    if isinstance(ele, tuple):\n      break\n  return (count) ", "test_imports": [], "test_list": ["assert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3", "assert count_first_elements((2, 9, (5, 7), 11) ) == 2", "assert count_first_elements((11, 15, 5, 8, (2, 3), 8) ) == 4"], "model_name": "google/gemini-2.5-flash", "generated_code": "def count_first_elements(tup, element):\n    \"\"\"\n    Finds the number of elements that occur before the first occurrence of 'element'\n    in the given tuple 'tup'.\n\n    Args:\n        tup: The input tuple.\n        element: The element to search for.\n\n    Returns:\n        The number of elements before the first occurrence of 'element'.\n        Returns -1 if the element is not found in the tuple.\n    \"\"\"\n    try:\n        index = tup.index(element)\n        return index\n    except ValueError:\n        return -1"}
{"benchmark": "mbpp", "task_id": "283", "prompt": "Write a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.", "reference_code": "def validate(n): \n    for i in range(10): \n        temp = n;  \n        count = 0; \n        while (temp): \n            if (temp % 10 == i): \n                count+=1;  \n            if (count > i): \n                return False\n            temp //= 10; \n    return True", "test_imports": [], "test_list": ["assert validate(1234) == True", "assert validate(51241) == False", "assert validate(321) == True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def validate(n: int) -> bool:\n    \"\"\"\n    Checks whether the frequency of each digit in the integer n is less than or equal to the digit itself.\n\n    Args:\n        n: The integer to check.\n\n    Returns:\n        True if the frequency of each digit is less than or equal to the digit itself,\n        False otherwise.\n    \"\"\"\n    if n < 0:\n        n = abs(n)\n\n    s = str(n)\n    digit_counts = {}\n\n    for char_digit in s:\n        digit = int(char_digit)\n        digit_counts[digit] = digit_counts.get(digit, 0) + 1\n\n    for digit, count in digit_counts.items():\n        if digit == 0:\n            # The frequency of digit 0 must be 0 or 1 (if it appears once).\n            # If it appears more than once, it violates the condition (count > digit).\n            # If it appears once, count (1) is not <= digit (0), so it's False.\n            # The only way for 0 to satisfy the condition is if it doesn't appear at all,\n            # or if the condition is interpreted as \"count <= digit IF digit is not 0\".\n            # Given the problem statement \"frequency of each digit ... is less than or equal to the digit itself\",\n            # for digit 0, this means count <= 0. This implies 0 cannot appear in the number.\n            # If 0 appears, its count will be >= 1, which is not <= 0.\n            if count > 0:\n                return False\n        elif count > digit:\n            return False\n\n    return True"}
{"benchmark": "mbpp", "task_id": "287", "prompt": "Write a python function takes in an integer n and returns the sum of squares of first n even natural numbers.", "reference_code": "def square_Sum(n):  \n    return int(2*n*(n+1)*(2*n+1)/3)", "test_imports": [], "test_list": ["assert square_Sum(2) == 20", "assert square_Sum(3) == 56", "assert square_Sum(4) == 120"], "model_name": "google/gemini-2.5-flash", "generated_code": "def square_Sum(n: int) -> int:\n    \"\"\"\n    Calculates the sum of squares of the first n even natural numbers.\n\n    Args:\n        n: An integer representing the number of even natural numbers.\n\n    Returns:\n        The sum of squares of the first n even natural numbers.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input n must be a non-negative integer.\")\n    \n    # The k-th even natural number is 2*k.\n    # We need to sum (2*k)^2 for k from 1 to n.\n    # (2*k)^2 = 4*k^2\n    # So, the sum is 4 * (sum of k^2 from k=1 to n)\n    # The sum of the first n squares (1^2 + 2^2 + ... + n^2) is given by the formula:\n    # n * (n + 1) * (2*n + 1) / 6\n\n    # Therefore, the sum of squares of the first n even natural numbers is:\n    # 4 * [n * (n + 1) * (2*n + 1) / 6]\n    # This simplifies to:\n    # 2 * n * (n + 1) * (2*n + 1) / 3\n\n    return 2 * n * (n + 1) * (2 * n + 1) // 3"}
{"benchmark": "mbpp", "task_id": "291", "prompt": "Write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.", "reference_code": "def count_no_of_ways(n, k): \n\tdp = [0] * (n + 1) \n\ttotal = k \n\tmod = 1000000007\n\tdp[1] = k \n\tdp[2] = k * k\t \n\tfor i in range(3,n+1): \n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \n\treturn dp[n]", "test_imports": [], "test_list": ["assert count_no_of_ways(2, 4) == 16", "assert count_no_of_ways(3, 2) == 6", "assert count_no_of_ways(4, 4) == 228"], "model_name": "google/gemini-2.5-flash", "generated_code": "def count_no_of_ways(n: int, k: int) -> int:\n    \"\"\"\n    Calculates the number of ways to paint a fence with n posts and k colors\n    such that at most 2 adjacent posts have the same color.\n\n    Args:\n        n: The number of posts in the fence.\n        k: The number of available colors.\n\n    Returns:\n        The number of ways to paint the fence.\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n\n    # dp[i][0] represents the number of ways to paint 'i' posts such that\n    # the i-th post has a different color than the (i-1)-th post.\n    # dp[i][1] represents the number of ways to paint 'i' posts such that\n    # the i-th post has the same color as the (i-1)-th post.\n\n    # Base cases for n = 2\n    # For the second post, if it's different from the first, there are k-1 choices.\n    # The first post has k choices. So, k * (k-1) ways.\n    diff = k * (k - 1)\n    # For the second post, if it's the same as the first, there is 1 choice.\n    # The first post has k choices. So, k * 1 ways.\n    same = k * 1\n\n    for i in range(3, n + 1):\n        # If the i-th post is different from the (i-1)-th post:\n        # It can be different from the (i-1)-th post, which itself could have been\n        # different or same as the (i-2)-th post.\n        # In either case, we have (k-1) choices for the i-th post.\n        new_diff = (diff + same) * (k - 1)\n\n        # If the i-th post is the same as the (i-1)-th post:\n        # This is only allowed if the (i-1)-th post was different from the (i-2)-th post.\n        # If (i-1)-th was same as (i-2)-th, then painting i-th same would make 3 consecutive same, which is not allowed.\n        # So, the number of ways is equal to the number of ways where (i-1)-th was different from (i-2)-th.\n        # And for the i-th post, there is only 1 choice (same color as (i-1)-th).\n        new_same = diff * 1\n\n        diff = new_diff\n        same = new_same\n\n    return diff + same"}
{"benchmark": "mbpp", "task_id": "286", "prompt": "Write a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.", "reference_code": "def max_sub_array_sum_repeated(a, n, k): \n\tmax_so_far = -2147483648\n\tmax_ending_here = 0\n\tfor i in range(n*k): \n\t\tmax_ending_here = max_ending_here + a[i%n] \n\t\tif (max_so_far < max_ending_here): \n\t\t\tmax_so_far = max_ending_here \n\t\tif (max_ending_here < 0): \n\t\t\tmax_ending_here = 0\n\treturn max_so_far", "test_imports": [], "test_list": ["assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30", "assert max_sub_array_sum_repeated([-1, 10, 20], 3, 2) == 59", "assert max_sub_array_sum_repeated([-1, -2, -3], 3, 3) == -1"], "model_name": "google/gemini-2.5-flash", "generated_code": "def max_sub_array_sum_repeated(arr, k):\n    \"\"\"\n    Finds the largest sum of a contiguous subarray in the modified array\n    which is formed by repeating the given array k times.\n\n    Args:\n        arr: A list of integers representing the original array.\n        k: An integer representing the number of times to repeat the array.\n\n    Returns:\n        An integer representing the maximum subarray sum.\n    \"\"\"\n\n    n = len(arr)\n\n    # Kadane's algorithm for a single array\n    def kadane(nums):\n        max_so_far = float('-inf')\n        current_max = 0\n        for x in nums:\n            current_max += x\n            if current_max > max_so_far:\n                max_so_far = current_max\n            if current_max < 0:\n                current_max = 0\n        return max_so_far if max_so_far != float('-inf') else 0 # Handle all negative numbers case\n\n    if k == 1:\n        return kadane(arr)\n\n    # For k > 1, we need to consider three cases:\n    # 1. The maximum subarray sum is entirely within one copy of the array.\n    # 2. The maximum subarray sum spans across the boundary of two copies.\n    # 3. The maximum subarray sum spans across multiple copies (more than two).\n\n    # Case 1 & 2: Consider two copies of the array\n    # This covers subarrays entirely within one copy, or spanning across the boundary of two copies.\n    max_sum_two_copies = kadane(arr + arr)\n\n    # If the sum of all elements in the original array is positive,\n    # then repeating the array multiple times can increase the sum.\n    # The total sum of the original array.\n    total_arr_sum = sum(arr)\n\n    if total_arr_sum > 0:\n        # If total_arr_sum is positive, and k > 1, the maximum sum could be\n        # max_sum_two_copies + (k - 2) * total_arr_sum.\n        # This accounts for the middle (k-2) full arrays contributing their total sum.\n        return max_sum_two_copies + (k - 2) * total_arr_sum\n    else:\n        # If total_arr_sum is non-positive, repeating the array more than twice\n        # will not increase the maximum sum beyond what's found in two copies.\n        # The maximum sum will be either within one copy or span at most two copies.\n        return max_sum_two_copies"}
{"benchmark": "mbpp", "task_id": "295", "prompt": "Write a function to return the sum of all divisors of a number.", "reference_code": "def sum_div(number):\n    divisors = [1]\n    for i in range(2, number):\n        if (number % i)==0:\n            divisors.append(i)\n    return sum(divisors)", "test_imports": [], "test_list": ["assert sum_div(8)==7", "assert sum_div(12)==16", "assert sum_div(7)==1"], "model_name": "google/gemini-2.5-flash", "generated_code": "def sum_div(number: int) -> int:\n    \"\"\"\n    Calculates the sum of all divisors of a given number.\n\n    Args:\n        number: An integer for which to calculate the sum of divisors.\n\n    Returns:\n        The sum of all divisors of the input number.\n    \"\"\"\n    if number <= 0:\n        return 0  # Divisors are typically defined for positive integers.\n                  # For non-positive, we return 0 as per common interpretations.\n\n    total_sum = 0\n    for i in range(1, int(number**0.5) + 1):\n        if number % i == 0:\n            total_sum += i\n            if i * i != number:  # Avoid adding the same divisor twice for perfect squares\n                total_sum += number // i\n    return total_sum"}
{"benchmark": "mbpp", "task_id": "293", "prompt": "Write a function to find the third side of a right angled triangle.", "reference_code": "import math\ndef otherside_rightangle(w,h):\n  s=math.sqrt((w*w)+(h*h))\n  return s", "test_imports": [], "test_list": ["assert otherside_rightangle(7,8)==10.63014581273465", "assert otherside_rightangle(3,4)==5", "assert otherside_rightangle(7,15)==16.55294535724685"], "model_name": "google/gemini-2.5-flash", "generated_code": "import math\n\ndef otherside_rightangle(side1: float, side2: float, hypotenuse: float) -> float:\n    \"\"\"\n    Calculates the length of the third side of a right-angled triangle given two sides.\n\n    Exactly two of the input arguments (side1, side2, hypotenuse) must be positive\n    numbers, and one must be zero. The function will calculate the missing side.\n\n    Args:\n        side1: Length of the first leg.\n        side2: Length of the second leg.\n        hypotenuse: Length of the hypotenuse.\n\n    Returns:\n        The length of the missing side.\n\n    Raises:\n        ValueError: If the input does not represent a valid right-angled triangle\n                    scenario (e.g., more than one side is zero, or all sides are zero,\n                    or the given sides violate the Pythagorean theorem).\n    \"\"\"\n    num_zeros = (side1 == 0) + (side2 == 0) + (hypotenuse == 0)\n\n    if num_zeros != 1:\n        raise ValueError(\"Exactly one side must be zero to calculate the missing side.\")\n\n    if side1 < 0 or side2 < 0 or hypotenuse < 0:\n        raise ValueError(\"Side lengths cannot be negative.\")\n\n    if side1 == 0:\n        # Calculate side1 (leg)\n        if hypotenuse <= side2:\n            raise ValueError(\"Hypotenuse must be greater than the leg.\")\n        return math.sqrt(hypotenuse**2 - side2**2)\n    elif side2 == 0:\n        # Calculate side2 (leg)\n        if hypotenuse <= side1:\n            raise ValueError(\"Hypotenuse must be greater than the leg.\")\n        return math.sqrt(hypotenuse**2 - side1**2)\n    else: # hypotenuse == 0\n        # Calculate hypotenuse\n        return math.sqrt(side1**2 + side2**2)"}
{"benchmark": "mbpp", "task_id": "294", "prompt": "Write a function to find the maximum value in a given heterogeneous list.", "reference_code": "def max_val(listval):\n     max_val = max(i for i in listval if isinstance(i, int)) \n     return(max_val)", "test_imports": [], "test_list": ["assert max_val(['Python', 3, 2, 4, 5, 'version'])==5", "assert max_val(['Python', 15, 20, 25])==25", "assert max_val(['Python', 30, 20, 40, 50, 'version'])==50"], "model_name": "google/gemini-2.5-flash", "generated_code": "def max_val(heterogeneous_list):\n    \"\"\"\n    Finds the maximum value in a given heterogeneous list.\n\n    The list can contain integers, floats, and strings.\n    - For numbers (int, float), the standard numerical comparison applies.\n    - For strings, lexicographical comparison applies.\n    - When comparing a number and a string, the number is always considered smaller.\n    - The function handles empty lists by returning None.\n\n    Args:\n        heterogeneous_list: A list containing a mix of integers, floats, and strings.\n\n    Returns:\n        The maximum value from the list, or None if the list is empty.\n    \"\"\"\n    if not heterogeneous_list:\n        return None\n\n    max_value = None\n\n    for item in heterogeneous_list:\n        if max_value is None:\n            max_value = item\n        else:\n            # Define a custom comparison logic\n            if isinstance(item, (int, float)) and isinstance(max_value, str):\n                # Number is always smaller than a string\n                # max_value remains the string\n                pass\n            elif isinstance(item, str) and isinstance(max_value, (int, float)):\n                # String is always larger than a number\n                max_value = item\n            else:\n                # Standard comparison for same types or when both are numbers\n                if item > max_value:\n                    max_value = item\n    return max_value"}
{"benchmark": "mbpp", "task_id": "297", "prompt": "Write a function to flatten a given nested list structure.", "reference_code": "def flatten_list(list1):\n    result_list = []\n    if not list1: return result_list\n    stack = [list(list1)]\n    while stack:\n        c_num = stack.pop()\n        next = c_num.pop()\n        if c_num: stack.append(c_num)\n        if isinstance(next, list):\n            if next: stack.append(list(next))\n        else: result_list.append(next)\n    result_list.reverse()\n    return result_list ", "test_imports": [], "test_list": ["assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]", "assert flatten_list([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]])==[10, 20, 40, 30, 56, 25, 10, 20, 33, 40]", "assert flatten_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])==[1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def flatten_list(nested_list):\n    \"\"\"\n    Flattens a given nested list structure.\n\n    Args:\n        nested_list: A list that may contain other lists as elements.\n\n    Returns:\n        A new list containing all elements from the nested_list,\n        with no nested lists.\n    \"\"\"\n    flat_list = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list"}
{"benchmark": "mbpp", "task_id": "299", "prompt": "Write a function to calculate the maximum aggregate from the list of tuples.", "reference_code": "from collections import defaultdict\ndef max_aggregate(stdata):\n    temp = defaultdict(int)\n    for name, marks in stdata:\n        temp[name] += marks\n    return max(temp.items(), key=lambda x: x[1])", "test_imports": [], "test_list": ["assert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])==('Juan Whelan', 212)", "assert max_aggregate([('Juan Whelan',50),('Sabah Colley',48),('Peter Nichols',37),('Juan Whelan',22),('Sabah Colley',14)])==('Juan Whelan', 72)", "assert max_aggregate([('Juan Whelan',10),('Sabah Colley',20),('Peter Nichols',30),('Juan Whelan',40),('Sabah Colley',50)])==('Sabah Colley', 70)"], "model_name": "google/gemini-2.5-flash", "generated_code": "def max_aggregate(data):\n    \"\"\"\n    Calculates the maximum aggregate from a list of tuples.\n\n    Each tuple in the input list `data` is expected to be of the form\n    (key, value), where 'key' is a hashable type and 'value' is a numeric type.\n    The function aggregates values by key and returns the maximum aggregated value.\n\n    Args:\n        data: A list of tuples, where each tuple is (key, value).\n\n    Returns:\n        The maximum aggregated value found across all keys.\n        Returns 0 if the input list is empty.\n    \"\"\"\n    if not data:\n        return 0\n\n    aggregates = {}\n    for key, value in data:\n        aggregates[key] = aggregates.get(key, 0) + value\n\n    return max(aggregates.values())"}
{"benchmark": "mbpp", "task_id": "296", "prompt": "Write a python function to count inversions in an array.", "reference_code": "def get_Inv_Count(arr): \n    inv_count = 0\n    for i in range(len(arr)): \n        for j in range(i + 1, len(arr)): \n            if (arr[i] > arr[j]): \n                inv_count += 1\n    return inv_count ", "test_imports": [], "test_list": ["assert get_Inv_Count([1,20,6,4,5]) == 5", "assert get_Inv_Count([1,2,1]) == 1", "assert get_Inv_Count([1,2,5,6,1]) == 3"], "model_name": "google/gemini-2.5-flash", "generated_code": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array using a modified merge sort algorithm.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input list of numbers.\n\n    Returns:\n        The total number of inversions in the array.\n    \"\"\"\n\n    def merge_sort_and_count(arr_slice):\n        n = len(arr_slice)\n        if n <= 1:\n            return arr_slice, 0\n\n        mid = n // 2\n        left_half, left_inversions = merge_sort_and_count(arr_slice[:mid])\n        right_half, right_inversions = merge_sort_and_count(arr_slice[mid:])\n\n        merged_arr = []\n        i = j = 0\n        inversions = left_inversions + right_inversions\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] <= right_half[j]:\n                merged_arr.append(left_half[i])\n                i += 1\n            else:\n                # If an element in the right half is smaller,\n                # it means all remaining elements in the left_half\n                # (from current i to end) form an inversion with right_half[j].\n                merged_arr.append(right_half[j])\n                inversions += (len(left_half) - i)\n                j += 1\n\n        merged_arr.extend(left_half[i:])\n        merged_arr.extend(right_half[j:])\n\n        return merged_arr, inversions\n\n    _, total_inversions = merge_sort_and_count(arr)\n    return total_inversions"}
{"benchmark": "mbpp", "task_id": "305", "prompt": "Write a function to return two words from a list of words starting with letter 'p'.", "reference_code": "import re\ndef start_withp(words):\n for w in words:\n        m = re.match(\"(P\\w+)\\W(P\\w+)\", w)\n        if m:\n            return m.groups()", "test_imports": [], "test_list": ["assert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"])==('Python', 'PHP')", "assert start_withp([\"Python Programming\",\"Java Programming\"])==('Python','Programming')", "assert start_withp([\"Pqrst Pqr\",\"qrstuv\"])==('Pqrst','Pqr')"], "model_name": "google/gemini-2.5-flash", "generated_code": "def start_withp(words):\n    \"\"\"\n    Returns two words from a list of words that start with the letter 'p'.\n    If fewer than two such words are found, it returns as many as it finds.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        A list containing up to two words from the input list that start with 'p' (case-insensitive).\n    \"\"\"\n    result = []\n    for word in words:\n        if word.lower().startswith('p'):\n            result.append(word)\n            if len(result) == 2:\n                break\n    return result"}
{"benchmark": "mbpp", "task_id": "301", "prompt": "Write a function to find the depth of a dictionary.", "reference_code": "def dict_depth(d):\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0", "test_imports": [], "test_list": ["assert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4", "assert dict_depth({'a':1, 'b': {'c':'python'}})==2", "assert dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}})==3"], "model_name": "google/gemini-2.5-flash", "generated_code": "def dict_depth(d):\n    \"\"\"\n    Calculates the maximum depth of a dictionary.\n\n    The depth of a dictionary is defined as the maximum number of nested dictionaries.\n    An empty dictionary or a dictionary with no nested dictionaries has a depth of 1.\n\n    Args:\n        d: The dictionary to calculate the depth of.\n\n    Returns:\n        The maximum depth of the dictionary. Returns 0 for non-dictionary inputs.\n    \"\"\"\n    if not isinstance(d, dict):\n        return 0\n\n    if not d:\n        return 1\n\n    max_depth = 1\n    for key, value in d.items():\n        if isinstance(value, dict):\n            max_depth = max(max_depth, 1 + dict_depth(value))\n        elif isinstance(value, (list, tuple, set)):\n            for item in value:\n                if isinstance(item, dict):\n                    max_depth = max(max_depth, 1 + dict_depth(item))\n    return max_depth"}
{"benchmark": "mbpp", "task_id": "304", "prompt": "Write a python function to find element at a given index after number of rotations.", "reference_code": "def find_Element(arr,ranges,rotations,index) :  \n    for i in range(rotations - 1,-1,-1 ) : \n        left = ranges[i][0] \n        right = ranges[i][1] \n        if (left <= index and right >= index) : \n            if (index == left) : \n                index = right \n            else : \n                index = index - 1 \n    return arr[index] ", "test_imports": [], "test_list": ["assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3", "assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3", "assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1"], "model_name": "google/gemini-2.5-flash", "generated_code": "def find_Element(arr, ranges, index):\n    \"\"\"\n    Finds the element at a given index after a number of rotations.\n\n    Args:\n        arr: The input array.\n        ranges: A list of tuples, where each tuple (start, end) represents a rotation\n                from index 'start' to 'end' (inclusive).\n        index: The index of the element to find after all rotations.\n\n    Returns:\n        The element at the specified index after all rotations.\n    \"\"\"\n    for r_start, r_end in reversed(ranges):\n        # If the index is within the current rotation range\n        if r_start <= index <= r_end:\n            # If the index is the start of the rotation, it moves to the end\n            if index == r_start:\n                index = r_end\n            # Otherwise, the element at 'index' moves one position to the left\n            else:\n                index -= 1\n    return arr[index]"}
{"benchmark": "mbpp", "task_id": "307", "prompt": "Write a function to get a colon of a tuple.", "reference_code": "from copy import deepcopy\ndef colon_tuplex(tuplex,m,n):\n  tuplex_colon = deepcopy(tuplex)\n  tuplex_colon[m].append(n)\n  return tuplex_colon", "test_imports": [], "test_list": ["assert colon_tuplex((\"HELLO\", 5, [], True) ,2,50)==(\"HELLO\", 5, [50], True)", "assert colon_tuplex((\"HELLO\", 5, [], True) ,2,100)==((\"HELLO\", 5, [100],True))", "assert colon_tuplex((\"HELLO\", 5, [], True) ,2,500)==(\"HELLO\", 5, [500], True)"], "model_name": "google/gemini-2.5-flash", "generated_code": "def colon_tuplex(tuplex, m, n):\n  \"\"\"\n  Returns a slice of a tuple from index m to n (exclusive of n).\n\n  Args:\n    tuplex: The input tuple.\n    m: The starting index of the slice.\n    n: The ending index of the slice (exclusive).\n\n  Returns:\n    A new tuple containing the slice of the original tuple.\n  \"\"\"\n  return tuplex[m:n]"}
{"benchmark": "mbpp", "task_id": "300", "prompt": "Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.", "reference_code": "def count_binary_seq(n): \n\tnCr = 1\n\tres = 1\n\tfor r in range(1, n + 1): \n\t\tnCr = (nCr * (n + 1 - r)) / r \n\t\tres += nCr * nCr \n\treturn res ", "test_imports": ["import math"], "test_list": ["assert math.isclose(count_binary_seq(1), 2.0, rel_tol=0.001)", "assert math.isclose(count_binary_seq(2), 6.0, rel_tol=0.001)", "assert math.isclose(count_binary_seq(3), 20.0, rel_tol=0.001)"], "model_name": "google/gemini-2.5-flash", "generated_code": "import math\n\ndef count_binary_seq(n: int) -> int:\n    \"\"\"\n    Calculates the count of all binary sequences of length 2n such that the sum of the first n bits\n    is the same as the sum of the last n bits.\n\n    Args:\n        n: An integer representing half the length of the binary sequence.\n\n    Returns:\n        The count of such binary sequences.\n    \"\"\"\n    total_count = 0\n    # Iterate through all possible sums (k) for the first n bits.\n    # The sum k can range from 0 (all zeros) to n (all ones).\n    for k in range(n + 1):\n        # The number of ways to choose k bits out of n bits to be 1\n        # (which determines the sum of the first n bits to be k)\n        # is given by the binomial coefficient C(n, k).\n        combinations_for_k = math.comb(n, k)\n\n        # Since the sum of the last n bits must also be k,\n        # the number of ways to choose k bits out of the last n bits to be 1\n        # is also C(n, k).\n\n        # For a fixed sum k, the total number of sequences where both halves\n        # sum to k is C(n, k) * C(n, k).\n        total_count += combinations_for_k * combinations_for_k\n\n    return total_count"}
{"benchmark": "mbpp", "task_id": "306", "prompt": "Write a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .", "reference_code": "def max_sum_increasing_subseq(a, n, index, k):\n\tdp = [[0 for i in range(n)] \n\t\t\tfor i in range(n)]\n\tfor i in range(n):\n\t\tif a[i] > a[0]:\n\t\t\tdp[0][i] = a[i] + a[0]\n\t\telse:\n\t\t\tdp[0][i] = a[i]\n\tfor i in range(1, n):\n\t\tfor j in range(n):\n\t\t\tif a[j] > a[i] and j > i:\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\n\t\t\t\telse:\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\n\t\t\telse:\n\t\t\t\tdp[i][j] = dp[i - 1][j]\n\treturn dp[index][k]", "test_imports": [], "test_list": ["assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11", "assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 2, 5) == 7", "assert max_sum_increasing_subseq([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71"], "model_name": "google/gemini-2.5-flash", "generated_code": "def max_sum_increasing_subseq(arr):\n    \"\"\"\n    Finds the maximum sum of an increasing subsequence from a prefix until the ith index,\n    and also including a given kth element which is after i (k > i).\n\n    This problem is interpreted as finding, for each element arr[k], the maximum sum\n    of an increasing subsequence ending at arr[i] (where i < k) plus arr[k],\n    such that arr[i] < arr[k]. If no such arr[i] exists, it's just arr[k].\n\n    The function returns a list where the element at index k represents this maximum sum\n    considering arr[k] as the last element of such a subsequence.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        A list of integers, where result[k] is the maximum sum of an increasing\n        subsequence ending with arr[k], considering all possible prefixes.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return []\n\n    # dp[i] will store the maximum sum of an increasing subsequence ending at index i\n    dp = [0] * n\n\n    for i in range(n):\n        dp[i] = arr[i]  # Initialize with the element itself (subsequence of length 1)\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + arr[i])\n\n    return dp"}
{"benchmark": "mbpp", "task_id": "309", "prompt": "Write a python function to find the maximum of two numbers.", "reference_code": "def maximum(a,b):   \n    if a >= b: \n        return a \n    else: \n        return b ", "test_imports": [], "test_list": ["assert maximum(5,10) == 10", "assert maximum(-1,-2) == -1", "assert maximum(9,7) == 9"], "model_name": "google/gemini-2.5-flash", "generated_code": "def maximum(a, b):\n  \"\"\"\n  Finds the maximum of two numbers.\n\n  Args:\n    a: The first number.\n    b: The second number.\n\n  Returns:\n    The larger of the two numbers.\n  \"\"\"\n  if a > b:\n    return a\n  else:\n    return b"}
{"benchmark": "mbpp", "task_id": "310", "prompt": "Write a function to convert a given string to a tuple of characters.", "reference_code": "def string_to_tuple(str1):\n    result = tuple(x for x in str1 if not x.isspace()) \n    return result", "test_imports": [], "test_list": ["assert string_to_tuple(\"python 3.0\")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')", "assert string_to_tuple(\"item1\")==('i', 't', 'e', 'm', '1')", "assert string_to_tuple(\"15.10\")==('1', '5', '.', '1', '0')"], "model_name": "google/gemini-2.5-flash", "generated_code": "def string_to_tuple(input_string: str) -> tuple:\n    \"\"\"\n    Converts a given string to a tuple of characters.\n\n    Args:\n        input_string: The string to convert.\n\n    Returns:\n        A tuple containing each character of the input string.\n    \"\"\"\n    return tuple(input_string)"}
{"benchmark": "mbpp", "task_id": "312", "prompt": "Write a function to find the volume of a cone.", "reference_code": "import math\ndef volume_cone(r,h):\n  volume = (1.0/3) * math.pi * r * r * h\n  return volume", "test_imports": ["import math"], "test_list": ["assert math.isclose(volume_cone(5,12), 314.15926535897927, rel_tol=0.001)", "assert math.isclose(volume_cone(10,15), 1570.7963267948965, rel_tol=0.001)", "assert math.isclose(volume_cone(19,17), 6426.651371693521, rel_tol=0.001)"], "model_name": "google/gemini-2.5-flash", "generated_code": "import math\n\ndef volume_cone(radius: float, height: float) -> float:\n    \"\"\"\n    Calculates the volume of a cone.\n\n    Args:\n        radius: The radius of the cone's base.\n        height: The height of the cone.\n\n    Returns:\n        The volume of the cone.\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"Radius and height cannot be negative.\")\n    \n    volume = (1/3) * math.pi * (radius ** 2) * height\n    return volume"}
{"benchmark": "mbpp", "task_id": "388", "prompt": "Write a python function to find the highest power of 2 that is less than or equal to n.", "reference_code": "def highest_Power_of_2(n): \n    res = 0 \n    for i in range(n, 0, -1): \n        if ((i & (i - 1)) == 0): \n            res = i \n            break \n    return res ", "test_imports": [], "test_list": ["assert highest_Power_of_2(10) == 8", "assert highest_Power_of_2(19) == 16", "assert highest_Power_of_2(32) == 32"], "model_name": "google/gemini-2.5-flash", "generated_code": "def highest_Power_of_2(n: int) -> int:\n    \"\"\"\n    Finds the highest power of 2 that is less than or equal to n.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        The highest power of 2 that is less than or equal to n.\n        If n is 0, returns 0.\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power"}
{"benchmark": "mbpp", "task_id": "389", "prompt": "Write a function to find the n'th lucas number.", "reference_code": "def find_lucas(n): \n\tif (n == 0): \n\t\treturn 2\n\tif (n == 1): \n\t\treturn 1\n\treturn find_lucas(n - 1) + find_lucas(n - 2) ", "test_imports": [], "test_list": ["assert find_lucas(9) == 76", "assert find_lucas(4) == 7", "assert find_lucas(3) == 4"], "model_name": "google/gemini-2.5-flash", "generated_code": "def find_lucas(n: int) -> int:\n    \"\"\"\n    Finds the n'th Lucas number.\n\n    The Lucas numbers are a sequence of integers similar to the Fibonacci sequence.\n    They are defined by the recurrence relation:\n    L(n) = L(n-1) + L(n-2)\n    with initial values L(0) = 2 and L(1) = 1.\n\n    For example:\n    L(0) = 2\n    L(1) = 1\n    L(2) = L(1) + L(0) = 1 + 2 = 3\n    L(3) = L(2) + L(1) = 3 + 1 = 4\n    L(4) = L(3) + L(2) = 4 + 3 = 7\n\n    Args:\n        n: The index of the Lucas number to find (non-negative integer).\n\n    Returns:\n        The n'th Lucas number.\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b"}
{"benchmark": "mbpp", "task_id": "390", "prompt": "Write a function to apply a given format string to all of the elements in a list.", "reference_code": "def add_string(list_, string):\n add_string=[string.format(i) for i in  list_]\n return add_string", "test_imports": [], "test_list": ["assert add_string([1,2,3,4],'temp{0}')==['temp1', 'temp2', 'temp3', 'temp4']", "assert add_string(['a','b','c','d'], 'python{0}')==[ 'pythona', 'pythonb', 'pythonc', 'pythond']", "assert add_string([5,6,7,8],'string{0}')==['string5', 'string6', 'string7', 'string8']"], "model_name": "google/gemini-2.5-flash", "generated_code": "def add_string(str_list, str_format):\n    \"\"\"\n    Applies a given format string to all elements in a list.\n\n    Args:\n        str_list: A list of items to be formatted.\n        str_format: The format string to apply. This string should contain\n                    a placeholder for the item, e.g., \"Item: {}\".\n\n    Returns:\n        A new list with each element formatted according to str_format.\n    \"\"\"\n    return [str_format.format(item) for item in str_list]"}
{"benchmark": "mbpp", "task_id": "394", "prompt": "Write a function to check if given tuple contains no duplicates.", "reference_code": "def check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return res ", "test_imports": [], "test_list": ["assert check_distinct((1, 4, 5, 6, 1, 4)) == False", "assert check_distinct((1, 4, 5, 6)) == True", "assert check_distinct((2, 3, 4, 5, 6)) == True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def check_distinct(tup: tuple) -> bool:\n    \"\"\"\n    Checks if the given tuple contains no duplicate elements.\n\n    Args:\n        tup: The input tuple.\n\n    Returns:\n        True if all elements in the tuple are distinct, False otherwise.\n    \"\"\"\n    return len(tup) == len(set(tup))"}
{"benchmark": "mbpp", "task_id": "393", "prompt": "Write a function to find the list with maximum length.", "reference_code": "def max_length_list(input_list):\n    max_length = max(len(x) for x in input_list )   \n    max_list = max(input_list, key = lambda i: len(i))    \n    return(max_length, max_list)", "test_imports": [], "test_list": ["assert max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])", "assert max_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(5,[1,2,3,4,5])", "assert max_length_list([[3,4,5],[6,7,8,9],[10,11,12]])==(4,[6,7,8,9])"], "model_name": "google/gemini-2.5-flash", "generated_code": "def max_length_list(input_list):\n    \"\"\"\n    Finds the list with the maximum length from a list of lists.\n\n    Args:\n        input_list: A list containing other lists.\n\n    Returns:\n        The list from input_list that has the maximum length.\n        If input_list is empty, returns None.\n        If there are multiple lists with the same maximum length,\n        the first one encountered is returned.\n    \"\"\"\n    if not input_list:\n        return None\n\n    max_len = -1\n    max_list = None\n\n    for sublist in input_list:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_list = sublist\n    return max_list"}
{"benchmark": "mbpp", "task_id": "395", "prompt": "Write a python function to find the first non-repeated character in a given string.", "reference_code": "def first_non_repeating_character(str1):\n  char_order = []\n  ctr = {}\n  for c in str1:\n    if c in ctr:\n      ctr[c] += 1\n    else:\n      ctr[c] = 1 \n      char_order.append(c)\n  for c in char_order:\n    if ctr[c] == 1:\n      return c\n  return None", "test_imports": [], "test_list": ["assert first_non_repeating_character(\"abcabc\") == None", "assert first_non_repeating_character(\"abc\") == \"a\"", "assert first_non_repeating_character(\"ababc\") == \"c\""], "model_name": "google/gemini-2.5-flash", "generated_code": "def first_non_repeating_character(s: str) -> str:\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The first non-repeated character as a string.\n        Returns an empty string if no non-repeated character is found.\n    \"\"\"\n    char_counts = {}\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n    return \"\""}
{"benchmark": "mbpp", "task_id": "311", "prompt": "Write a python function to set the left most unset bit.", "reference_code": "def set_left_most_unset_bit(n): \n    if not (n & (n + 1)): \n        return n \n    pos, temp, count = 0, n, 0 \n    while temp: \n        if not (temp & 1): \n            pos = count      \n        count += 1; temp>>=1\n    return (n | (1 << (pos))) ", "test_imports": [], "test_list": ["assert set_left_most_unset_bit(10) == 14", "assert set_left_most_unset_bit(12) == 14", "assert set_left_most_unset_bit(15) == 15"], "model_name": "google/gemini-2.5-flash", "generated_code": "def set_left_most_unset_bit(n: int) -> int:\n    \"\"\"\n    Sets the left-most unset bit in a given integer n.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        The integer with its left-most unset bit set.\n        If all bits are set (e.g., for a negative number in two's complement\n        where all bits are considered set, or for a positive number where\n        all bits up to the typical integer size are set), the number is\n        returned unchanged.\n    \"\"\"\n    if n < 0:\n        # For negative numbers, all bits are typically considered set in two's complement\n        # or the concept of \"unset bit\" might not apply as directly.\n        # We return the number unchanged.\n        return n\n\n    if n == 0:\n        # If n is 0, the left-most unset bit is the 0th bit.\n        return 1\n\n    # Find the position of the most significant bit (MSB)\n    # This can be done by repeatedly right-shifting until n becomes 0.\n    # The position of the MSB is the number of shifts.\n    temp_n = n\n    msb_pos = -1\n    while temp_n > 0:\n        temp_n >>= 1\n        msb_pos += 1\n\n    # Iterate from the MSB position downwards to find the first unset bit\n    for i in range(msb_pos, -1, -1):\n        # Check if the i-th bit is unset\n        if not (n & (1 << i)):\n            return n | (1 << i)\n\n    # If all bits up to msb_pos are set, then the next bit to the left\n    # (msb_pos + 1) is the left-most unset bit.\n    # This handles cases like n = 7 (binary 111), where msb_pos is 2.\n    # The 3rd bit (1 << 3) would be the left-most unset bit.\n    return n | (1 << (msb_pos + 1))"}
{"benchmark": "mbpp", "task_id": "396", "prompt": "Write a function to check whether the given string starts and ends with the same character or not.", "reference_code": "import re  \nregex = r'^[a-z]$|^([a-z]).*\\1$'\ndef check_char(string): \n\tif(re.search(regex, string)): \n\t\treturn \"Valid\" \n\telse: \n\t\treturn \"Invalid\" ", "test_imports": [], "test_list": ["assert check_char(\"abba\") == \"Valid\"", "assert check_char(\"a\") == \"Valid\"", "assert check_char(\"abcd\") == \"Invalid\""], "model_name": "google/gemini-2.5-flash", "generated_code": "def check_char(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string starts and ends with the same character.\n\n    Args:\n        input_string: The string to check.\n\n    Returns:\n        True if the string starts and ends with the same character, False otherwise.\n        Returns True for an empty string or a string with a single character.\n    \"\"\"\n    if not input_string:\n        return True\n    return input_string[0] == input_string[-1]"}
{"benchmark": "mbpp", "task_id": "397", "prompt": "Write a function to find the median of three numbers.", "reference_code": "def median_numbers(a,b,c):\n if a > b:\n    if a < c:\n        median = a\n    elif b > c:\n        median = b\n    else:\n        median = c\n else:\n    if a > c:\n        median = a\n    elif b < c:\n        median = b\n    else:\n        median = c\n return median", "test_imports": [], "test_list": ["assert median_numbers(25,55,65)==55.0", "assert median_numbers(20,10,30)==20.0", "assert median_numbers(15,45,75)==45.0"], "model_name": "google/gemini-2.5-flash", "generated_code": "def median_numbers(a, b, c):\n    \"\"\"\n    Finds the median of three numbers.\n\n    Args:\n        a: The first number.\n        b: The second number.\n        c: The third number.\n\n    Returns:\n        The median of the three numbers.\n    \"\"\"\n    if (a <= b <= c) or (c <= b <= a):\n        return b\n    elif (b <= a <= c) or (c <= a <= b):\n        return a\n    else:\n        return c"}
{"benchmark": "mbpp", "task_id": "392", "prompt": "Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).", "reference_code": "def get_max_sum (n):\n\tres = list()\n\tres.append(0)\n\tres.append(1)\n\ti = 2\n\twhile i<n + 1:\n\t\tres.append(max(i, (res[int(i / 2)] \n\t\t\t\t\t\t+ res[int(i / 3)] +\n\t\t\t\t\t\t\tres[int(i / 4)]\n\t\t\t\t\t\t+ res[int(i / 5)])))\n\t\ti = i + 1\n\treturn res[n]", "test_imports": [], "test_list": ["assert get_max_sum(60) == 106", "assert get_max_sum(10) == 12", "assert get_max_sum(2) == 2"], "model_name": "google/gemini-2.5-flash", "generated_code": "def get_max_sum(n: int) -> int:\n    \"\"\"\n    Calculates the maximum sum possible by using the given equation\n    f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Args:\n        n: An integer representing the input to the function f.\n\n    Returns:\n        The maximum sum achievable for the given n.\n    \"\"\"\n    memo = {}\n\n    def solve(k):\n        if k == 0:\n            return 0\n        if k in memo:\n            return memo[k]\n\n        # Calculate the sum of f(k/2) + f(k/3) + f(k/4) + f(k/5)\n        # Use integer division as per the problem statement (n/x implies integer division)\n        sum_of_parts = solve(k // 2) + solve(k // 3) + solve(k // 4) + solve(k // 5)\n\n        # The maximum sum is either k itself or the sum of its parts\n        result = max(k, sum_of_parts)\n        memo[k] = result\n        return result\n\n    return solve(n)"}
{"benchmark": "mbpp", "task_id": "398", "prompt": "Write a function to compute the sum of digits of each number of a given list.", "reference_code": "def sum_of_digits(nums):\n    return sum(int(el) for n in nums for el in str(n) if el.isdigit())", "test_imports": [], "test_list": ["assert sum_of_digits([10,2,56])==14", "assert sum_of_digits([[10,20,4,5,'b',70,'a']])==19", "assert sum_of_digits([10,20,-4,5,-70])==19"], "model_name": "google/gemini-2.5-flash", "generated_code": "def sum_of_digits(numbers: list[int]) -> list[int]:\n    \"\"\"\n    Computes the sum of digits of each number in a given list.\n\n    Args:\n        numbers: A list of integers.\n\n    Returns:\n        A list of integers, where each element is the sum of the digits\n        of the corresponding number in the input list.\n    \"\"\"\n    result = []\n    for num in numbers:\n        s = 0\n        # Handle negative numbers by taking the absolute value\n        abs_num = abs(num)\n        \n        # If the number is 0, its sum of digits is 0\n        if abs_num == 0:\n            result.append(0)\n            continue\n\n        while abs_num > 0:\n            s += abs_num % 10\n            abs_num //= 10\n        result.append(s)\n    return result"}
{"benchmark": "mbpp", "task_id": "391", "prompt": "Write a function to convert more than one list to nested dictionary.", "reference_code": "def convert_list_dictionary(l1, l2, l3):\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\n     return result", "test_imports": [], "test_list": ["assert convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"],[\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"] ,[85, 98, 89, 92])==[{'S001': {'Adina Park': 85}}, {'S002': {'Leyton Marsh': 98}}, {'S003': {'Duncan Boyle': 89}}, {'S004': {'Saim Richards': 92}}]", "assert convert_list_dictionary([\"abc\",\"def\",\"ghi\",\"jkl\"],[\"python\",\"program\",\"language\",\"programs\"],[100,200,300,400])==[{'abc':{'python':100}},{'def':{'program':200}},{'ghi':{'language':300}},{'jkl':{'programs':400}}]", "assert convert_list_dictionary([\"A1\",\"A2\",\"A3\",\"A4\"],[\"java\",\"C\",\"C++\",\"DBMS\"],[10,20,30,40])==[{'A1':{'java':10}},{'A2':{'C':20}},{'A3':{'C++':30}},{'A4':{'DBMS':40}}]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def convert_list_dictionary(keys, values):\n    \"\"\"\n    Converts a list of keys and a list of values into a nested dictionary.\n\n    The function takes two lists: `keys` and `values`.\n    It iterates through the `keys` list from right to left.\n    For each key, it creates a dictionary where the current key maps to the\n    previously created dictionary (or the initial `values` list if it's the\n    first iteration).\n\n    Args:\n        keys (list): A list of strings or other hashable types to be used as keys.\n        values (list): A list of values to be nested at the innermost level.\n\n    Returns:\n        dict: A nested dictionary created from the keys and values.\n              Returns an empty dictionary if keys is empty.\n              Returns a dictionary with the last key mapping to values if keys has one element.\n\n    Examples:\n        >>> convert_list_dictionary(['a', 'b', 'c'], [1, 2, 3])\n        {'a': {'b': {'c': [1, 2, 3]}}}\n\n        >>> convert_list_dictionary(['x', 'y'], ['hello', 'world'])\n        {'x': {'y': ['hello', 'world']}}\n\n        >>> convert_list_dictionary([], [1, 2])\n        {}\n\n        >>> convert_list_dictionary(['only_key'], [100])\n        {'only_key': [100]}\n    \"\"\"\n    if not keys:\n        return {}\n\n    # Start with the innermost value, which is the 'values' list itself.\n    # Then, iterate through the keys in reverse order to build the nested structure.\n    result = values\n    for key in reversed(keys):\n        result = {key: result}\n\n    return result"}
{"benchmark": "mbpp", "task_id": "399", "prompt": "Write a function to perform the mathematical bitwise xor operation across the given tuples.", "reference_code": "def bitwise_xor(test_tup1, test_tup2):\n  res = tuple(ele1 ^ ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) ", "test_imports": [], "test_list": ["assert bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)", "assert bitwise_xor((11, 5, 7, 10), (6, 3, 4, 4)) == (13, 6, 3, 14)", "assert bitwise_xor((12, 6, 8, 11), (7, 4, 5, 6)) == (11, 2, 13, 13)"], "model_name": "google/gemini-2.5-flash", "generated_code": "def bitwise_xor(tuple1, tuple2):\n    \"\"\"\n    Performs the mathematical bitwise XOR operation across the given tuples.\n\n    Args:\n        tuple1 (tuple): The first tuple of integers.\n        tuple2 (tuple): The second tuple of integers.\n\n    Returns:\n        tuple: A new tuple containing the bitwise XOR of corresponding elements\n               from tuple1 and tuple2. The length of the resulting tuple will be\n               the minimum of the lengths of the input tuples.\n    \"\"\"\n    min_len = min(len(tuple1), len(tuple2))\n    result = []\n    for i in range(min_len):\n        result.append(tuple1[i] ^ tuple2[i])\n    return tuple(result)"}
{"benchmark": "mbpp", "task_id": "308", "prompt": "Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.", "reference_code": "def large_product(nums1, nums2, N):\n    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]\n    return result", "test_imports": [], "test_list": ["assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)==[60, 54, 50]", "assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],4)==[60, 54, 50, 48]", "assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],5)==[60, 54, 50, 48, 45]"], "model_name": "google/gemini-2.5-flash", "generated_code": "import heapq\n\ndef large_product(list1: list[int], list2: list[int], n: int) -> list[int]:\n    \"\"\"\n    Finds the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Args:\n        list1: The first list of integers.\n        list2: The second list of integers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list of the n largest products, sorted in descending order.\n    \"\"\"\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    products = []\n    # Use a min-heap to keep track of the n largest products found so far.\n    # The heap will store tuples of (product_value, index1, index2)\n    # to avoid duplicate products if the same product can be formed by different pairs.\n    # However, for this problem, we only need the product values.\n    # A min-heap of size n will store the n largest elements.\n    # If a new product is larger than the smallest in the heap, replace it.\n\n    # Initialize the heap with the first n products (or fewer if lists are small)\n    # from the largest elements of each list.\n    # This optimization is crucial for performance when lists are large.\n\n    # Sort both lists in descending order to easily access largest elements.\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n\n    # A min-heap to store the n largest products.\n    # We store (product_value, index_in_list1, index_in_list2)\n    # to manage the exploration efficiently and avoid redundant calculations.\n    # The heap will store the negative of the product value to make it a max-heap\n    # effectively, as heapq is a min-heap.\n    # Or, we can just store the product values and use it as a min-heap\n    # to keep track of the n largest values.\n\n    # Let's use a min-heap to store the actual product values.\n    # If the heap size is less than n, add the product.\n    # If the heap size is n, and the new product is larger than the smallest\n    # in the heap (heap[0]), then pop the smallest and push the new product.\n\n    min_heap = [] # Stores the n largest products found so far\n\n    # To efficiently find the largest products, we can use a max-heap\n    # of (product, index1, index2) to explore potential products.\n    # However, a simpler approach for this problem is to iterate through\n    # the products and maintain a min-heap of size n.\n\n    # Iterate through all possible products and maintain the top n.\n    # This approach has O(len(list1) * len(list2) * log(n)) complexity.\n    # For very large lists, this might be too slow.\n\n    # A more optimized approach for finding the top N products:\n    # Consider the products formed by the largest elements.\n    # We can use a max-heap to keep track of the largest potential products to explore.\n    # The heap will store tuples: (-product_value, index1, index2)\n    # We need to keep track of visited pairs to avoid duplicates.\n\n    # Initialize a max-heap with the product of the largest elements.\n    # The heap stores (-product, i, j)\n    # A set to keep track of visited (i, j) pairs.\n    \n    # Handle edge cases where n is larger than the total number of products\n    max_products_possible = len(list1) * len(list2)\n    n = min(n, max_products_possible)\n\n    if n == 0:\n        return []\n\n    # Initialize a min-heap to store the n largest products.\n    # We will iterate through all possible products and maintain this heap.\n    # This is the most straightforward approach given the constraints.\n    \n    for x in list1:\n        for y in list2:\n            product = x * y\n            if len(min_heap) < n:\n                heapq.heappush(min_heap, product)\n            elif product > min_heap[0]:\n                heapq.heapreplace(min_heap, product)\n\n    # The min_heap now contains the n largest products.\n    # Convert to a list and sort in descending order.\n    result = sorted(list(min_heap), reverse=True)\n    return result"}
{"benchmark": "mbpp", "task_id": "400", "prompt": "Write a function to extract the number of unique tuples in the given list.", "reference_code": "def extract_freq(test_list):\n  res = len(list(set(tuple(sorted(sub)) for sub in test_list)))\n  return (res)", "test_imports": [], "test_list": ["assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3", "assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4", "assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4"], "model_name": "google/gemini-2.5-flash", "generated_code": "def extract_freq(list_of_tuples):\n    \"\"\"\n    Extracts the number of unique tuples in the given list.\n\n    Args:\n        list_of_tuples: A list of tuples.\n\n    Returns:\n        The number of unique tuples in the list.\n    \"\"\"\n    unique_tuples = set(list_of_tuples)\n    return len(unique_tuples)"}
{"benchmark": "mbpp", "task_id": "405", "prompt": "Write a function to check whether an element exists within a tuple.", "reference_code": "def check_tuplex(tuplex,tuple1): \n  if tuple1 in tuplex:\n    return True\n  else:\n     return False", "test_imports": [], "test_list": ["assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'r')==True", "assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'5')==False", "assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\",\"e\"),3)==True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def check_tuplex(tuplex, element):\n  \"\"\"\n  Checks whether an element exists within a tuple.\n\n  Args:\n    tuplex: The tuple to search within.\n    element: The element to search for.\n\n  Returns:\n    True if the element is found in the tuple, False otherwise.\n  \"\"\"\n  return element in tuplex"}
{"benchmark": "mbpp", "task_id": "404", "prompt": "Write a python function to find the minimum of two numbers.", "reference_code": "def minimum(a,b):   \n    if a <= b: \n        return a \n    else: \n        return b ", "test_imports": [], "test_list": ["assert minimum(1,2) == 1", "assert minimum(-5,-4) == -5", "assert minimum(0,0) == 0"], "model_name": "google/gemini-2.5-flash", "generated_code": "def minimum(a: float, b: float) -> float:\n    \"\"\"\n    Finds the minimum of two numbers.\n\n    Args:\n        a: The first number.\n        b: The second number.\n\n    Returns:\n        The smaller of the two numbers.\n    \"\"\"\n    if a < b:\n        return a\n    else:\n        return b"}
{"benchmark": "mbpp", "task_id": "406", "prompt": "Write a python function to find whether the parity of a given number is odd.", "reference_code": "def find_Parity(x): \n    y = x ^ (x >> 1); \n    y = y ^ (y >> 2); \n    y = y ^ (y >> 4); \n    y = y ^ (y >> 8); \n    y = y ^ (y >> 16); \n    if (y & 1): \n        return True\n    return False", "test_imports": [], "test_list": ["assert find_Parity(12) == False", "assert find_Parity(7) == True", "assert find_Parity(10) == False"], "model_name": "google/gemini-2.5-flash", "generated_code": "def find_Parity(num: int) -> bool:\n    \"\"\"\n    Finds whether the parity of a given number is odd.\n\n    Parity is the number of set bits (1s) in the binary representation of a number.\n    An odd parity means there is an odd number of set bits.\n\n    Args:\n        num: The integer number to check.\n\n    Returns:\n        True if the parity of the number is odd, False otherwise.\n    \"\"\"\n    set_bits_count = 0\n    while num > 0:\n        num &= (num - 1)  # Brian Kernighan's algorithm to count set bits\n        set_bits_count += 1\n    return set_bits_count % 2 != 0"}
{"benchmark": "mbpp", "task_id": "401", "prompt": "Write a function to perform index wise addition of tuple elements in the given two nested tuples.", "reference_code": "def add_nested_tuples(test_tup1, test_tup2):\n  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "test_imports": [], "test_list": ["assert add_nested_tuples(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((7, 10), (7, 14), (3, 10), (8, 13))", "assert add_nested_tuples(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((9, 12), (9, 16), (5, 12), (10, 15))", "assert add_nested_tuples(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((11, 14), (11, 18), (7, 14), (12, 17))"], "model_name": "google/gemini-2.5-flash", "generated_code": "def add_nested_tuples(tuple1, tuple2):\n    \"\"\"\n    Performs index-wise addition of elements in two nested tuples.\n\n    Args:\n        tuple1: The first nested tuple.\n        tuple2: The second nested tuple.\n\n    Returns:\n        A new nested tuple where corresponding elements from tuple1 and tuple2\n        are added together.\n    \"\"\"\n    if not tuple1 and not tuple2:\n        return ()\n    if not tuple1:\n        return tuple2\n    if not tuple2:\n        return tuple1\n\n    result = []\n    for i in range(max(len(tuple1), len(tuple2))):\n        if i < len(tuple1) and i < len(tuple2):\n            sub_tuple1 = tuple1[i]\n            sub_tuple2 = tuple2[i]\n            sub_result = []\n            for j in range(max(len(sub_tuple1), len(sub_tuple2))):\n                if j < len(sub_tuple1) and j < len(sub_tuple2):\n                    sub_result.append(sub_tuple1[j] + sub_tuple2[j])\n                elif j < len(sub_tuple1):\n                    sub_result.append(sub_tuple1[j])\n                else:\n                    sub_result.append(sub_tuple2[j])\n            result.append(tuple(sub_result))\n        elif i < len(tuple1):\n            result.append(tuple1[i])\n        else:\n            result.append(tuple2[i])\n            \n    return tuple(result)"}
{"benchmark": "mbpp", "task_id": "412", "prompt": "Write a python function to remove odd numbers from a given list.", "reference_code": "def remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l", "test_imports": [], "test_list": ["assert remove_odd([1,2,3]) == [2]", "assert remove_odd([2,4,6]) == [2,4,6]", "assert remove_odd([10,20,3]) == [10,20]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def remove_odd(numbers: list) -> list:\n    \"\"\"\n    Removes odd numbers from a given list.\n\n    Args:\n        numbers: A list of integers.\n\n    Returns:\n        A new list containing only the even numbers from the input list.\n    \"\"\"\n    return [num for num in numbers if num % 2 == 0]"}
{"benchmark": "mbpp", "task_id": "411", "prompt": "Write a function to convert the given snake case string to camel case string.", "reference_code": "import re\ndef snake_to_camel(word):\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))", "test_imports": [], "test_list": ["assert snake_to_camel('android_tv') == 'AndroidTv'", "assert snake_to_camel('google_pixel') == 'GooglePixel'", "assert snake_to_camel('apple_watch') == 'AppleWatch'"], "model_name": "google/gemini-2.5-flash", "generated_code": "def snake_to_camel(snake_str: str) -> str:\n    \"\"\"\n    Converts a snake_case string to a camelCase string.\n\n    Args:\n        snake_str: The input string in snake_case.\n\n    Returns:\n        The converted string in camelCase.\n    \"\"\"\n    components = snake_str.split('_')\n    # Capitalize the first letter of each component except the first one\n    # and join them together.\n    return components[0] + ''.join(x.title() for x in components[1:])"}
{"benchmark": "mbpp", "task_id": "407", "prompt": "Write a function to create the next bigger number by rearranging the digits of a given number.", "reference_code": "def rearrange_bigger(n):\n    nums = list(str(n))\n    for i in range(len(nums)-2,-1,-1):\n        if nums[i] < nums[i+1]:\n            z = nums[i:]\n            y = min(filter(lambda x: x > z[0], z))\n            z.remove(y)\n            z.sort()\n            nums[i:] = [y] + z\n            return int(\"\".join(nums))\n    return False", "test_imports": [], "test_list": ["assert rearrange_bigger(12)==21", "assert rearrange_bigger(10)==False", "assert rearrange_bigger(102)==120"], "model_name": "google/gemini-2.5-flash", "generated_code": "import itertools\n\ndef rearrange_bigger(n: int) -> int:\n    s = str(n)\n    digits = list(s)\n    \n    # Find the largest index k such that a[k] < a[k + 1]. \n    # If no such index exists, the permutation is the last permutation.\n    k = -1\n    for i in range(len(digits) - 1):\n        if digits[i] < digits[i+1]:\n            k = i\n    \n    if k == -1:\n        return -1  # No bigger number can be formed\n\n    # Find the largest index l greater than k such that a[k] < a[l].\n    l = -1\n    for i in range(k + 1, len(digits)):\n        if digits[k] < digits[i]:\n            l = i\n            \n    # Swap the value of a[k] with that of a[l].\n    digits[k], digits[l] = digits[l], digits[k]\n    \n    # Reverse the sequence from a[k + 1] up to and including the final element a[n].\n    digits[k+1:] = reversed(digits[k+1:])\n    \n    result = int(\"\".join(digits))\n    return result if result > n else -1"}
{"benchmark": "mbpp", "task_id": "414", "prompt": "Write a python function to check whether any value in a sequence exists in a sequence or not.", "reference_code": "def overlapping(list1,list2):  \n    for i in range(len(list1)): \n        for j in range(len(list2)): \n            if(list1[i]==list2[j]): \n                return True\n    return False", "test_imports": [], "test_list": ["assert overlapping([1,2,3,4,5],[6,7,8,9]) == False", "assert overlapping([1,2,3],[4,5,6]) == False", "assert overlapping([1,4,5],[1,4,5]) == True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def overlapping(list1, list2):\n  \"\"\"\n  Checks if any value in list1 exists in list2.\n\n  Args:\n    list1: The first sequence (e.g., list, tuple, set).\n    list2: The second sequence (e.g., list, tuple, set).\n\n  Returns:\n    True if at least one element from list1 is found in list2,\n    False otherwise.\n  \"\"\"\n  for item1 in list1:\n    if item1 in list2:\n      return True\n  return False"}
{"benchmark": "mbpp", "task_id": "409", "prompt": "Write a function to find the minimum product from the pairs of tuples within a given list.", "reference_code": "def min_product_tuple(list1):\n    result_min = min([abs(x * y) for x, y in list1] )\n    return result_min", "test_imports": [], "test_list": ["assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==8", "assert min_product_tuple([(10,20), (15,2), (5,10)] )==30", "assert min_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==100"], "model_name": "google/gemini-2.5-flash", "generated_code": "def min_product_tuple(list_of_tuples):\n    \"\"\"\n    Finds the minimum product from the pairs of tuples within a given list.\n\n    Args:\n        list_of_tuples: A list of tuples, where each tuple contains two numbers.\n\n    Returns:\n        The minimum product found among all pairs of numbers in the tuples.\n        Returns None if the input list is empty or if any tuple is empty.\n    \"\"\"\n    if not list_of_tuples:\n        return None\n\n    min_prod = float('inf')\n\n    for tpl in list_of_tuples:\n        if len(tpl) < 2:\n            # Handle cases where a tuple might not have two elements\n            # Depending on requirements, one might raise an error or skip.\n            # Here, we'll treat it as if it can't form a product pair.\n            continue\n        \n        product = tpl[0] * tpl[1]\n        if product < min_prod:\n            min_prod = product\n\n    if min_prod == float('inf'):\n        # This case happens if list_of_tuples was not empty but all tuples\n        # had fewer than 2 elements.\n        return None\n        \n    return min_prod"}
{"benchmark": "mbpp", "task_id": "413", "prompt": "Write a function to extract the nth element from a given list of tuples.", "reference_code": "def extract_nth_element(list1, n):\n    result = [x[n] for x in list1]\n    return result", "test_imports": [], "test_list": ["assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,0)==['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']", "assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,2)==[99, 96, 94, 98]", "assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)],1)==[98, 97, 91, 94]"], "model_name": "google/gemini-2.5-flash", "generated_code": "from typing import List, Tuple, Any\n\ndef extract_nth_element(data: List[Tuple], n: int) -> List[Any]:\n    \"\"\"\n    Extracts the nth element from each tuple in a list of tuples.\n\n    Args:\n        data: A list of tuples.\n        n: The index of the element to extract from each tuple (0-indexed).\n\n    Returns:\n        A list containing the nth elements from each tuple.\n        If a tuple does not have an element at index n, it is skipped.\n    \"\"\"\n    result = []\n    for item_tuple in data:\n        if 0 <= n < len(item_tuple):\n            result.append(item_tuple[n])\n    return result"}
{"benchmark": "mbpp", "task_id": "408", "prompt": "Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.", "reference_code": "import heapq\ndef k_smallest_pairs(nums1, nums2, k):\n   queue = []\n   def push(i, j):\n       if i < len(nums1) and j < len(nums2):\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\n   push(0, 0)\n   pairs = []\n   while queue and len(pairs) < k:\n       _, i, j = heapq.heappop(queue)\n       pairs.append([nums1[i], nums2[j]])\n       push(i, j + 1)\n       if j == 0:\n           push(i + 1, 0)\n   return pairs", "test_imports": [], "test_list": ["assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]", "assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]", "assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]"], "model_name": "google/gemini-2.5-flash", "generated_code": "import heapq\n\ndef k_smallest_pairs(nums1: list[int], nums2: list[int], k: int) -> list[list[int]]:\n    \"\"\"\n    Finds k number of smallest pairs which consist of one element from the first array\n    and one element from the second array.\n\n    Args:\n        nums1: The first list of integers.\n        nums2: The second list of integers.\n        k: The number of smallest pairs to find.\n\n    Returns:\n        A list of k smallest pairs, where each pair is a list [num1_element, num2_element].\n    \"\"\"\n    if not nums1 or not nums2 or k == 0:\n        return []\n\n    min_heap = []\n    result = []\n    \n    # Push the first k pairs (or fewer if nums1 is smaller) into the min-heap.\n    # Each element in the heap is (sum, index_in_nums1, index_in_nums2).\n    # We only need to consider starting with the first element of nums2 for each element in nums1\n    # because nums1 and nums2 are sorted.\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))\n\n    while min_heap and len(result) < k:\n        current_sum, i, j = heapq.heappop(min_heap)\n        result.append([nums1[i], nums2[j]])\n\n        # If there is a next element in nums2 for the current nums1[i],\n        # push the next pair into the heap.\n        if j + 1 < len(nums2):\n            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n    return result"}
{"benchmark": "mbpp", "task_id": "417", "prompt": "Write a function to find common first element in given list of tuple.", "reference_code": "def group_tuples(Input): \n\tout = {} \n\tfor elem in Input: \n\t\ttry: \n\t\t\tout[elem[0]].extend(elem[1:]) \n\t\texcept KeyError: \n\t\t\tout[elem[0]] = list(elem) \n\treturn [tuple(values) for values in out.values()] ", "test_imports": [], "test_list": ["assert group_tuples([('x', 'y'), ('x', 'z'), ('w', 't')]) == [('x', 'y', 'z'), ('w', 't')]", "assert group_tuples([('a', 'b'), ('a', 'c'), ('d', 'e')]) == [('a', 'b', 'c'), ('d', 'e')]", "assert group_tuples([('f', 'g'), ('f', 'g'), ('h', 'i')]) == [('f', 'g', 'g'), ('h', 'i')]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def group_tuples(tuples_list):\n    \"\"\"\n    Groups tuples in a list by their first element.\n\n    Args:\n        tuples_list: A list of tuples.\n\n    Returns:\n        A dictionary where keys are the first elements of the tuples,\n        and values are lists of tuples that share that first element.\n    \"\"\"\n    grouped_data = {}\n    for tpl in tuples_list:\n        if tpl:  # Ensure the tuple is not empty\n            first_element = tpl[0]\n            if first_element not in grouped_data:\n                grouped_data[first_element] = []\n            grouped_data[first_element].append(tpl)\n    return grouped_data"}
{"benchmark": "mbpp", "task_id": "418", "prompt": "Write a python function to find the element of a list having maximum length.", "reference_code": "def Find_Max(lst): \n    maxList = max((x) for x in lst) \n    return maxList", "test_imports": [], "test_list": ["assert Find_Max([['A'],['A','B'],['A','B','C']]) == ['A','B','C']", "assert Find_Max([[1],[1,2],[1,2,3]]) == [1,2,3]", "assert Find_Max([[1,1],[1,2,3],[1,5,6,1]]) == [1,5,6,1]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def Find_Max(input_list):\n    \"\"\"\n    Finds the element of a list having the maximum length.\n\n    Args:\n        input_list: A list of elements (e.g., strings, lists, tuples).\n\n    Returns:\n        The element from the input_list that has the maximum length.\n        If the input_list is empty, returns None.\n        If multiple elements have the same maximum length, the first one encountered is returned.\n    \"\"\"\n    if not input_list:\n        return None\n\n    max_length_element = input_list[0]\n    max_length = len(input_list[0])\n\n    for element in input_list[1:]:\n        current_length = len(element)\n        if current_length > max_length:\n            max_length = current_length\n            max_length_element = element\n\n    return max_length_element"}
{"benchmark": "mbpp", "task_id": "419", "prompt": "Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.", "reference_code": "def round_and_sum(list1):\n  lenght=len(list1)\n  round_and_sum=sum(list(map(round,list1))* lenght)\n  return round_and_sum", "test_imports": [], "test_list": ["assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243", "assert round_and_sum([5,2,9,24.3,29])==345", "assert round_and_sum([25.0,56.7,89.2])==513"], "model_name": "google/gemini-2.5-flash", "generated_code": "import math\n\ndef round_and_sum(numbers: list[float]) -> int:\n    \"\"\"\n    Rounds every number in a given list of numbers, calculates their sum,\n    and then multiplies the sum by the length of the list.\n\n    Args:\n        numbers: A list of floating-point numbers.\n\n    Returns:\n        An integer representing the total sum of rounded numbers multiplied\n        by the length of the list.\n    \"\"\"\n    if not numbers:\n        return 0\n\n    rounded_sum = sum(round(num) for num in numbers)\n    return int(rounded_sum * len(numbers))"}
{"benchmark": "mbpp", "task_id": "420", "prompt": "Write a python function to find the cube sum of first n even natural numbers.", "reference_code": "def cube_Sum(n): \n    sum = 0\n    for i in range(1,n + 1): \n        sum += (2*i)*(2*i)*(2*i) \n    return sum", "test_imports": [], "test_list": ["assert cube_Sum(2) == 72", "assert cube_Sum(3) == 288", "assert cube_Sum(4) == 800"], "model_name": "google/gemini-2.5-flash", "generated_code": "def cube_Sum(n: int) -> int:\n    \"\"\"\n    Calculates the cube sum of the first n even natural numbers.\n\n    Args:\n        n: An integer representing the number of even natural numbers.\n\n    Returns:\n        The sum of the cubes of the first n even natural numbers.\n        Returns 0 if n is less than or equal to 0.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    total_sum = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total_sum += even_number ** 3\n    return total_sum"}
{"benchmark": "mbpp", "task_id": "410", "prompt": "Write a function to find the minimum value in a given heterogeneous list.", "reference_code": "def min_val(listval):\n     min_val = min(i for i in listval if isinstance(i, int))\n     return min_val", "test_imports": [], "test_list": ["assert min_val(['Python', 3, 2, 4, 5, 'version'])==2", "assert min_val(['Python', 15, 20, 25])==15", "assert min_val(['Python', 30, 20, 40, 50, 'version'])==20"], "model_name": "google/gemini-2.5-flash", "generated_code": "def min_val(data):\n    \"\"\"\n    Finds the minimum value in a given heterogeneous list.\n\n    The list can contain integers, floats, and strings.\n    - For numbers, the standard numerical comparison applies.\n    - For strings, lexicographical comparison applies.\n    - When comparing a number and a string, the number is considered smaller.\n    - The list is guaranteed to be non-empty.\n\n    Args:\n        data: A list of heterogeneous elements (integers, floats, strings).\n\n    Returns:\n        The minimum value found in the list.\n    \"\"\"\n    if not data:\n        return None  # Or raise an error, depending on desired behavior for empty list\n\n    min_value = data[0]\n\n    for item in data[1:]:\n        # Helper function to determine the type for comparison\n        def get_comparable_type(val):\n            if isinstance(val, (int, float)):\n                return 0, val  # Numbers are type 0\n            elif isinstance(val, str):\n                return 1, val  # Strings are type 1\n            else:\n                # Handle other types if necessary, or raise an error\n                return 2, val\n\n        min_type, min_val_comparable = get_comparable_type(min_value)\n        item_type, item_comparable = get_comparable_type(item)\n\n        if item_type < min_type:\n            # If item is a number and min_value is a string, item is smaller\n            min_value = item\n        elif item_type == min_type:\n            # If both are numbers or both are strings, compare directly\n            if item_comparable < min_val_comparable:\n                min_value = item\n        # If item_type > min_type (e.g., item is string, min_value is number), min_value remains\n    return min_value"}
{"benchmark": "mbpp", "task_id": "415", "prompt": "Write a python function to find a pair with highest product from a given array of integers.", "reference_code": "def max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    ", "test_imports": [], "test_list": ["assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)", "assert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)", "assert max_Product([1,2,3]) == (2,3)"], "model_name": "google/gemini-2.5-flash", "generated_code": "def max_Product(arr):\n    \"\"\"\n    Finds a pair with the highest product from a given array of integers.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        A tuple containing the two integers that form the highest product.\n        If the array has fewer than two elements, returns None.\n    \"\"\"\n    if len(arr) < 2:\n        return None\n\n    # Initialize variables to store the two largest and two smallest numbers\n    # This handles cases with negative numbers where two small negatives can give a large positive product\n    max1 = float('-inf')\n    max2 = float('-inf')\n    min1 = float('inf')\n    min2 = float('inf')\n\n    for num in arr:\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n\n    # Compare the product of the two largest numbers with the product of the two smallest numbers\n    if max1 * max2 > min1 * min2:\n        return (max2, max1)\n    else:\n        return (min1, min2)"}
{"benchmark": "mbpp", "task_id": "424", "prompt": "Write a function to extract only the rear index element of each string in the given tuple.", "reference_code": "def extract_rear(test_tuple):\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\n  return (res) ", "test_imports": [], "test_list": ["assert extract_rear(('Mers', 'for', 'Vers') ) == ['s', 'r', 's']", "assert extract_rear(('Avenge', 'for', 'People') ) == ['e', 'r', 'e']", "assert extract_rear(('Gotta', 'get', 'go') ) == ['a', 't', 'o']"], "model_name": "google/gemini-2.5-flash", "generated_code": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n\n    Args:\n        tuple_of_strings: A tuple containing strings.\n\n    Returns:\n        A tuple containing the last character of each string.\n        If a string is empty, an empty string is returned for that element.\n    \"\"\"\n    return tuple(s[-1] if s else '' for s in tuple_of_strings)"}
{"benchmark": "mbpp", "task_id": "425", "prompt": "Write a function to count the number of sublists containing a particular element.", "reference_code": "def count_element_in_list(list1, x): \n    ctr = 0\n    for i in range(len(list1)): \n        if x in list1[i]: \n            ctr+= 1          \n    return ctr", "test_imports": [], "test_list": ["assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]],1)==3", "assert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'A')==3", "assert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'E')==1"], "model_name": "google/gemini-2.5-flash", "generated_code": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists within a list of lists that contain a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to search for.\n\n    Returns:\n        An integer representing the count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count"}
{"benchmark": "mbpp", "task_id": "426", "prompt": "Write a function to filter odd numbers.", "reference_code": "def filter_oddnumbers(nums):\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\n return odd_nums", "test_imports": [], "test_list": ["assert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1,3,5,7,9]", "assert filter_oddnumbers([10,20,45,67,84,93])==[45,67,93]", "assert filter_oddnumbers([5,7,9,8,6,4,3])==[5,7,9,3]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def filter_oddnumbers(numbers: list) -> list:\n    \"\"\"\n    Filters a list of numbers, returning only the odd numbers.\n\n    Args:\n        numbers: A list of integers.\n\n    Returns:\n        A new list containing only the odd numbers from the input list.\n    \"\"\"\n    return [num for num in numbers if num % 2 != 0]"}
{"benchmark": "mbpp", "task_id": "422", "prompt": "Write a python function to find the average of cubes of first n natural numbers.", "reference_code": "def find_Average_Of_Cube(n):  \n    sum = 0\n    for i in range(1, n + 1): \n        sum += i * i * i  \n    return round(sum / n, 6) ", "test_imports": [], "test_list": ["assert find_Average_Of_Cube(2) == 4.5", "assert find_Average_Of_Cube(3) == 12", "assert find_Average_Of_Cube(1) == 1"], "model_name": "google/gemini-2.5-flash", "generated_code": "def find_Average_Of_Cube(n: int) -> float:\n    \"\"\"\n    Finds the average of the cubes of the first n natural numbers.\n\n    Args:\n        n: An integer representing the number of natural numbers.\n\n    Returns:\n        A float representing the average of the cubes of the first n natural numbers.\n        Returns 0.0 if n is 0.\n    \"\"\"\n    if n <= 0:\n        return 0.0\n    \n    # The sum of the cubes of the first n natural numbers is given by the formula:\n    # (n * (n + 1) / 2)^2\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    \n    # The average is the sum divided by n\n    average = sum_of_cubes / n\n    \n    return float(average)"}
{"benchmark": "mbpp", "task_id": "427", "prompt": "Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.", "reference_code": "import re\ndef change_date_format(dt):\n        return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)", "test_imports": [], "test_list": ["assert change_date_format(\"2026-01-02\") == '02-01-2026'", "assert change_date_format(\"2020-11-13\") == '13-11-2020'", "assert change_date_format(\"2021-04-26\") == '26-04-2021'"], "model_name": "google/gemini-2.5-flash", "generated_code": "def change_date_format(date_str: str) -> str:\n    \"\"\"\n    Converts a date of yyyy-mm-dd format to dd-mm-yyyy format.\n\n    Args:\n        date_str: The date string in yyyy-mm-dd format.\n\n    Returns:\n        The date string in dd-mm-yyyy format.\n    \"\"\"\n    parts = date_str.split('-')\n    year = parts[0]\n    month = parts[1]\n    day = parts[2]\n    return f\"{day}-{month}-{year}\""}
{"benchmark": "mbpp", "task_id": "429", "prompt": "Write a function to extract the elementwise and tuples from the given two tuples.", "reference_code": "def and_tuples(test_tup1, test_tup2):\n  res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) ", "test_imports": [], "test_list": ["assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)", "assert and_tuples((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)", "assert and_tuples((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)"], "model_name": "google/gemini-2.5-flash", "generated_code": "def and_tuples(tuple1, tuple2):\n    \"\"\"\n    Performs an element-wise logical AND operation on two tuples.\n\n    Args:\n        tuple1: The first tuple of boolean-like values (e.g., 0, 1, True, False).\n        tuple2: The second tuple of boolean-like values (e.g., 0, 1, True, False).\n\n    Returns:\n        A new tuple where each element is the result of the logical AND\n        of the corresponding elements from tuple1 and tuple2.\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Input tuples must have the same length.\")\n\n    result_tuple = tuple(bool(a) and bool(b) for a, b in zip(tuple1, tuple2))\n    return result_tuple"}
{"benchmark": "mbpp", "task_id": "428", "prompt": "Write a function to sort the given array by using shell sort.", "reference_code": "def shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > current_item:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n\n    return my_list", "test_imports": [], "test_list": ["assert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]", "assert shell_sort([24, 22, 39, 34, 87, 73, 68]) == [22, 24, 34, 39, 68, 73, 87]", "assert shell_sort([32, 30, 16, 96, 82, 83, 74]) == [16, 30, 32, 74, 82, 83, 96]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    Args:\n        arr: The list of elements to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr"}
{"benchmark": "mbpp", "task_id": "431", "prompt": "Write a function that takes two lists and returns true if they have at least one common element.", "reference_code": "def common_element(list1, list2):\n     result = False\n     for x in list1:\n         for y in list2:\n             if x == y:\n                 result = True\n                 return result", "test_imports": [], "test_list": ["assert common_element([1,2,3,4,5], [5,6,7,8,9])==True", "assert common_element([1,2,3,4,5], [6,7,8,9])==None", "assert common_element(['a','b','c'], ['d','b','e'])==True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def common_element(list1, list2):\n    \"\"\"\n    Checks if two lists have at least one common element.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n\n    Returns:\n        True if there is at least one common element, False otherwise.\n    \"\"\"\n    set1 = set(list1)\n    for item in list2:\n        if item in set1:\n            return True\n    return False"}
{"benchmark": "mbpp", "task_id": "432", "prompt": "Write a function to find the median length of a trapezium.", "reference_code": "def median_trapezium(base1,base2,height):\n median = 0.5 * (base1+ base2)\n return median", "test_imports": [], "test_list": ["assert median_trapezium(15,25,35)==20", "assert median_trapezium(10,20,30)==15", "assert median_trapezium(6,9,4)==7.5"], "model_name": "google/gemini-2.5-flash", "generated_code": "def median_trapezium(base1, base2):\n    \"\"\"\n    Calculates the median length of a trapezium.\n\n    The median of a trapezium is the line segment connecting the midpoints of the non-parallel sides.\n    Its length is the average of the lengths of the two parallel bases.\n\n    Args:\n        base1 (float or int): The length of the first parallel base.\n        base2 (float or int): The length of the second parallel base.\n\n    Returns:\n        float: The median length of the trapezium.\n    \"\"\"\n    return (base1 + base2) / 2"}
{"benchmark": "mbpp", "task_id": "421", "prompt": "Write a function to concatenate each element of tuple by the delimiter.", "reference_code": "def concatenate_tuple(test_tup):\n    delim = \"-\"\n    res = ''.join([str(ele) + delim for ele in test_tup])\n    res = res[ : len(res) - len(delim)]\n    return (str(res)) ", "test_imports": [], "test_list": ["assert concatenate_tuple((\"ID\", \"is\", 4, \"UTS\") ) == 'ID-is-4-UTS'", "assert concatenate_tuple((\"QWE\", \"is\", 4, \"RTY\") ) == 'QWE-is-4-RTY'", "assert concatenate_tuple((\"ZEN\", \"is\", 4, \"OP\") ) == 'ZEN-is-4-OP'"], "model_name": "google/gemini-2.5-flash", "generated_code": "def concatenate_tuple(input_tuple, delimiter):\n    \"\"\"\n    Concatenates each element of a tuple by the given delimiter.\n\n    Args:\n        input_tuple: A tuple containing elements that can be converted to strings.\n        delimiter: The string to use as a delimiter between elements.\n\n    Returns:\n        A single string with all elements of the tuple concatenated by the delimiter.\n        If the input_tuple is empty, an empty string is returned.\n    \"\"\"\n    return delimiter.join(str(item) for item in input_tuple)"}
{"benchmark": "mbpp", "task_id": "433", "prompt": "Write a function to check whether the entered number is greater than the elements of the given array.", "reference_code": "def check_greater(arr, number):\n  arr.sort()\n  return number > arr[-1]", "test_imports": [], "test_list": ["assert check_greater([1, 2, 3, 4, 5], 4) == False", "assert check_greater([2, 3, 4, 5, 6], 8) == True", "assert check_greater([9, 7, 4, 8, 6, 1], 11) == True"], "model_name": "google/gemini-2.5-flash", "generated_code": "def check_greater(arr, number):\n    \"\"\"\n    Checks if the given number is greater than all elements in the array.\n\n    Args:\n        arr (list): A list of numbers.\n        number (int or float): The number to compare against the array elements.\n\n    Returns:\n        bool: True if the number is greater than all elements in the array,\n              False otherwise. Returns True for an empty array.\n    \"\"\"\n    if not arr:\n        return True\n    \n    for element in arr:\n        if number <= element:\n            return False\n    return True"}
{"benchmark": "mbpp", "task_id": "434", "prompt": "Write a function that matches a string that has an a followed by one or more b's.", "reference_code": "import re\ndef text_match_one(text):\n        patterns = 'ab+?'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n", "test_imports": [], "test_list": ["assert text_match_one(\"ac\")==False", "assert text_match_one(\"dc\")==False", "assert text_match_one(\"abba\")==True"], "model_name": "google/gemini-2.5-flash", "generated_code": "import re\n\ndef text_match_one(text):\n  \"\"\"\n  Matches a string that has an 'a' followed by one or more 'b's.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A re.Match object if a match is found, None otherwise.\n  \"\"\"\n  pattern = 'ab+'\n  return re.search(pattern, text)"}
{"benchmark": "mbpp", "task_id": "435", "prompt": "Write a python function to find the last digit of a given number.", "reference_code": "def last_Digit(n) :\n    return (n % 10) ", "test_imports": [], "test_list": ["assert last_Digit(123) == 3", "assert last_Digit(25) == 5", "assert last_Digit(30) == 0"], "model_name": "google/gemini-2.5-flash", "generated_code": "def last_Digit(number: int) -> int:\n    \"\"\"\n    Finds the last digit of a given number.\n\n    Args:\n        number: An integer.\n\n    Returns:\n        The last digit of the number.\n    \"\"\"\n    return abs(number) % 10"}
{"benchmark": "mbpp", "task_id": "436", "prompt": "Write a python function to return the negative numbers in a list.", "reference_code": "def neg_nos(list1):\n  out = []\n  for num in list1: \n    if num < 0: \n      out.append(num)\n  return out ", "test_imports": [], "test_list": ["assert neg_nos([-1,4,5,-6]) == [-1,-6]", "assert neg_nos([-1,-2,3,4]) == [-1,-2]", "assert neg_nos([-7,-6,8,9]) == [-7,-6]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def neg_nos(l: list) -> list:\n    \"\"\"\n    Returns a new list containing only the negative numbers from the input list.\n\n    Args:\n        l: A list of numbers.\n\n    Returns:\n        A new list containing only the negative numbers.\n    \"\"\"\n    negative_numbers = []\n    for num in l:\n        if num < 0:\n            negative_numbers.append(num)\n    return negative_numbers"}
{"benchmark": "mbpp", "task_id": "437", "prompt": "Write a function to remove odd characters in a string.", "reference_code": "def remove_odd(str1):\n str2 = ''\n for i in range(1, len(str1) + 1):\n    if(i % 2 == 0):\n        str2 = str2 + str1[i - 1]\n return str2", "test_imports": [], "test_list": ["assert remove_odd(\"python\")==(\"yhn\")", "assert remove_odd(\"program\")==(\"rga\")", "assert remove_odd(\"language\")==(\"agae\")"], "model_name": "google/gemini-2.5-flash", "generated_code": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Removes characters at odd indices from a string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        A new string with characters at odd indices removed.\n    \"\"\"\n    return s[::2]"}
{"benchmark": "mbpp", "task_id": "441", "prompt": "Write a function to find the surface area of a cube of a given size.", "reference_code": "def surfacearea_cube(l):\n  surfacearea= 6*l*l\n  return surfacearea", "test_imports": [], "test_list": ["assert surfacearea_cube(5)==150", "assert surfacearea_cube(3)==54", "assert surfacearea_cube(10)==600"], "model_name": "google/gemini-2.5-flash", "generated_code": "def surfacearea_cube(side_length: float) -> float:\n    \"\"\"\n    Calculates the surface area of a cube given its side length.\n\n    Args:\n        side_length: The length of one side of the cube.\n\n    Returns:\n        The surface area of the cube.\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"Side length cannot be negative.\")\n    return 6 * (side_length ** 2)"}
{"benchmark": "mbpp", "task_id": "430", "prompt": "Write a function to find the directrix of a parabola.", "reference_code": "def parabola_directrix(a, b, c): \n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\n  return directrix", "test_imports": [], "test_list": ["assert parabola_directrix(5,3,2)==-198", "assert parabola_directrix(9,8,4)==-2336", "assert parabola_directrix(2,4,6)==-130"], "model_name": "google/gemini-2.5-flash", "generated_code": "def parabola_directrix(focus: tuple, vertex: tuple) -> str:\n    \"\"\"\n    Calculates the equation of the directrix of a parabola given its focus and vertex.\n\n    The equation of the directrix is returned as a string.\n\n    Args:\n        focus (tuple): A tuple (fx, fy) representing the coordinates of the focus.\n        vertex (tuple): A tuple (vx, vy) representing the coordinates of the vertex.\n\n    Returns:\n        str: The equation of the directrix in the form \"x = k\" or \"y = k\".\n\n    Examples:\n        >>> parabola_directrix((1, 2), (1, 0))\n        'y = -2'\n        >>> parabola_directrix((3, 4), (1, 4))\n        'x = -1'\n        >>> parabola_directrix((0, 0), (0, 2))\n        'y = 4'\n        >>> parabola_directrix((5, 5), (3, 5))\n        'x = 1'\n    \"\"\"\n    fx, fy = focus\n    vx, vy = vertex\n\n    # Calculate 'p', the distance from the vertex to the focus (and to the directrix)\n    # and determine the orientation of the parabola.\n\n    if fx == vx:  # Vertical parabola (opens up or down)\n        # The axis of symmetry is x = vx.\n        # The directrix is a horizontal line y = k.\n        # The distance 'p' is fy - vy.\n        p = fy - vy\n        # The directrix is at y = vy - p\n        directrix_y = vy - p\n        return f\"y = {directrix_y}\"\n    elif fy == vy:  # Horizontal parabola (opens left or right)\n        # The axis of symmetry is y = vy.\n        # The directrix is a vertical line x = k.\n        # The distance 'p' is fx - vx.\n        p = fx - vx\n        # The directrix is at x = vx - p\n        directrix_x = vx - p\n        return f\"x = {directrix_x}\"\n    else:\n        # This case implies the axis of symmetry is not parallel to x or y axis,\n        # which is not a standard parabola definition for this context.\n        # For a standard parabola, either x-coordinates or y-coordinates of focus and vertex must be the same.\n        raise ValueError(\"Focus and vertex do not form a standard parabola (axis parallel to x or y axis).\")"}
{"benchmark": "mbpp", "task_id": "442", "prompt": "Write a function to find the ration of positive numbers in an array of integers.", "reference_code": "from array import array\ndef positive_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "test_imports": [], "test_list": ["assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.54", "assert positive_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.69", "assert positive_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.56"], "model_name": "google/gemini-2.5-flash", "generated_code": "def positive_count(arr: list[int]) -> float:\n    \"\"\"\n    Calculates the ratio of positive numbers in an array of integers.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The ratio of positive numbers as a float. Returns 0.0 if the array is empty.\n    \"\"\"\n    if not arr:\n        return 0.0\n\n    positive_numbers = 0\n    for num in arr:\n        if num > 0:\n            positive_numbers += 1\n\n    return positive_numbers / len(arr)"}
{"benchmark": "mbpp", "task_id": "440", "prompt": "Write a function to find the first adverb and their positions in a given sentence.", "reference_code": "import re\ndef find_adverb_position(text):\n for m in re.finditer(r\"\\w+ly\", text):\n    return (m.start(), m.end(), m.group(0))", "test_imports": [], "test_list": ["assert find_adverb_position(\"clearly!! we can see the sky\")==(0, 7, 'clearly')", "assert find_adverb_position(\"seriously!! there are many roses\")==(0, 9, 'seriously')", "assert find_adverb_position(\"unfortunately!! sita is going to home\")==(0, 13, 'unfortunately')"], "model_name": "google/gemini-2.5-flash", "generated_code": "import spacy\n\ndef find_adverb_position(sentence: str) -> tuple[str, int]:\n    \"\"\"\n    Finds the first adverb and its starting position in a given sentence.\n\n    Args:\n        sentence: The input sentence string.\n\n    Returns:\n        A tuple containing:\n            - The first adverb found (str).\n            - The starting character position of the adverb in the sentence (int).\n        Returns an empty string and -1 if no adverb is found.\n    \"\"\"\n    try:\n        nlp = spacy.load(\"en_core_web_sm\")\n    except OSError:\n        spacy.cli.download(\"en_core_web_sm\")\n        nlp = spacy.load(\"en_core_web_sm\")\n\n    doc = nlp(sentence)\n\n    for token in doc:\n        if token.pos_ == \"ADV\":\n            return token.text, token.idx\n\n    return \"\", -1"}
{"benchmark": "mbpp", "task_id": "439", "prompt": "Write a function to join a list of multiple integers into a single integer.", "reference_code": "def multiple_to_single(L):\n  x = int(\"\".join(map(str, L)))\n  return x", "test_imports": [], "test_list": ["assert multiple_to_single([11, 33, 50])==113350", "assert multiple_to_single([-1,2,3,4,5,6])==-123456", "assert multiple_to_single([10,15,20,25])==10152025"], "model_name": "google/gemini-2.5-flash", "generated_code": "def multiple_to_single(numbers: list[int]) -> int:\n    \"\"\"\n    Joins a list of multiple integers into a single integer.\n\n    For example:\n    multiple_to_single([1, 2, 3]) == 123\n    multiple_to_single([10, 20, 30]) == 102030\n    multiple_to_single([]) == 0\n    multiple_to_single([5]) == 5\n    \"\"\"\n    if not numbers:\n        return 0\n\n    # Convert each integer to a string and then join them\n    string_numbers = [str(num) for num in numbers]\n    joined_string = \"\".join(string_numbers)\n\n    # Convert the joined string back to an integer\n    return int(joined_string)"}
{"benchmark": "mbpp", "task_id": "443", "prompt": "Write a python function to find the largest negative number from the given list.", "reference_code": "def largest_neg(list1): \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max", "test_imports": [], "test_list": ["assert largest_neg([1,2,3,-4,-6]) == -6", "assert largest_neg([1,2,3,-8,-9]) == -9", "assert largest_neg([1,2,3,4,-1]) == -1"], "model_name": "google/gemini-2.5-flash", "generated_code": "def largest_neg(numbers: list) -> int:\n    \"\"\"\n    Finds the largest negative number from the given list.\n\n    Args:\n        numbers: A list of integers.\n\n    Returns:\n        The largest negative number in the list.\n        If there are no negative numbers, it returns 0.\n    \"\"\"\n    largest_negative = 0\n    found_negative = False\n\n    for num in numbers:\n        if num < 0:\n            if not found_negative:\n                largest_negative = num\n                found_negative = True\n            elif num > largest_negative:\n                largest_negative = num\n    \n    return largest_negative"}
{"benchmark": "mbpp", "task_id": "445", "prompt": "Write a function to perform index wise multiplication of tuple elements in the given two tuples.", "reference_code": "def index_multiplication(test_tup1, test_tup2):\n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "test_imports": [], "test_list": ["assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))", "assert index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)) ) == ((14, 32), (20, 60), (6, 20), (16, 44))", "assert index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 77), (12, 33), (27, 60))"], "model_name": "google/gemini-2.5-flash", "generated_code": "def index_multiplication(tuple1, tuple2):\n    \"\"\"\n    Performs index-wise multiplication of elements from two tuples.\n\n    Args:\n        tuple1: The first tuple of numbers.\n        tuple2: The second tuple of numbers.\n\n    Returns:\n        A new tuple containing the products of corresponding elements.\n        If the tuples have different lengths, the resulting tuple will\n        have the length of the shorter tuple.\n    \"\"\"\n    result = []\n    min_len = min(len(tuple1), len(tuple2))\n\n    for i in range(min_len):\n        result.append(tuple1[i] * tuple2[i])\n\n    return tuple(result)"}
{"benchmark": "mbpp", "task_id": "446", "prompt": "Write a python function to count the occurence of all elements of list in a tuple.", "reference_code": "from collections import Counter \ndef count_Occurrence(tup, lst): \n    count = 0\n    for item in tup: \n        if item in lst: \n            count+= 1 \n    return count  ", "test_imports": [], "test_list": ["assert count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'] ) == 3", "assert count_Occurrence((1, 2, 3, 1, 4, 6, 7, 1, 4),[1, 4, 7]) == 6", "assert count_Occurrence((1,2,3,4,5,6),[1,2]) == 2"], "model_name": "google/gemini-2.5-flash", "generated_code": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the occurrence of each element from a list within a tuple.\n\n    Args:\n        tup: The tuple to search within.\n        lst: The list of elements to count.\n\n    Returns:\n        A dictionary where keys are elements from 'lst' and values are their\n        respective counts in 'tup'.\n    \"\"\"\n    counts = {}\n    for item_to_count in lst:\n        counts[item_to_count] = tup.count(item_to_count)\n    return counts"}
{"benchmark": "mbpp", "task_id": "444", "prompt": "Write a function to trim each tuple by k in the given tuple list.", "reference_code": "def trim_tuple(test_list, K):\n  res = []\n  for ele in test_list:\n    N = len(ele)\n    res.append(tuple(list(ele)[K: N - K]))\n  return (str(res)) ", "test_imports": [], "test_list": ["assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'", "assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'", "assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'"], "model_name": "google/gemini-2.5-flash", "generated_code": "def trim_tuple(tuple_list, k):\n    \"\"\"\n    Trims each tuple in a list of tuples to contain only the first k elements.\n\n    Args:\n        tuple_list: A list of tuples.\n        k: An integer representing the number of elements to keep from the beginning of each tuple.\n\n    Returns:\n        A new list of tuples, where each tuple has been trimmed to k elements.\n    \"\"\"\n    return [t[:k] for t in tuple_list]"}
{"benchmark": "mbpp", "task_id": "447", "prompt": "Write a function to find cubes of individual elements in a list.", "reference_code": "def cube_nums(nums):\n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums", "test_imports": [], "test_list": ["assert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]", "assert cube_nums([10,20,30])==([1000, 8000, 27000])", "assert cube_nums([12,15])==([1728, 3375])"], "model_name": "google/gemini-2.5-flash", "generated_code": "def cube_nums(nums: list[int]) -> list[int]:\n    \"\"\"\n    Finds the cubes of individual elements in a list of integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        A new list containing the cube of each element from the input list.\n    \"\"\"\n    return [num ** 3 for num in nums]"}
{"benchmark": "mbpp", "task_id": "451", "prompt": "Write a function to remove all whitespaces from the given string.", "reference_code": "import re\ndef remove_whitespaces(text1):\n  return (re.sub(r'\\s+', '',text1))", "test_imports": [], "test_list": ["assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'", "assert remove_whitespaces(' Google    Dart ') == 'GoogleDart'", "assert remove_whitespaces(' iOS    Swift ') == 'iOSSwift'"], "model_name": "google/gemini-2.5-flash", "generated_code": "def remove_whitespaces(text: str) -> str:\n    \"\"\"\n    Removes all whitespace characters from the given string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A new string with all whitespace characters removed.\n    \"\"\"\n    return text.replace(\" \", \"\").replace(\"\\t\", \"\").replace(\"\\n\", \"\").replace(\"\\r\", \"\").replace(\"\\f\", \"\").replace(\"\\v\", \"\")"}
{"benchmark": "mbpp", "task_id": "450", "prompt": "Write a function to extract specified size of strings from a given list of string values.", "reference_code": "def extract_string(str, l):\n    result = [e for e in str if len(e) == l] \n    return result", "test_imports": [], "test_list": ["assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,8)==['practice', 'solution']", "assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,6)==['Python']", "assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,9)==['exercises']"], "model_name": "google/gemini-2.5-flash", "generated_code": "def extract_string(str_list, size):\n    \"\"\"\n    Extracts strings of a specified size from a given list of string values.\n\n    Args:\n        str_list: A list of strings.\n        size: An integer representing the desired length of strings to extract.\n\n    Returns:\n        A new list containing only the strings from str_list that have the specified size.\n    \"\"\"\n    return [s for s in str_list if len(s) == size]"}
{"benchmark": "mbpp", "task_id": "452", "prompt": "Write a function that gives loss amount on a sale if the given amount has loss else return 0.", "reference_code": "def loss_amount(actual_cost,sale_amount): \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return 0", "test_imports": [], "test_list": ["assert loss_amount(1500,1200)==0", "assert loss_amount(100,200)==100", "assert loss_amount(2000,5000)==3000"], "model_name": "google/gemini-2.5-flash", "generated_code": "def loss_amount(sale_price, cost_price):\n  \"\"\"\n  Calculates the loss amount on a sale.\n\n  Args:\n    sale_price: The selling price of the item.\n    cost_price: The original cost price of the item.\n\n  Returns:\n    The loss amount if sale_price is less than cost_price, otherwise 0.\n  \"\"\"\n  if sale_price < cost_price:\n    return cost_price - sale_price\n  else:\n    return 0"}
{"benchmark": "mbpp", "task_id": "448", "prompt": "Write a function to calculate the sum of perrin numbers.", "reference_code": "def cal_sum(n): \n\ta = 3\n\tb = 0\n\tc = 2\n\tif (n == 0): \n\t\treturn 3\n\tif (n == 1): \n\t\treturn 3\n\tif (n == 2): \n\t\treturn 5\n\tsum = 5\n\twhile (n > 2): \n\t\td = a + b \n\t\tsum = sum + d \n\t\ta = b \n\t\tb = c \n\t\tc = d \n\t\tn = n-1\n\treturn sum", "test_imports": [], "test_list": ["assert cal_sum(9) == 49", "assert cal_sum(10) == 66", "assert cal_sum(11) == 88"], "model_name": "google/gemini-2.5-flash", "generated_code": "def cal_sum(n: int) -> int:\n    \"\"\"\n    Calculates the sum of the first n Perrin numbers.\n\n    The Perrin sequence is defined as:\n    P(0) = 3\n    P(1) = 0\n    P(2) = 2\n    P(n) = P(n-2) + P(n-3) for n > 2\n\n    Args:\n        n: The number of Perrin numbers to sum (non-negative integer).\n\n    Returns:\n        The sum of the first n Perrin numbers.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if n == 0:\n        return 0\n    if n == 1:\n        return 3\n    if n == 2:\n        return 3  # P(0) + P(1) = 3 + 0 = 3\n    if n == 3:\n        return 5  # P(0) + P(1) + P(2) = 3 + 0 + 2 = 5\n\n    # Initialize the first three Perrin numbers\n    p0, p1, p2 = 3, 0, 2\n    current_sum = p0 + p1 + p2\n\n    # Calculate subsequent Perrin numbers and add to the sum\n    for i in range(3, n):\n        p_next = p0 + p1\n        current_sum += p_next\n        p0, p1, p2 = p1, p2, p_next\n\n    return current_sum"}
{"benchmark": "mbpp", "task_id": "453", "prompt": "Write a python function to find the sum of even factors of a number.", "reference_code": "import math \ndef sumofFactors(n) : \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res", "test_imports": [], "test_list": ["assert sumofFactors(18) == 26", "assert sumofFactors(30) == 48", "assert sumofFactors(6) == 8"], "model_name": "google/gemini-2.5-flash", "generated_code": "def sumofFactors(n: int) -> int:\n    \"\"\"\n    Finds the sum of even factors of a number.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        The sum of even factors of n.\n    \"\"\"\n    if n <= 0:\n        return 0\n\n    total_sum = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # i is a factor\n            if i % 2 == 0:\n                total_sum += i\n\n            # n // i is also a factor\n            if (n // i) != i:  # Avoid double counting for perfect squares\n                if (n // i) % 2 == 0:\n                    total_sum += (n // i)\n    return total_sum"}
{"benchmark": "mbpp", "task_id": "454", "prompt": "Write a function that matches a word containing 'z'.", "reference_code": "import re\ndef text_match_wordz(text):\n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False", "test_imports": [], "test_list": ["assert text_match_wordz(\"pythonz.\")==True", "assert text_match_wordz(\"xyz.\")==True", "assert text_match_wordz(\"  lang  .\")==False"], "model_name": "google/gemini-2.5-flash", "generated_code": "import re\n\ndef text_match_wordz(text):\n    \"\"\"\n    Matches a word containing 'z'.\n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        re.Match or None: A match object if a word containing 'z' is found, otherwise None.\n    \"\"\"\n    pattern = r'\\b\\w*z\\w*\\b'\n    return re.search(pattern, text)"}
{"benchmark": "mbpp", "task_id": "438", "prompt": "Write a function to count bidirectional tuple pairs.", "reference_code": "def count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return res", "test_imports": [], "test_list": ["assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 3", "assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 2", "assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == 4"], "model_name": "google/gemini-2.5-flash", "generated_code": "def count_bidirectional(tuples):\n    \"\"\"\n    Counts the number of bidirectional tuple pairs in a list of tuples.\n    A pair (a, b) is bidirectional if (b, a) also exists in the list.\n\n    Args:\n        tuples: A list of tuples.\n\n    Returns:\n        The number of bidirectional tuple pairs.\n    \"\"\"\n    if not tuples:\n        return 0\n\n    # Use a set for efficient lookup of existing tuples\n    tuple_set = set(tuples)\n    count = 0\n\n    for t in tuples:\n        # Ensure the tuple has exactly two elements\n        if len(t) != 2:\n            continue\n\n        a, b = t\n        # Check if the reverse tuple exists and if the original tuple is not a self-pair (a, a)\n        # We also need to ensure we don't double count (a, b) and (b, a) as separate bidirectional pairs.\n        # By only counting if a < b, we ensure each unique bidirectional pair is counted exactly once.\n        if (b, a) in tuple_set and a < b:\n            count += 1\n        # If a == b, it's a self-pair. We count it if it exists, but it doesn't have a distinct reverse.\n        # The problem statement implies (a,b) and (b,a) are distinct for bidirectionality.\n        # If (a,a) is considered bidirectional with itself, then the condition (b,a) in tuple_set\n        # already covers it. However, the example (1,2) and (2,1) suggests distinct elements.\n        # Let's stick to the interpretation that (a,b) and (b,a) must be distinct for a pair.\n        # If (a,a) is in the list, it's not a \"pair\" in the sense of (a,b) and (b,a) where a!=b.\n        # The example (1,2) and (2,1) implies a != b for a \"pair\".\n        # If (1,1) is in the list, and we are looking for (1,1), it's found.\n        # But it's not a \"bidirectional pair\" in the sense of (a,b) and (b,a) where a!=b.\n        # The problem statement is a bit ambiguous for (a,a) cases.\n        # Given \"bidirectional tuple pairs\", it usually implies (a,b) and (b,a) where a != b.\n        # If (a,a) is present, (a,a) is also present. This would be counted if we just did (b,a) in tuple_set.\n        # To avoid double counting (a,b) and (b,a) when a != b, we use a < b.\n        # For (a,a), a < b is false. So (a,a) will not be counted by this logic.\n        # This seems to align with the spirit of \"bidirectional pairs\" where the elements are swapped.\n\n    return count"}
{"benchmark": "mbpp", "task_id": "455", "prompt": "Write a function to check whether the given month number contains 31 days or not.", "reference_code": "def check_monthnumb_number(monthnum2):\n  if(monthnum2==1 or monthnum2==3 or monthnum2==5 or monthnum2==7 or monthnum2==8 or monthnum2==10 or monthnum2==12):\n    return True\n  else:\n    return False", "test_imports": [], "test_list": ["assert check_monthnumb_number(5)==True", "assert check_monthnumb_number(2)==False", "assert check_monthnumb_number(6)==False"], "model_name": "google/gemini-2.5-flash", "generated_code": "def check_monthnumb_number(month_number: int) -> bool:\n    \"\"\"\n    Checks whether the given month number contains 31 days or not.\n\n    Args:\n        month_number: An integer representing the month (1 for January, 12 for December).\n\n    Returns:\n        True if the month has 31 days, False otherwise.\n    \"\"\"\n    if month_number in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    else:\n        return False"}
{"benchmark": "mbpp", "task_id": "456", "prompt": "Write a function to reverse each string in a given list of string values.", "reference_code": "def reverse_string_list(stringlist):\n    result = [x[::-1] for x in stringlist]\n    return result", "test_imports": [], "test_list": ["assert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])==['deR', 'neerG', 'eulB', 'etihW', 'kcalB']", "assert reverse_string_list(['john','amal','joel','george'])==['nhoj','lama','leoj','egroeg']", "assert reverse_string_list(['jack','john','mary'])==['kcaj','nhoj','yram']"], "model_name": "google/gemini-2.5-flash", "generated_code": "def reverse_string_list(string_list: list[str]) -> list[str]:\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A new list where each string from the input list is reversed.\n    \"\"\"\n    reversed_list = []\n    for s in string_list:\n        reversed_list.append(s[::-1])\n    return reversed_list"}
{"benchmark": "mbpp", "task_id": "458", "prompt": "Write a function to find the area of a rectangle.", "reference_code": "def rectangle_area(l,b):\n  area=l*b\n  return area", "test_imports": [], "test_list": ["assert rectangle_area(10,20)==200", "assert rectangle_area(10,5)==50", "assert rectangle_area(4,2)==8"], "model_name": "google/gemini-2.5-flash", "generated_code": "def rectangle_area(length: float, width: float) -> float:\n    \"\"\"\n    Calculates the area of a rectangle given its length and width.\n\n    Args:\n        length: The length of the rectangle.\n        width: The width of the rectangle.\n\n    Returns:\n        The area of the rectangle.\n    \"\"\"\n    return length * width"}
{"benchmark": "mbpp", "task_id": "457", "prompt": "Write a python function to find the sublist having minimum length.", "reference_code": "def Find_Min(lst): \n    return min(lst, key=len) ", "test_imports": [], "test_list": ["assert Find_Min([[1],[1,2],[1,2,3]]) == [1]", "assert Find_Min([[1,1],[1,1,1],[1,2,7,8]]) == [1,1]", "assert Find_Min([['x'],['x','y'],['x','y','z']]) == ['x']"], "model_name": "google/gemini-2.5-flash", "generated_code": "def Find_Min(input_list):\n    \"\"\"\n    Finds the sublist with the minimum length from a list of lists.\n\n    Args:\n        input_list: A list of lists. Each inner list can contain any type of elements.\n\n    Returns:\n        The sublist with the minimum length. If input_list is empty, returns None.\n        If there are multiple sublists with the same minimum length, the first one encountered is returned.\n    \"\"\"\n    if not input_list:\n        return None\n\n    min_length = float('inf')\n    min_sublist = None\n\n    for sublist in input_list:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n    \n    return min_sublist"}
{"benchmark": "mbpp", "task_id": "460", "prompt": "Write a python function to get the first element of each sublist.", "reference_code": "def Extract(lst): \n    return [item[0] for item in lst] ", "test_imports": [], "test_list": ["assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]", "assert Extract([[1,2,3],[4, 5]]) == [1,4]", "assert Extract([[9,8,1],[1,2]]) == [9,1]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist in a given list.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A list containing the first element of each sublist.\n    \"\"\"\n    return [item[0] for item in lst]"}
{"benchmark": "mbpp", "task_id": "461", "prompt": "Write a python function to count the upper case characters in a given string.", "reference_code": "def upper_ctr(str):\n    upper_ctr = 0\n    for i in range(len(str)):\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\n          return upper_ctr", "test_imports": [], "test_list": ["assert upper_ctr('PYthon') == 1", "assert upper_ctr('BigData') == 1", "assert upper_ctr('program') == 0"], "model_name": "google/gemini-2.5-flash", "generated_code": "def upper_ctr(input_string):\n    \"\"\"\n    Counts the number of uppercase characters in a given string.\n\n    Args:\n        input_string: The string to analyze.\n\n    Returns:\n        The count of uppercase characters.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if 'A' <= char <= 'Z':  # Check if the character is an uppercase letter\n            count += 1\n    return count"}
{"benchmark": "mbpp", "task_id": "462", "prompt": "Write a function to find all possible combinations of the elements of a given list.", "reference_code": "def combinations_list(list1):\n    if len(list1) == 0:\n        return [[]]\n    result = []\n    for el in combinations_list(list1[1:]):\n        result += [el, el+[list1[0]]]\n    return result", "test_imports": [], "test_list": ["assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]", "assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]", "assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]"], "model_name": "google/gemini-2.5-flash", "generated_code": "def combinations_list(elements):\n    \"\"\"\n    Finds all possible combinations of the elements of a given list.\n\n    Args:\n        elements: A list of elements.\n\n    Returns:\n        A list of lists, where each inner list is a combination of the elements.\n        The order of combinations and elements within combinations is not guaranteed.\n    \"\"\"\n    if not elements:\n        return [[]]\n\n    all_combinations = []\n    for i in range(1 << len(elements)):\n        combination = []\n        for j in range(len(elements)):\n            if (i >> j) & 1:\n                combination.append(elements[j])\n        all_combinations.append(combination)\n\n    return all_combinations"}
{"benchmark": "mbpp", "task_id": "464", "prompt": "Write a function to check if all values are same in a dictionary.", "reference_code": "def check_value(dict, n):\n    result = all(x == n for x in dict.values()) \n    return result", "test_imports": [], "test_list": ["assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)==False", "assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)==True", "assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)==False"], "model_name": "google/gemini-2.5-flash", "generated_code": "def check_value(dictionary: dict) -> bool:\n    \"\"\"\n    Checks if all values in a dictionary are the same.\n\n    Args:\n        dictionary: The input dictionary.\n\n    Returns:\n        True if all values are the same, False otherwise.\n        Returns True for an empty dictionary.\n    \"\"\"\n    if not dictionary:\n        return True\n\n    # Get the first value in the dictionary\n    first_value = next(iter(dictionary.values()))\n\n    # Check if all other values are equal to the first value\n    for value in dictionary.values():\n        if value != first_value:\n            return False\n    return True"}
{"benchmark": "mbpp", "task_id": "465", "prompt": "Write a function to drop empty items from a given dictionary.", "reference_code": "def drop_empty(dict1):\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1", "test_imports": [], "test_list": ["assert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3':None})=={'c1': 'Red', 'c2': 'Green'}", "assert drop_empty({'c1': 'Red', 'c2': None, 'c3':None})=={'c1': 'Red'}", "assert drop_empty({'c1': None, 'c2': 'Green', 'c3':None})=={ 'c2': 'Green'}"], "model_name": "google/gemini-2.5-flash", "generated_code": "def drop_empty(d: dict) -> dict:\n    \"\"\"\n    Drops empty items (None, empty string, empty list, empty dict) from a dictionary.\n\n    Args:\n        d: The input dictionary.\n\n    Returns:\n        A new dictionary with empty items removed.\n    \"\"\"\n    if not isinstance(d, dict):\n        raise TypeError(\"Input must be a dictionary.\")\n\n    return {k: v for k, v in d.items() if v is not None and v != '' and v != [] and v != {}}"}
{"benchmark": "mbpp", "task_id": "463", "prompt": "Write a function to find the maximum product subarray of the given array.", "reference_code": "def max_subarray_product(arr):\n\tn = len(arr)\n\tmax_ending_here = 1\n\tmin_ending_here = 1\n\tmax_so_far = 0\n\tflag = 0\n\tfor i in range(0, n):\n\t\tif arr[i] > 0:\n\t\t\tmax_ending_here = max_ending_here * arr[i]\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\n\t\t\tflag = 1\n\t\telif arr[i] == 0:\n\t\t\tmax_ending_here = 1\n\t\t\tmin_ending_here = 1\n\t\telse:\n\t\t\ttemp = max_ending_here\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\n\t\t\tmin_ending_here = temp * arr[i]\n\t\tif (max_so_far < max_ending_here):\n\t\t\tmax_so_far = max_ending_here\n\tif flag == 0 and max_so_far == 0:\n\t\treturn 0\n\treturn max_so_far", "test_imports": [], "test_list": ["assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112", "assert max_subarray_product([6, -3, -10, 0, 2]) == 180", "assert max_subarray_product([-2, -40, 0, -2, -3]) == 80"], "model_name": "google/gemini-2.5-flash", "generated_code": "from typing import List\n\ndef max_subarray_product(nums: List[int]) -> int:\n    \"\"\"\n    Finds the maximum product subarray of the given array.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The maximum product of any subarray.\n    \"\"\"\n    if not nums:\n        return 0\n\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    result = nums[0]\n\n    for i in range(1, len(nums)):\n        curr = nums[i]\n        # If current number is negative, swap max_so_far and min_so_far\n        # because multiplying by a negative number will flip their roles\n        # (e.g., min * neg becomes max, max * neg becomes min)\n        if curr < 0:\n            max_so_far, min_so_far = min_so_far, max_so_far\n\n        max_so_far = max(curr, max_so_far * curr)\n        min_so_far = min(curr, min_so_far * curr)\n\n        result = max(result, max_so_far)\n\n    return result"}
{"benchmark": "mbpp", "task_id": "471", "prompt": "Write a python function to find the product of the array multiplication modulo n.", "reference_code": "def find_remainder(arr, n): \n    mul = 1\n    for i in range(len(arr)):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n ", "test_imports": [], "test_list": ["assert find_remainder([ 100, 10, 5, 25, 35, 14 ],11) ==9", "assert find_remainder([1,1,1],1) == 0", "assert find_remainder([1,2,1],2) == 0"], "model_name": "google/gemini-2.5-flash", "generated_code": "def find_remainder(arr, n):\n    \"\"\"\n    Finds the product of the array multiplication modulo n.\n\n    Args:\n        arr: A list of integers.\n        n: An integer, the modulo value.\n\n    Returns:\n        The product of all elements in arr modulo n.\n    \"\"\"\n    product = 1\n    for num in arr:\n        product = (product * num) % n\n    return product"}
{"benchmark": "mbpp", "task_id": "470", "prompt": "Write a function to find the pairwise addition of the neighboring elements of the given tuple.", "reference_code": "def add_pairwise(test_tup):\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) ", "test_imports": [], "test_list": ["assert add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)", "assert add_pairwise((2, 6, 8, 9, 11)) == (8, 14, 17, 20)", "assert add_pairwise((3, 7, 9, 10, 12)) == (10, 16, 19, 22)"], "model_name": "google/gemini-2.5-flash", "generated_code": "def add_pairwise(numbers: tuple) -> tuple:\n    \"\"\"\n    Finds the pairwise addition of the neighboring elements of the given tuple.\n\n    Args:\n        numbers: A tuple of numbers.\n\n    Returns:\n        A new tuple where each element is the sum of two neighboring elements\n        from the input tuple. If the input tuple has an odd number of elements,\n        the last element is added to itself.\n    \"\"\"\n    if not numbers:\n        return ()\n\n    result = []\n    n = len(numbers)\n\n    for i in range(0, n, 2):\n        if i + 1 < n:\n            result.append(numbers[i] + numbers[i + 1])\n        else:\n            # If there's an odd number of elements, add the last element to itself\n            result.append(numbers[i] + numbers[i])\n            \n    return tuple(result)"}
{"benchmark": "mbpp", "task_id": "472", "prompt": "Write a python function to check whether the given list contains consecutive numbers or not.", "reference_code": "def check_Consecutive(l): \n    return sorted(l) == list(range(min(l),max(l)+1)) ", "test_imports": [], "test_list": ["assert check_Consecutive([1,2,3,4,5]) == True", "assert check_Consecutive([1,2,3,5,6]) == False", "assert check_Consecutive([1,2,1]) == False"], "model_name": "google/gemini-2.5-flash", "generated_code": "def check_Consecutive(l):\n    \"\"\"\n    Checks if the given list contains consecutive numbers.\n\n    Args:\n        l: A list of numbers.\n\n    Returns:\n        True if the list contains consecutive numbers, False otherwise.\n        Returns True for an empty list or a list with a single element.\n    \"\"\"\n    if not l or len(l) == 1:\n        return True\n\n    # Sort the list to easily check for consecutive numbers\n    l.sort()\n\n    # Iterate through the sorted list and check if the difference between\n    # adjacent elements is 1.\n    for i in range(len(l) - 1):\n        if l[i+1] - l[i] != 1:\n            return False\n    return True"}
{"benchmark": "mbpp", "task_id": "474", "prompt": "Write a function to replace characters in a string.", "reference_code": "def replace_char(str1,ch,newch):\n str2 = str1.replace(ch, newch)\n return str2", "test_imports": [], "test_list": ["assert replace_char(\"polygon\",'y','l')==(\"pollgon\")", "assert replace_char(\"character\",'c','a')==(\"aharaater\")", "assert replace_char(\"python\",'l','a')==(\"python\")"], "model_name": "google/gemini-2.5-flash", "generated_code": "def replace_char(s: str, old_char: str, new_char: str) -> str:\n    \"\"\"\n    Replaces all occurrences of a specified character with another character in a string.\n\n    Args:\n        s: The input string.\n        old_char: The character to be replaced.\n        new_char: The character to replace with.\n\n    Returns:\n        A new string with all occurrences of old_char replaced by new_char.\n    \"\"\"\n    return s.replace(old_char, new_char)"}
{"benchmark": "mbpp", "task_id": "473", "prompt": "Write a function to find the tuple intersection of elements in the given tuple list irrespective of their order.", "reference_code": "def tuple_intersection(test_list1, test_list2):\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\n  return (res)", "test_imports": [], "test_list": ["assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}", "assert tuple_intersection([(4, 1), (7, 4), (11, 13), (17, 14)] , [(1, 4), (7, 4), (16, 12), (10, 13)]) == {(4, 7), (1, 4)}", "assert tuple_intersection([(2, 1), (3, 2), (1, 3), (1, 4)] , [(11, 2), (2, 3), (6, 2), (1, 3)]) == {(1, 3), (2, 3)}"], "model_name": "google/gemini-2.5-flash", "generated_code": "def tuple_intersection(tuple_list):\n    \"\"\"\n    Finds the intersection of elements in a list of tuples, irrespective of their order.\n\n    Args:\n        tuple_list: A list of tuples.\n\n    Returns:\n        A tuple containing the common elements across all tuples in the input list.\n        The order of elements in the output tuple is not guaranteed.\n        If the input list is empty, an empty tuple is returned.\n        If there are no common elements, an empty tuple is returned.\n    \"\"\"\n    if not tuple_list:\n        return ()\n\n    # Convert the first tuple to a set for efficient intersection operations\n    intersection_set = set(tuple_list[0])\n\n    # Iterate through the rest of the tuples and find the intersection\n    for i in range(1, len(tuple_list)):\n        intersection_set.intersection_update(set(tuple_list[i]))\n\n    return tuple(intersection_set)"}
{"benchmark": "mbpp", "task_id": "476", "prompt": "Write a python function to find the sum of the largest and smallest value in a given array.", "reference_code": "def big_sum(nums):\n      sum= max(nums)+min(nums)\n      return sum", "test_imports": [], "test_list": ["assert big_sum([1,2,3]) == 4", "assert big_sum([-1,2,3,4]) == 3", "assert big_sum([2,3,6]) == 8"], "model_name": "google/gemini-2.5-flash", "generated_code": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest value in a given array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest value in the array.\n        Returns 0 if the array is empty.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    smallest = arr[0]\n    largest = arr[0]\n\n    for num in arr:\n        if num < smallest:\n            smallest = num\n        if num > largest:\n            largest = num\n            \n    return smallest + largest"}
{"benchmark": "mbpp", "task_id": "477", "prompt": "Write a python function to convert the given string to lower case.", "reference_code": "def is_lower(string):\n  return (string.lower())", "test_imports": [], "test_list": ["assert is_lower(\"InValid\") == \"invalid\"", "assert is_lower(\"TruE\") == \"true\"", "assert is_lower(\"SenTenCE\") == \"sentence\""], "model_name": "google/gemini-2.5-flash", "generated_code": "def is_lower(s: str) -> str:\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The lowercased version of the input string.\n    \"\"\"\n    return s.lower()"}
{"benchmark": "mbpp", "task_id": "475", "prompt": "Write a function to sort a dictionary by value.", "reference_code": "from collections import Counter\ndef sort_counter(dict1):\n x = Counter(dict1)\n sort_counter=x.most_common()\n return sort_counter", "test_imports": [], "test_list": ["assert sort_counter({'Math':81, 'Physics':83, 'Chemistry':87})==[('Chemistry', 87), ('Physics', 83), ('Math', 81)]", "assert sort_counter({'Math':400, 'Physics':300, 'Chemistry':250})==[('Math', 400), ('Physics', 300), ('Chemistry', 250)]", "assert sort_counter({'Math':900, 'Physics':1000, 'Chemistry':1250})==[('Chemistry', 1250), ('Physics', 1000), ('Math', 900)]"], "model_name": "google/gemini-2.5-flash", "generated_code": "from collections import Counter\n\ndef sort_counter(counter: Counter) -> Counter:\n    \"\"\"\n    Sorts a Counter object by its values in descending order.\n    If values are equal, sorts by keys in ascending order.\n\n    Args:\n        counter: The Counter object to sort.\n\n    Returns:\n        A new Counter object with items sorted by value (descending)\n        then by key (ascending).\n    \"\"\"\n    # Sort items by value in descending order, then by key in ascending order\n    sorted_items = sorted(counter.items(), key=lambda item: (-item[1], item[0]))\n    \n    # Create a new Counter from the sorted items to maintain order\n    # A Counter object inherently doesn't guarantee order, but when initialized\n    # from an ordered sequence, it will retain that order in Python 3.7+\n    # For older versions, or strict ordering, an OrderedDict would be more explicit,\n    # but the problem asks for a Counter return type.\n    return Counter(dict(sorted_items))"}
{"benchmark": "mbpp", "task_id": "468", "prompt": "Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.", "reference_code": "def max_product(arr):   \n  n = len(arr)\n  mpis = arr[:]\n  for i in range(n): \n    current_prod = arr[i]\n    j = i + 1\n    while j < n:\n      if arr[j-1] > arr[j]: \n        break\n      current_prod *= arr[j]\n      if current_prod > mpis[j]:\n        mpis[j] = current_prod \n      j = j + 1\n  return max(mpis)", "test_imports": [], "test_list": ["assert max_product([3, 100, 4, 5, 150, 6]) == 3000", "assert max_product([4, 42, 55, 68, 80]) == 50265600", "assert max_product([10, 22, 9, 33, 21, 50, 41, 60]) == 2460"], "model_name": "google/gemini-2.5-flash", "generated_code": "def max_product(arr: list[int]) -> int:\n    \"\"\"\n    Finds the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The maximum product of an increasing subsequence. Returns 0 if the array is empty.\n        If all numbers are negative, it returns the maximum single negative number.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n\n    # dp[i] stores the maximum product of an increasing subsequence ending at index i\n    dp = [num for num in arr]\n\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                # If arr[i] is positive, multiplying it with dp[j] will increase the product.\n                # If arr[i] is negative, multiplying it with a negative dp[j] could also increase the product.\n                # However, the problem asks for an increasing subsequence.\n                # If arr[i] is positive, we can extend the subsequence ending at j.\n                # If arr[i] is negative, and arr[j] is also negative, and arr[i] > arr[j],\n                # then arr[i] * dp[j] could be a larger positive product.\n                # But the subsequence must be increasing.\n                # Example: [-5, -4, -3].\n                # dp[0] = -5\n                # dp[1] = max(-4, -4 * -5) = max(-4, 20) = 20 (subsequence: -5, -4)\n                # dp[2] = max(-3, -3 * -5, -3 * -4) = max(-3, 15, 12) = 15 (subsequence: -5, -3)\n                # This logic is correct.\n                dp[i] = max(dp[i], dp[j] * arr[i])\n\n    # The maximum product could be a single element if all products are smaller.\n    # For example, if arr = [-1, -2, -3], the increasing subsequences are [-1], [-2], [-3].\n    # The max product is -1.\n    # If arr = [-5, -4, -3], dp will be [-5, 20, 15]. The max is 20.\n    # If arr = [1, 2, 3], dp will be [1, 2, 6]. The max is 6.\n    return max(dp)"}
{"benchmark": "mbpp", "task_id": "479", "prompt": "Write a python function to find the first digit of a given number.", "reference_code": "def first_Digit(n) :  \n    while n >= 10:  \n        n = n / 10 \n    return int(n) ", "test_imports": [], "test_list": ["assert first_Digit(123) == 1", "assert first_Digit(456) == 4", "assert first_Digit(12) == 1"], "model_name": "google/gemini-2.5-flash", "generated_code": "def first_Digit(num: int) -> int:\n    \"\"\"\n    Finds the first digit of a given integer.\n\n    Args:\n        num: The input integer.\n\n    Returns:\n        The first digit of the number.\n    \"\"\"\n    num_str = str(abs(num))  # Convert to string to easily access digits, handle negative numbers\n    return int(num_str[0])"}
{"benchmark": "mbpp", "task_id": "478", "prompt": "Write a function to remove lowercase substrings from a given string.", "reference_code": "import re\ndef remove_lowercase(str1):\n return re.sub('[a-z]', '', str1)", "test_imports": [], "test_list": ["assert remove_lowercase(\"PYTHon\")==('PYTH')", "assert remove_lowercase(\"FInD\")==('FID')", "assert remove_lowercase(\"STRinG\")==('STRG')"], "model_name": "google/gemini-2.5-flash", "generated_code": "def remove_lowercase(input_string: str) -> str:\n    \"\"\"\n    Removes all lowercase substrings from the input string.\n    A lowercase substring is defined as a contiguous sequence of lowercase letters.\n    Other characters (uppercase letters, numbers, symbols, spaces) are preserved.\n\n    Args:\n        input_string: The string from which to remove lowercase substrings.\n\n    Returns:\n        The string with all lowercase substrings removed.\n    \"\"\"\n    result = []\n    in_lowercase_sequence = False\n\n    for char in input_string:\n        if 'a' <= char <= 'z':\n            # We are in or entering a lowercase sequence, so skip this character\n            in_lowercase_sequence = True\n        else:\n            # This character is not lowercase\n            if in_lowercase_sequence:\n                # We just exited a lowercase sequence, reset the flag\n                in_lowercase_sequence = False\n            # Add the non-lowercase character to the result\n            result.append(char)\n\n    return \"\".join(result)"}
{"benchmark": "mbpp", "task_id": "459", "prompt": "Write a function to remove uppercase substrings from a given string.", "reference_code": "import re\ndef remove_uppercase(str1):\n  return re.sub('[A-Z]', '', str1)", "test_imports": [], "test_list": ["assert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'", "assert remove_uppercase('wAtchTheinTernEtrAdIo') == 'wtchheinerntrdo'", "assert remove_uppercase('VoicESeaRchAndreComMendaTionS') == 'oiceachndreomendaion'"], "model_name": "google/gemini-2.5-flash", "generated_code": "def remove_uppercase(input_string: str) -> str:\n    \"\"\"\n    Removes uppercase substrings from a given string.\n\n    A substring is considered uppercase if all its alphabetic characters are uppercase.\n    Non-alphabetic characters within such a substring are also removed.\n\n    Examples:\n    remove_uppercase(\"Hello World\") == \"ello orld\"\n    remove_uppercase(\"PYTHON is FUN\") == \" is \"\n    remove_uppercase(\"123abcABC456\") == \"123abc456\"\n    remove_uppercase(\"No_UPPER_Case_Here\") == \"No_Case_Here\"\n    remove_uppercase(\"ALLCAPS\") == \"\"\n    remove_uppercase(\"no_caps\") == \"no_caps\"\n    remove_uppercase(\"\") == \"\"\n    remove_uppercase(\"A\") == \"\"\n    remove_uppercase(\"a\") == \"a\"\n    \"\"\"\n    if not input_string:\n        return \"\"\n\n    result = []\n    current_substring_start = 0\n    n = len(input_string)\n\n    while current_substring_start < n:\n        if input_string[current_substring_start].isupper():\n            # Found the start of a potential uppercase substring\n            substring_end = current_substring_start\n            is_all_uppercase_segment = True\n            has_alpha = False\n\n            # Find the end of the current segment (alphabetic or non-alphabetic)\n            while substring_end < n:\n                char = input_string[substring_end]\n                if char.isalpha():\n                    has_alpha = True\n                    if not char.isupper():\n                        is_all_uppercase_segment = False\n                        break\n                # If it's not an alpha char, it's part of the segment\n                # but doesn't break the 'all uppercase' rule yet.\n                substring_end += 1\n            \n            # Now, check if the segment from current_substring_start to substring_end-1\n            # (or n if it went to the end) is truly an uppercase substring.\n            # An uppercase substring is defined as having all its alphabetic characters uppercase.\n            # We need to find the actual end of the \"word\" or \"segment\" that started uppercase.\n            \n            # Let's re-evaluate the logic. The problem states \"uppercase substrings\".\n            # This implies contiguous sequences of characters where all *alphabetic* characters are uppercase.\n            # Non-alphabetic characters within such a sequence are also removed.\n\n            # A simpler approach might be to iterate and build the string,\n            # identifying uppercase \"words\" as we go.\n\n            # Let's try a state-based approach or a split-and-check approach.\n            # The example \"No_UPPER_Case_Here\" -> \"No_Case_Here\" suggests that\n            # \"UPPER\" is removed, but \"_\" are not if they are not part of an uppercase block.\n            # This implies that non-alphabetic characters act as delimiters or are removed\n            # if they are *within* an uppercase block.\n\n            # Let's re-read: \"A substring is considered uppercase if all its alphabetic characters are uppercase.\n            # Non-alphabetic characters within such a substring are also removed.\"\n\n            # This means we need to find a contiguous block.\n            # Example: \"PYTHON is FUN\" -> \" is \"\n            # \"PYTHON\" is an uppercase substring. \"is\" is not. \"FUN\" is an uppercase substring.\n\n            # Let's iterate through the string, identifying blocks of characters.\n            # A block ends when we encounter a character that breaks the current block's \"all uppercase\" status.\n\n            i = current_substring_start\n            while i < n:\n                if input_string[i].isalpha() and input_string[i].islower():\n                    # Found a lowercase letter, this block is not all uppercase.\n                    # Append everything from current_substring_start up to i-1\n                    # (if it wasn't already part of an uppercase block)\n                    # and then append the current char.\n                    result.append(input_string[current_substring_start:i+1])\n                    current_substring_start = i + 1\n                    break\n                elif i == n - 1:\n                    # Reached the end of the string. Check if the block from current_substring_start to n-1\n                    # is an uppercase substring.\n                    segment = input_string[current_substring_start:n]\n                    if any(c.isalpha() and c.islower() for c in segment):\n                        result.append(segment)\n                    # If it's all uppercase or contains no alpha, it's removed.\n                    current_substring_start = n\n                    break\n                i += 1\n            else: # Loop finished without a 'break', meaning the whole remaining string is potentially uppercase\n                segment = input_string[current_substring_start:n]\n                if any(c.isalpha() and c.islower() for c in segment):\n                    result.append(segment)\n                current_substring_start = n # Processed the rest of the string\n        else:\n            # Current character is lowercase or non-alphabetic.\n            # It's part of a non-uppercase block.\n            i = current_substring_start\n            while i < n:\n                if input_string[i].isupper():\n                    # Found an uppercase letter, this non-uppercase block ends here.\n                    result.append(input_string[current_substring_start:i])\n                    current_substring_start = i\n                    break\n                elif i == n - 1:\n                    # Reached the end of the string. Append the rest.\n                    result.append(input_string[current_substring_start:n])\n                    current_substring_start = n\n                    break\n                i += 1\n            else: # Loop finished without a 'break', meaning the whole remaining string is non-uppercase\n                result.append(input_string[current_substring_start:n])\n                current_substring_start = n\n\n    return \"\".join(result)"}
