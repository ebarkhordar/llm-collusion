{"task_id": "mbpp_1", "prompt": "Write a function to sort a given matrix in ascending order according to the sum of its rows.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef sort_matrix_by_row_sum(matrix):\n    \"\"\"\n    Sort a matrix in ascending order according to the sum of its rows.\n    \n    Args:\n        matrix: A list of lists representing the matrix\n        \n    Returns:\n        A new matrix sorted by row sums in ascending order\n    \"\"\"\n    return sorted(matrix, key=sum)\n\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test 1: Basic matrix\n    matrix1 = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [1, 1, 1]\n    ]\n    print(\"Original matrix 1:\")\n    for row in matrix1:\n        print(row)\n    print(\"Sorted by row sum:\")\n    result1 = sort_matrix_by_row_sum(matrix1)\n    for row in result1:\n        print(row)\n    print()\n    \n    # Test 2: Matrix with negative numbers\n    matrix2 = [\n        [5, -2, 3],\n        [-1, 0, 1],\n        [10, 10, 10]\n    ]\n    print(\"Original matrix 2:\")\n    for row in matrix2:\n        print(row)\n    print(\"Sorted by row sum:\")\n    result2 = sort_matrix_by_row_sum(matrix2)\n    for row in result2:\n        print(row)\n    print()\n    \n    # Test 3: Single row\n    matrix3 = [[5, 3, 1]]\n    print(\"Original matrix 3:\")\n    for row in matrix3:\n        print(row)\n    print(\"Sorted by row sum:\")\n    result3 = sort_matrix_by_row_sum(matrix3)\n    for row in result3:\n        print(row)\n    print()\n    \n    # Test 4: Matrix with equal row sums\n    matrix4 = [\n        [1, 2, 3],\n        [2, 2, 2],\n        [0, 3, 3]\n    ]\n    print(\"Original matrix 4:\")\n    for row in matrix4:\n        print(row)\n    print(\"Sorted by row sum:\")\n    result4 = sort_matrix_by_row_sum(matrix4)\n    for row in result4:\n        print(row)\n```\n\n**Explanation:**\n\nThe function `sort_matrix_by_row_sum()` uses Python's built-in `sorted()` function with a `key` parameter:\n\n- **`key=sum`**: This tells `sorted()` to use the sum of each row as the sorting criterion\n- The function returns a new sorted matrix without modifying the original\n- Time complexity: O(n*m + n*log(n)) where n is the number of rows and m is the number of columns\n- Space complexity: O(n*m) for the new sorted matrix\n\nThe test cases demonstrate:\n1. Basic sorting with positive integers\n2. Sorting with negative numbers\n3. Single row matrix\n4. Rows with equal sums (maintains relative order due to stable sort)"}
{"task_id": "mbpp_0", "prompt": "Write a python function to remove first and last occurrence of a given character from the string.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef remove_first_and_last_occurrence(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n        string: The input string\n        char: The character to remove\n    \n    Returns:\n        The modified string with first and last occurrence of char removed\n    \"\"\"\n    if not string or char not in string:\n        return string\n    \n    # Find the first occurrence\n    first_index = string.find(char)\n    \n    # Find the last occurrence\n    last_index = string.rfind(char)\n    \n    # If first and last are the same (only one occurrence), remove it\n    if first_index == last_index:\n        return string[:first_index] + string[first_index + 1:]\n    \n    # Remove last occurrence first (to avoid index shifting issues)\n    string = string[:last_index] + string[last_index + 1:]\n    \n    # Remove first occurrence\n    string = string[:first_index] + string[first_index + 1:]\n    \n    return string\n\n\n# Test cases\nif __name__ == \"__main__\":\n    print(remove_first_and_last_occurrence(\"hello\", \"l\"))  # \"heo\"\n    print(remove_first_and_last_occurrence(\"abcabc\", \"a\"))  # \"bcabc\"\n    print(remove_first_and_last_occurrence(\"programming\", \"g\"))  # \"programmin\"\n    print(remove_first_and_last_occurrence(\"aaa\", \"a\"))  # \"a\"\n    print(remove_first_and_last_occurrence(\"xyz\", \"a\"))  # \"xyz\"\n    print(remove_first_and_last_occurrence(\"a\", \"a\"))  # \"\"\n    print(remove_first_and_last_occurrence(\"\", \"a\"))  # \"\"\n```\n\n**Explanation:**\n\n1. **Check if string is empty or character doesn't exist**: Return the original string if there's nothing to remove.\n\n2. **Find indices**: \n   - `find()` returns the index of the first occurrence\n   - `rfind()` returns the index of the last occurrence\n\n3. **Handle single occurrence**: If first and last indices are the same, only one occurrence exists, so remove it.\n\n4. **Remove both occurrences**: Remove the last occurrence first (to avoid index shifting), then remove the first occurrence.\n\n**Time Complexity**: O(n) where n is the length of the string\n**Space Complexity**: O(n) for the new string created"}
{"task_id": "mbpp_2", "prompt": "Write a function to count the most common words in a dictionary.", "model": "anthropic/claude-haiku-4.5", "code": "```python\nfrom collections import Counter\nfrom typing import List, Tuple\n\ndef count_most_common_words(words: List[str], n: int = 10) -> List[Tuple[str, int]]:\n    \"\"\"\n    Count the most common words in a list.\n    \n    Args:\n        words: List of words to count\n        n: Number of most common words to return (default: 10)\n    \n    Returns:\n        List of tuples containing (word, count) sorted by frequency\n    \"\"\"\n    counter = Counter(words)\n    return counter.most_common(n)\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Example 1: Basic usage\n    words = [\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\", \"apple\", \"date\", \"cherry\", \"cherry\"]\n    result = count_most_common_words(words, n=5)\n    print(\"Most common words:\")\n    for word, count in result:\n        print(f\"  {word}: {count}\")\n    \n    # Example 2: From a text\n    text = \"the quick brown fox jumps over the lazy dog the fox is quick\"\n    words_from_text = text.lower().split()\n    result = count_most_common_words(words_from_text, n=5)\n    print(\"\\nMost common words from text:\")\n    for word, count in result:\n        print(f\"  {word}: {count}\")\n    \n    # Example 3: Get all unique words with counts\n    result_all = count_most_common_words(words)\n    print(\"\\nAll words with counts:\")\n    for word, count in result_all:\n        print(f\"  {word}: {count}\")\n```\n\n**Alternative implementation without using Counter:**\n\n```python\ndef count_most_common_words_manual(words: list, n: int = 10) -> list:\n    \"\"\"\n    Count the most common words without using Counter.\n    \n    Args:\n        words: List of words to count\n        n: Number of most common words to return\n    \n    Returns:\n        List of tuples containing (word, count) sorted by frequency\n    \"\"\"\n    word_count = {}\n    \n    # Count occurrences\n    for word in words:\n        word_count[word] = word_count.get(word, 0) + 1\n    \n    # Sort by count (descending) and return top n\n    sorted_words = sorted(word_count.items(), key=lambda x: x[1], reverse=True)\n    return sorted_words[:n]\n\n\n# Example usage\nif __name__ == \"__main__\":\n    words = [\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\", \"apple\"]\n    result = count_most_common_words_manual(words, n=3)\n    print(\"Most common words:\")\n    for word, count in result:\n        print(f\"  {word}: {count}\")\n```\n\n**Key Features:**\n\n1. **Counter-based approach** (recommended): Uses `collections.Counter` for efficient counting\n2. **Manual approach**: Implements counting using a dictionary\n3. **Flexible parameter**: `n` parameter lets you specify how many top words to return\n4. **Returns tuples**: Each result is a (word, count) tuple\n5. **Sorted output**: Results are automatically sorted by frequency (highest first)\n\nBoth implementations handle edge cases like empty lists and return results in descending order of frequency."}
{"task_id": "mbpp_3", "prompt": "Write a python function to find the volume of a triangular prism.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef triangular_prism_volume(base, height, length):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base: The base of the triangular face (in units)\n        height: The height of the triangular face (in units)\n        length: The length/depth of the prism (in units)\n    \n    Returns:\n        The volume of the triangular prism (in cubic units)\n    \n    Formula: Volume = (1/2 * base * height) * length\n    \"\"\"\n    triangle_area = 0.5 * base * height\n    volume = triangle_area * length\n    return volume\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Example 1: base=5, height=4, length=10\n    vol1 = triangular_prism_volume(5, 4, 10)\n    print(f\"Volume of triangular prism: {vol1} cubic units\")\n    \n    # Example 2: base=3, height=6, length=8\n    vol2 = triangular_prism_volume(3, 6, 8)\n    print(f\"Volume of triangular prism: {vol2} cubic units\")\n    \n    # Example 3: base=7.5, height=5.2, length=12\n    vol3 = triangular_prism_volume(7.5, 5.2, 12)\n    print(f\"Volume of triangular prism: {vol3} cubic units\")\n```\n\n**Output:**\n```\nVolume of triangular prism: 100.0 cubic units\nVolume of triangular prism: 72.0 cubic units\nVolume of triangular prism: 234.0 cubic units\n```\n\nThe function calculates the volume of a triangular prism using the formula:\n- **Volume = (1/2 × base × height) × length**\n\nWhere:\n- `base` and `height` are the dimensions of the triangular cross-section\n- `length` is the depth/length of the prism"}
{"task_id": "mbpp_1", "prompt": "Write a function to sort a given matrix in ascending order according to the sum of its rows.", "model": "openai/gpt-5", "code": "def sort_matrix_by_row_sum(matrix):\n    \"\"\"\n    Return a new matrix sorted in ascending order by the sum of each row.\n\n    Args:\n        matrix (list[list[Number]]): A list of rows (iterables of numbers).\n\n    Returns:\n        list[list[Number]]: A new matrix sorted by row sums.\n    \"\"\"\n    return sorted(matrix, key=sum)"}
{"task_id": "mbpp_4", "prompt": "Write a function to split a string at lowercase letters.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef split_at_lowercase(s):\n    \"\"\"\n    Split a string at lowercase letters.\n    \n    Args:\n        s: Input string\n        \n    Returns:\n        List of substrings split at lowercase letters\n    \"\"\"\n    result = []\n    current = \"\"\n    \n    for char in s:\n        if char.islower():\n            if current:\n                result.append(current)\n            result.append(char)\n            current = \"\"\n        else:\n            current += char\n    \n    if current:\n        result.append(current)\n    \n    return result\n\n\n# Test cases\nprint(split_at_lowercase(\"HelloWorld\"))  # ['H', 'e', 'llo', 'W', 'o', 'rld']\nprint(split_at_lowercase(\"ABC\"))  # ['ABC']\nprint(split_at_lowercase(\"aBcDeF\"))  # ['', 'a', 'Bc', 'D', 'e', 'F']\nprint(split_at_lowercase(\"123abc456\"))  # ['123', 'a', 'b', 'c', '456']\nprint(split_at_lowercase(\"\"))  # []\n```\n\nThis function:\n1. Iterates through each character in the string\n2. When a lowercase letter is found, it appends the accumulated `current` string (if not empty) and the lowercase letter itself to the result\n3. Non-lowercase characters are accumulated in `current`\n4. After the loop, any remaining accumulated string is appended to the result\n5. Returns a list of the split parts"}
{"task_id": "mbpp_0", "prompt": "Write a python function to remove first and last occurrence of a given character from the string.", "model": "openai/gpt-5", "code": "def remove_first_last_occurrence(s: str, ch: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of character (or substring) `ch` from string `s`.\n    - If `ch` occurs zero times, return `s` unchanged.\n    - If `ch` occurs once, remove that single occurrence.\n    - If `ch` occurs 2+ times, remove the first and the last occurrences.\n    \"\"\"\n    if not ch:\n        return s  # avoid removing empty substring which matches everywhere\n\n    first = s.find(ch)\n    if first == -1:\n        return s\n\n    last = s.rfind(ch)\n    if first == last:\n        # only one occurrence\n        return s[:first] + s[first + len(ch):]\n\n    # remove both first and last occurrences, computed on the original string\n    return s[:first] + s[first + len(ch):last] + s[last + len(ch):]"}
{"task_id": "mbpp_3", "prompt": "Write a python function to find the volume of a triangular prism.", "model": "openai/gpt-5", "code": "def triangular_prism_volume(base: float, triangle_height: float, length: float) -> float:\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n        base (float): Base of the triangular face.\n        triangle_height (float): Height of the triangular face perpendicular to the base.\n        length (float): Length (or depth) of the prism.\n\n    Returns:\n        float: Volume of the triangular prism.\n\n    Formula:\n        Volume = 0.5 * base * triangle_height * length\n    \"\"\"\n    if base < 0 or triangle_height < 0 or length < 0:\n        raise ValueError(\"All dimensions must be non-negative.\")\n    return 0.5 * base * triangle_height * length"}
{"task_id": "mbpp_5", "prompt": "Write a function to find sequences of lowercase letters joined with an underscore.", "model": "anthropic/claude-haiku-4.5", "code": "```python\nimport re\n\ndef find_underscore_sequences(text):\n    \"\"\"\n    Find sequences of lowercase letters joined with an underscore.\n    \n    Args:\n        text (str): The input text to search\n        \n    Returns:\n        list: A list of all matching sequences\n    \"\"\"\n    pattern = r'[a-z]+(?:_[a-z]+)+'\n    matches = re.findall(pattern, text)\n    return matches\n\n\n# Test cases\nif __name__ == \"__main__\":\n    test_cases = [\n        \"hello_world and foo_bar_baz\",\n        \"snake_case_naming_convention\",\n        \"test_123_invalid and valid_test\",\n        \"single and multiple_words_here\",\n        \"UPPER_CASE should_not_match MixedCase_test\",\n        \"underscore_ _leading and trailing_\",\n        \"a_b_c_d_e and x_y\",\n    ]\n    \n    for test in test_cases:\n        print(f\"Input: {test}\")\n        print(f\"Matches: {find_underscore_sequences(test)}\")\n        print()\n```\n\n**Explanation:**\n\n- **Pattern**: `r'[a-z]+(?:_[a-z]+)+'`\n  - `[a-z]+` - One or more lowercase letters\n  - `(?:_[a-z]+)+` - One or more occurrences of (underscore followed by one or more lowercase letters)\n  - This ensures at least one underscore is present between lowercase letter sequences\n\n- **Returns**: A list of all matching sequences found in the text\n\n- **Examples**:\n  - ✅ `hello_world`, `foo_bar_baz`, `snake_case_naming_convention`\n  - ❌ `UPPER_CASE` (uppercase), `test_123` (contains numbers), `single` (no underscore)"}
{"task_id": "mbpp_6", "prompt": "Write a function to find the perimeter of a square.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n    \"\"\"\n    return 4 * side_length\n\n\n# Test cases\nif __name__ == \"__main__\":\n    print(square_perimeter(5))      # Output: 20\n    print(square_perimeter(10))     # Output: 40\n    print(square_perimeter(2.5))    # Output: 10.0\n    print(square_perimeter(0))      # Output: 0\n```"}
{"task_id": "mbpp_7", "prompt": "Write a function to remove characters from the first string which are present in the second string.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef remove_characters(str1, str2):\n    \"\"\"\n    Remove characters from the first string which are present in the second string.\n    \n    Args:\n        str1: The string to remove characters from\n        str2: The string containing characters to remove\n    \n    Returns:\n        A new string with characters removed\n    \"\"\"\n    # Create a set of characters from str2 for O(1) lookup\n    chars_to_remove = set(str2)\n    \n    # Filter out characters that are in str2\n    result = ''.join(char for char in str1 if char not in chars_to_remove)\n    \n    return result\n\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test 1: Basic example\n    print(remove_characters(\"hello\", \"lo\"))  # Output: \"he\"\n    \n    # Test 2: No common characters\n    print(remove_characters(\"abc\", \"xyz\"))  # Output: \"abc\"\n    \n    # Test 3: All characters removed\n    print(remove_characters(\"aaa\", \"a\"))  # Output: \"\"\n    \n    # Test 4: Empty strings\n    print(remove_characters(\"hello\", \"\"))  # Output: \"hello\"\n    print(remove_characters(\"\", \"hello\"))  # Output: \"\"\n    \n    # Test 5: Duplicate characters\n    print(remove_characters(\"programming\", \"grm\"))  # Output: \"poa\"\n    \n    # Test 6: Case sensitive\n    print(remove_characters(\"Hello\", \"h\"))  # Output: \"Hello\"\n```\n\n**Explanation:**\n\n1. **Function Logic**: The function takes two strings as input and removes all characters from `str1` that appear anywhere in `str2`.\n\n2. **Efficient Approach**: \n   - Convert `str2` to a set for O(1) character lookup time\n   - Use a list comprehension with `join()` to build the result string efficiently\n\n3. **Time Complexity**: O(n + m) where n is the length of str1 and m is the length of str2\n4. **Space Complexity**: O(m) for the set of characters from str2\n\nThe function handles edge cases like empty strings and is case-sensitive."}
{"task_id": "mbpp_5", "prompt": "Write a function to find sequences of lowercase letters joined with an underscore.", "model": "openai/gpt-5", "code": "import re\nfrom typing import List\n\n_pattern = re.compile(r\"[a-z]+_[a-z]+\")\n\ndef find_sequences(text: str) -> List[str]:\n    return _pattern.findall(text)"}
{"task_id": "mbpp_6", "prompt": "Write a function to find the perimeter of a square.", "model": "openai/gpt-5", "code": "def square_perimeter(side: float) -> float:\n    \"\"\"\n    Return the perimeter of a square given the length of one side.\n\n    Parameters:\n        side (float): Length of a side. Must be non-negative.\n\n    Returns:\n        float: The perimeter of the square.\n\n    Raises:\n        ValueError: If side is negative.\n    \"\"\"\n    if side < 0:\n        raise ValueError(\"Side length must be non-negative.\")\n    return 4 * side"}
{"task_id": "mbpp_8", "prompt": "Write a function to find whether a given array of integers contains any duplicate element.", "model": "openai/gpt-5", "code": "from typing import Iterable\n\ndef contains_duplicate(nums: Iterable[int]) -> bool:\n    \"\"\"\n    Return True if any integer appears at least twice in nums, else False.\n    \"\"\"\n    seen = set()\n    for n in nums:\n        if n in seen:\n            return True\n        seen.add(n)\n    return False"}
{"task_id": "mbpp_8", "prompt": "Write a function to find whether a given array of integers contains any duplicate element.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef contains_duplicate(nums):\n    \"\"\"\n    Find whether a given array of integers contains any duplicate element.\n    \n    Args:\n        nums: List of integers\n        \n    Returns:\n        True if duplicates exist, False otherwise\n    \"\"\"\n    return len(nums) != len(set(nums))\n\n\n# Alternative implementation using a set\ndef contains_duplicate_v2(nums):\n    \"\"\"\n    Alternative approach: iterate through array and track seen elements.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test case 1: Array with duplicates\n    assert contains_duplicate([1, 2, 3, 1]) == True\n    print(\"Test 1 passed: [1, 2, 3, 1] contains duplicates\")\n    \n    # Test case 2: Array without duplicates\n    assert contains_duplicate([1, 2, 3, 4]) == False\n    print(\"Test 2 passed: [1, 2, 3, 4] has no duplicates\")\n    \n    # Test case 3: Empty array\n    assert contains_duplicate([]) == False\n    print(\"Test 3 passed: [] has no duplicates\")\n    \n    # Test case 4: Single element\n    assert contains_duplicate([1]) == False\n    print(\"Test 4 passed: [1] has no duplicates\")\n    \n    # Test case 5: All duplicates\n    assert contains_duplicate([5, 5, 5, 5]) == True\n    print(\"Test 5 passed: [5, 5, 5, 5] contains duplicates\")\n    \n    # Test case 6: Negative numbers\n    assert contains_duplicate([-1, -2, -1]) == True\n    print(\"Test 6 passed: [-1, -2, -1] contains duplicates\")\n    \n    print(\"\\nAll tests passed!\")\n```\n\n**Explanation:**\n\n1. **`contains_duplicate()`** - Most concise approach:\n   - Converts the array to a set (which removes duplicates)\n   - Compares the length of the original array with the set\n   - If lengths differ, duplicates exist\n\n2. **`contains_duplicate_v2()`** - Early exit approach:\n   - Iterates through the array once\n   - Tracks seen elements in a set\n   - Returns `True` immediately upon finding a duplicate\n   - More efficient for large arrays with duplicates early on\n\n**Time Complexity:**\n- Both: O(n) average case\n- `contains_duplicate_v2()` can be faster in practice with early exit\n\n**Space Complexity:**\n- Both: O(n) for the set storage"}
{"task_id": "mbpp_9", "prompt": "Write a function to check if the given number is woodball or not.", "model": "anthropic/claude-haiku-4.5", "code": "# A Woodball number is a number where the sum of factorials of its digits equals the number itself.\n# For example: 145 = 1! + 4! + 5! = 1 + 24 + 120 = 145\n\ndef is_woodball(n):\n    \"\"\"\n    Check if a number is a Woodball number.\n    \n    A Woodball number is a number that equals the sum of the factorials of its digits.\n    \n    Args:\n        n: An integer to check\n        \n    Returns:\n        True if n is a Woodball number, False otherwise\n    \"\"\"\n    if n < 0:\n        return False\n    \n    # Calculate factorial of a digit\n    def factorial(num):\n        if num <= 1:\n            return 1\n        result = 1\n        for i in range(2, num + 1):\n            result *= i\n        return result\n    \n    # Sum of factorials of digits\n    digit_factorial_sum = sum(factorial(int(digit)) for digit in str(n))\n    \n    return digit_factorial_sum == n\n\n\n# Test cases\nif __name__ == \"__main__\":\n    test_cases = [145, 40585, 1, 2, 10, 100, 123, 0]\n    \n    for num in test_cases:\n        result = is_woodball(num)\n        print(f\"{num} is {'a' if result else 'not a'} Woodball number\")\n```\n\n**Output:**\n```\n145 is a Woodball number\n40585 is a Woodball number\n1 is a Woodball number\n2 is a Woodball number\n10 is not a Woodball number\n100 is not a Woodball number\n123 is not a Woodball number\n0 is not a Woodball number\n```\n\n**Explanation:**\n- **145**: 1! + 4! + 5! = 1 + 24 + 120 = 145 ✓\n- **40585**: 4! + 0! + 5! + 8! + 5! = 24 + 1 + 120 + 40320 + 120 = 40585 ✓\n- **1**: 1! = 1 ✓\n- **2**: 2! = 2 ✓"}
{"task_id": "mbpp_10", "prompt": "Write a function to find m number of multiples of n.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef find_multiples(n, m):\n    \"\"\"\n    Find m number of multiples of n.\n    \n    Args:\n        n: The number to find multiples of\n        m: The count of multiples to find\n    \n    Returns:\n        A list containing m multiples of n\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n\n\n# Test cases\nif __name__ == \"__main__\":\n    print(find_multiples(5, 4))      # [5, 10, 15, 20]\n    print(find_multiples(3, 6))      # [3, 6, 9, 12, 15, 18]\n    print(find_multiples(7, 3))      # [7, 14, 21]\n    print(find_multiples(2, 10))     # [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n```\n\nThe function `find_multiples(n, m)` returns a list of `m` multiples of `n` by multiplying `n` by integers from 1 to `m`."}
{"task_id": "mbpp_7", "prompt": "Write a function to remove characters from the first string which are present in the second string.", "model": "openai/gpt-5", "code": "def remove_characters(s1: str, s2: str) -> str:\n    \"\"\"\n    Return a new string formed by removing from s1 all characters that appear in s2.\n    Example: remove_characters(\"hello world\", \"lo\") -> \"he wrd\"\n    \"\"\"\n    if not s2:\n        return s1\n    return s1.translate({ord(c): None for c in set(s2)})"}
{"task_id": "mbpp_4", "prompt": "Write a function to split a string at lowercase letters.", "model": "openai/gpt-5", "code": "import re\n\ndef split_at_lowercase(s: str) -> list[str]:\n    \"\"\"\n    Split a string at lowercase letters (treating contiguous lowercase letters as delimiters).\n    Lowercase letters are not included in the result.\n\n    Example:\n        \"abCDeFgh\" -> [\"CD\", \"F\"]\n    \"\"\"\n    return [part for part in re.split(r'[a-z]+', s) if part]"}
{"task_id": "mbpp_11", "prompt": "Write a function to find the first duplicate element in a given array of integers.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef find_first_duplicate(arr):\n    \"\"\"\n    Find the first duplicate element in an array of integers.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        The first duplicate element found, or None if no duplicates exist\n    \"\"\"\n    seen = set()\n    \n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    \n    return None\n\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test 1: Array with duplicates\n    print(find_first_duplicate([1, 2, 3, 4, 2, 5]))  # Output: 2\n    \n    # Test 2: Array with no duplicates\n    print(find_first_duplicate([1, 2, 3, 4, 5]))  # Output: None\n    \n    # Test 3: Duplicate at the beginning\n    print(find_first_duplicate([1, 1, 2, 3]))  # Output: 1\n    \n    # Test 4: Duplicate at the end\n    print(find_first_duplicate([1, 2, 3, 4, 4]))  # Output: 4\n    \n    # Test 5: Multiple duplicates (returns first one encountered)\n    print(find_first_duplicate([5, 3, 2, 3, 5, 1]))  # Output: 3\n    \n    # Test 6: Empty array\n    print(find_first_duplicate([]))  # Output: None\n    \n    # Test 7: Single element\n    print(find_first_duplicate([1]))  # Output: None\n```\n\n**Explanation:**\n\n- **Time Complexity:** O(n) - single pass through the array\n- **Space Complexity:** O(n) - for the set storing seen elements\n\nThe function uses a set to track elements we've already encountered. As we iterate through the array:\n1. If we find an element already in the set, it's a duplicate → return it\n2. Otherwise, add the element to the set and continue\n3. If we finish the loop without finding duplicates, return None"}
{"task_id": "mbpp_12", "prompt": "Write a python function to find the maximum sum of elements of list in a list of lists.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef max_sum_of_list(list_of_lists):\n    \"\"\"\n    Find the maximum sum of elements in a list of lists.\n    \n    Args:\n        list_of_lists: A list containing multiple lists of numbers\n        \n    Returns:\n        The maximum sum among all lists\n    \"\"\"\n    return max(sum(lst) for lst in list_of_lists)\n\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test 1: Basic case\n    test1 = [[1, 2, 3], [4, 5], [10, -5, 2]]\n    print(f\"Test 1: {test1}\")\n    print(f\"Result: {max_sum_of_list(test1)}\")  # Output: 19\n    \n    # Test 2: Negative numbers\n    test2 = [[-1, -2, -3], [-4, -5], [1, 2, 3]]\n    print(f\"\\nTest 2: {test2}\")\n    print(f\"Result: {max_sum_of_list(test2)}\")  # Output: 6\n    \n    # Test 3: Single list\n    test3 = [[5, 10, 15]]\n    print(f\"\\nTest 3: {test3}\")\n    print(f\"Result: {max_sum_of_list(test3)}\")  # Output: 30\n    \n    # Test 4: Mixed positive and negative\n    test4 = [[1, -5, 3], [2, 2, 2], [-10, 5, 8]]\n    print(f\"\\nTest 4: {test4}\")\n    print(f\"Result: {max_sum_of_list(test4)}\")  # Output: 6\n```\n\n**Alternative implementation with error handling:**\n\n```python\ndef max_sum_of_list(list_of_lists):\n    \"\"\"\n    Find the maximum sum of elements in a list of lists.\n    \n    Args:\n        list_of_lists: A list containing multiple lists of numbers\n        \n    Returns:\n        The maximum sum among all lists, or None if list is empty\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    return max(sum(lst) for lst in list_of_lists)\n```\n\n**Key Points:**\n- Uses `sum()` to calculate the sum of each inner list\n- Uses `max()` with a generator expression to find the maximum sum\n- Time Complexity: O(n*m) where n is the number of lists and m is the average length of each list\n- Space Complexity: O(1) (excluding input)"}
{"task_id": "mbpp_10", "prompt": "Write a function to find m number of multiples of n.", "model": "openai/gpt-5", "code": "def multiples_of_n(n, m):\n    \"\"\"\n    Return a list of the first m multiples of n: [n, 2n, ..., m*n].\n\n    Args:\n        n (int or float): The base number.\n        m (int): How many multiples to generate.\n\n    Returns:\n        list: List containing the first m multiples of n.\n\n    Examples:\n        multiples_of_n(3, 5) -> [3, 6, 9, 12, 15]\n        multiples_of_n(0, 4) -> [0, 0, 0, 0]\n        multiples_of_n(2.5, 3) -> [2.5, 5.0, 7.5]\n    \"\"\"\n    if m <= 0:\n        return []\n    return [n * k for k in range(1, m + 1)]"}
{"task_id": "mbpp_13", "prompt": "Write a function to convert the given binary number to its decimal equivalent.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef binary_to_decimal(binary_num):\n    \"\"\"\n    Convert a binary number to its decimal equivalent.\n    \n    Args:\n        binary_num: Binary number as a string or integer\n        \n    Returns:\n        Decimal equivalent as an integer\n    \"\"\"\n    return int(str(binary_num), 2)\n\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test with string input\n    print(binary_to_decimal(\"1010\"))      # Output: 10\n    print(binary_to_decimal(\"11111111\"))  # Output: 255\n    print(binary_to_decimal(\"1\"))         # Output: 1\n    print(binary_to_decimal(\"0\"))         # Output: 0\n    print(binary_to_decimal(\"10101010\"))  # Output: 170\n    \n    # Test with integer input\n    print(binary_to_decimal(1010))        # Output: 10\n    print(binary_to_decimal(11111111))    # Output: 255\n```\n\n**Alternative implementation using manual calculation:**\n\n```python\ndef binary_to_decimal_manual(binary_num):\n    \"\"\"\n    Convert a binary number to decimal using manual calculation.\n    \n    Args:\n        binary_num: Binary number as a string\n        \n    Returns:\n        Decimal equivalent as an integer\n    \"\"\"\n    binary_str = str(binary_num)\n    decimal = 0\n    \n    for i, digit in enumerate(reversed(binary_str)):\n        decimal += int(digit) * (2 ** i)\n    \n    return decimal\n\n\n# Test cases\nif __name__ == \"__main__\":\n    print(binary_to_decimal_manual(\"1010\"))      # Output: 10\n    print(binary_to_decimal_manual(\"11111111\"))  # Output: 255\n    print(binary_to_decimal_manual(\"1\"))         # Output: 1\n    print(binary_to_decimal_manual(\"0\"))         # Output: 0\n    print(binary_to_decimal_manual(\"10101010\"))  # Output: 170\n```\n\n**Explanation:**\n\n1. **First approach** uses Python's built-in `int()` function with base 2, which is the simplest and most efficient method.\n\n2. **Second approach** manually calculates the decimal value by:\n   - Iterating through each digit from right to left\n   - Multiplying each digit by 2 raised to its position power\n   - Summing all the results\n\nBoth functions correctly convert binary numbers to their decimal equivalents. The first approach is recommended for production code due to its simplicity and efficiency."}
{"task_id": "mbpp_12", "prompt": "Write a python function to find the maximum sum of elements of list in a list of lists.", "model": "openai/gpt-5", "code": "def max_sum_in_list_of_lists(list_of_lists):\n    \"\"\"\n    Return the maximum sum of elements among sublists in a list of lists.\n    If the outer list is empty, returns 0.\n    \"\"\"\n    return max((sum(sublist) for sublist in list_of_lists), default=0)"}
{"task_id": "mbpp_14", "prompt": "Write a python function to find the product of non-repeated elements in a given array.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef product_of_non_repeated_elements(arr):\n    \"\"\"\n    Find the product of non-repeated elements in a given array.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        int: Product of elements that appear only once in the array\n    \"\"\"\n    from collections import Counter\n    \n    # Count occurrences of each element\n    element_count = Counter(arr)\n    \n    # Calculate product of elements that appear exactly once\n    product = 1\n    for element, count in element_count.items():\n        if count == 1:\n            product *= element\n    \n    return product\n\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test 1: Array with repeated and non-repeated elements\n    arr1 = [1, 2, 2, 3, 4, 4, 5]\n    print(f\"Array: {arr1}\")\n    print(f\"Product of non-repeated elements: {product_of_non_repeated_elements(arr1)}\")\n    # Expected: 1 * 3 * 5 = 15\n    \n    # Test 2: Array with all unique elements\n    arr2 = [1, 2, 3, 4, 5]\n    print(f\"\\nArray: {arr2}\")\n    print(f\"Product of non-repeated elements: {product_of_non_repeated_elements(arr2)}\")\n    # Expected: 1 * 2 * 3 * 4 * 5 = 120\n    \n    # Test 3: Array with all repeated elements\n    arr3 = [2, 2, 3, 3, 4, 4]\n    print(f\"\\nArray: {arr3}\")\n    print(f\"Product of non-repeated elements: {product_of_non_repeated_elements(arr3)}\")\n    # Expected: 1 (no non-repeated elements)\n    \n    # Test 4: Array with single element\n    arr4 = [5]\n    print(f\"\\nArray: {arr4}\")\n    print(f\"Product of non-repeated elements: {product_of_non_repeated_elements(arr4)}\")\n    # Expected: 5\n    \n    # Test 5: Array with negative numbers\n    arr5 = [-1, 2, 2, -3, 4, -3]\n    print(f\"\\nArray: {arr5}\")\n    print(f\"Product of non-repeated elements: {product_of_non_repeated_elements(arr5)}\")\n    # Expected: -1 * 4 = -4\n```\n\n**Explanation:**\n\n1. **Counter from collections**: Used to count occurrences of each element in the array\n2. **Iterate through counts**: Loop through the dictionary of element counts\n3. **Filter non-repeated**: Only multiply elements that have a count of 1\n4. **Return product**: Return the final product\n\n**Time Complexity**: O(n) - where n is the length of the array\n**Space Complexity**: O(n) - for the Counter dictionary\n\nThe function handles:\n- Arrays with mixed repeated and non-repeated elements\n- Arrays with all unique elements\n- Arrays with all repeated elements\n- Single element arrays\n- Negative numbers"}
{"task_id": "mbpp_2", "prompt": "Write a function to count the most common words in a dictionary.", "model": "openai/gpt-5", "code": "from typing import Dict, List, Tuple, Optional\n\ndef most_common_words(freqs: Dict[str, int], k: Optional[int] = None):\n    \"\"\"\n    Given a dictionary mapping words to their counts, return the most common words.\n\n    - If k is None: return a list of words tied for the highest count (alphabetically sorted).\n    - If k > 0: return a list of (word, count) tuples for the top-k words,\n      sorted by count desc then word asc.\n    - If the input dict is empty or k <= 0: return [].\n    \"\"\"\n    if not freqs:\n        return []\n    if k is None:\n        max_count = max(freqs.values())\n        return sorted([w for w, c in freqs.items() if c == max_count])\n    try:\n        k = int(k)\n    except (TypeError, ValueError):\n        raise ValueError(\"k must be an integer or None\")\n    if k <= 0:\n        return []\n    return sorted(freqs.items(), key=lambda kv: (-kv[1], kv[0]))[:k]"}
{"task_id": "mbpp_9", "prompt": "Write a function to check if the given number is woodball or not.", "model": "openai/gpt-5", "code": "def is_woodball(n: int) -> bool:\n    \"\"\"\n    Check if n is a Woodall (often misspelled 'woodball') number.\n    A Woodall number has the form k * 2^k - 1 for some integer k >= 1.\n    \"\"\"\n    if n < 1:\n        return False\n    k = 1\n    while True:\n        val = (1 << k) * k - 1\n        if val == n:\n            return True\n        if val > n:\n            return False\n        k += 1"}
{"task_id": "mbpp_11", "prompt": "Write a function to find the first duplicate element in a given array of integers.", "model": "openai/gpt-5", "code": "from typing import List, Optional\n\ndef first_duplicate(nums: List[int]) -> Optional[int]:\n    \"\"\"\n    Returns the first duplicate element encountered when traversing the list\n    from left to right. If no duplicate exists, returns None.\n    \"\"\"\n    seen = set()\n    for x in nums:\n        if x in seen:\n            return x\n        seen.add(x)\n    return None"}
{"task_id": "mbpp_13", "prompt": "Write a function to convert the given binary number to its decimal equivalent.", "model": "openai/gpt-5", "code": "def binary_to_decimal(binary):\n    \"\"\"\n    Convert a binary number to its decimal equivalent.\n    Accepts:\n      - str: e.g., '1010', '0b1010', '-1010', '+1010'\n      - int: e.g., 1010 (interpreted as binary digits), -1010\n    Returns:\n      - int: decimal equivalent\n    Raises:\n      - TypeError: if input type is unsupported\n      - ValueError: if the binary digits are invalid or empty\n    \"\"\"\n    # Normalize input to a sign and a string of binary digits\n    if isinstance(binary, int):\n        sign = -1 if binary < 0 else 1\n        digits = str(abs(binary))\n    elif isinstance(binary, str):\n        s = binary.strip().lower()\n        if not s:\n            raise ValueError(\"Empty input.\")\n        sign = -1 if s.startswith('-') else 1\n        if s[0] in '+-':\n            s = s[1:]\n        if s.startswith('0b'):\n            s = s[2:]\n        digits = s\n    else:\n        raise TypeError(\"binary must be an int or str\")\n\n    if not digits:\n        raise ValueError(\"No binary digits provided.\")\n\n    if any(ch not in '01' for ch in digits):\n        raise ValueError(f\"Invalid binary digits: {digits!r}\")\n\n    return sign * int(digits, 2)"}
{"task_id": "mbpp_15", "prompt": "Write a function to check if the given tuple list has all k elements.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef has_all_k_elements(tuple_list, k):\n    \"\"\"\n    Check if all tuples in the list have exactly k elements.\n    \n    Args:\n        tuple_list: A list of tuples\n        k: The expected number of elements in each tuple\n    \n    Returns:\n        bool: True if all tuples have k elements, False otherwise\n    \"\"\"\n    return all(len(t) == k for t in tuple_list)\n\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test 1: All tuples have k elements\n    test1 = [(1, 2), (3, 4), (5, 6)]\n    print(f\"Test 1: {has_all_k_elements(test1, 2)}\")  # True\n    \n    # Test 2: Not all tuples have k elements\n    test2 = [(1, 2), (3, 4, 5), (6, 7)]\n    print(f\"Test 2: {has_all_k_elements(test2, 2)}\")  # False\n    \n    # Test 3: Empty list\n    test3 = []\n    print(f\"Test 3: {has_all_k_elements(test3, 2)}\")  # True\n    \n    # Test 4: Tuples with 3 elements\n    test4 = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\n    print(f\"Test 4: {has_all_k_elements(test4, 3)}\")  # True\n    \n    # Test 5: Single element tuples\n    test5 = [(1,), (2,), (3,)]\n    print(f\"Test 5: {has_all_k_elements(test5, 1)}\")  # True\n```\n\nThis function:\n- Takes a list of tuples and an integer `k` as parameters\n- Uses the `all()` function with a generator expression to check if every tuple has exactly `k` elements\n- Returns `True` if all tuples have `k` elements, `False` otherwise\n- Handles edge cases like empty lists (returns `True`) and single-element tuples"}
{"task_id": "mbpp_16", "prompt": "Write a python function to remove all digits from a list of strings.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef remove_digits(strings):\n    \"\"\"\n    Remove all digits from a list of strings.\n    \n    Args:\n        strings: A list of strings\n        \n    Returns:\n        A list of strings with all digits removed\n    \"\"\"\n    return [''.join(char for char in s if not char.isdigit()) for s in strings]\n\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test 1: Basic case\n    test1 = [\"hello123\", \"world456\", \"python789\"]\n    print(remove_digits(test1))\n    # Output: ['hello', 'world', 'python']\n    \n    # Test 2: Mixed content\n    test2 = [\"abc123def\", \"1a2b3c\", \"123\"]\n    print(remove_digits(test2))\n    # Output: ['abcdef', 'abc', '']\n    \n    # Test 3: No digits\n    test3 = [\"hello\", \"world\"]\n    print(remove_digits(test3))\n    # Output: ['hello', 'world']\n    \n    # Test 4: Empty list\n    test4 = []\n    print(remove_digits(test4))\n    # Output: []\n    \n    # Test 5: Strings with only digits\n    test5 = [\"123\", \"456\", \"789\"]\n    print(remove_digits(test5))\n    # Output: ['', '', '']\n```\n\nThe function uses a list comprehension to iterate through each string and filters out any digit characters using the `isdigit()` method."}
{"task_id": "mbpp_14", "prompt": "Write a python function to find the product of non-repeated elements in a given array.", "model": "openai/gpt-5", "code": "def product_of_non_repeated(arr):\n    \"\"\"\n    Returns the product of elements that appear exactly once in the array.\n    If no such elements exist, returns 1 (product of empty set).\n    \"\"\"\n    freq = {}\n    for x in arr:\n        freq[x] = freq.get(x, 0) + 1\n\n    result = 1\n    for x, count in freq.items():\n        if count == 1:\n            result *= x\n    return result"}
{"task_id": "mbpp_15", "prompt": "Write a function to check if the given tuple list has all k elements.", "model": "openai/gpt-5", "code": "from itertools import chain\n\ndef has_all_k_elements(tuple_list, k):\n    \"\"\"\n    Returns True if all integers from 1 to k are present across the tuples.\n    \"\"\"\n    required = set(range(1, k + 1))\n    present = set(chain.from_iterable(tuple_list))\n    return required.issubset(present)"}
{"task_id": "mbpp_17", "prompt": "Write a python function to find binomial co-efficient.", "model": "anthropic/claude-haiku-4.5", "code": "# Python function to find binomial coefficient\n\n```python\ndef binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient C(n, k) = n! / (k! * (n-k)!)\n    \n    Args:\n        n: Total number of items\n        k: Number of items to choose\n    \n    Returns:\n        The binomial coefficient C(n, k)\n    \n    Raises:\n        ValueError: If n or k is negative, or k > n\n    \"\"\"\n    # Input validation\n    if n < 0 or k < 0:\n        raise ValueError(\"n and k must be non-negative integers\")\n    if k > n:\n        raise ValueError(\"k cannot be greater than n\")\n    \n    # Optimization: C(n, k) = C(n, n-k)\n    if k > n - k:\n        k = n - k\n    \n    # Calculate using iterative approach to avoid overflow\n    result = 1\n    for i in range(k):\n        result = result * (n - i) // (i + 1)\n    \n    return result\n\n\n# Alternative implementation using math.factorial\nimport math\n\ndef binomial_coefficient_factorial(n, k):\n    \"\"\"\n    Calculate binomial coefficient using factorial function.\n    \n    Args:\n        n: Total number of items\n        k: Number of items to choose\n    \n    Returns:\n        The binomial coefficient C(n, k)\n    \"\"\"\n    if n < 0 or k < 0 or k > n:\n        raise ValueError(\"Invalid input: n >= k >= 0\")\n    \n    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\n\n\n# Alternative implementation using math.comb (Python 3.8+)\ndef binomial_coefficient_comb(n, k):\n    \"\"\"\n    Calculate binomial coefficient using math.comb (Python 3.8+).\n    \n    Args:\n        n: Total number of items\n        k: Number of items to choose\n    \n    Returns:\n        The binomial coefficient C(n, k)\n    \"\"\"\n    return math.comb(n, k)\n\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test the functions\n    test_cases = [(5, 2), (10, 3), (6, 0), (7, 7), (20, 10)]\n    \n    print(\"Testing binomial_coefficient function:\")\n    for n, k in test_cases:\n        result = binomial_coefficient(n, k)\n        print(f\"C({n}, {k}) = {result}\")\n    \n    print(\"\\nTesting binomial_coefficient_factorial function:\")\n    for n, k in test_cases:\n        result = binomial_coefficient_factorial(n, k)\n        print(f\"C({n}, {k}) = {result}\")\n    \n    print(\"\\nTesting binomial_coefficient_comb function:\")\n    for n, k in test_cases:\n        result = binomial_coefficient_comb(n, k)\n        print(f\"C({n}, {k}) = {result}\")\n    \n    # Error handling\n    print(\"\\nTesting error handling:\")\n    try:\n        binomial_coefficient(5, 10)\n    except ValueError as e:\n        print(f\"Error: {e}\")\n```\n\n**Output:**\n```\nTesting binomial_coefficient function:\nC(5, 2) = 10\nC(10, 3) = 120\nC(6, 0) = 1\nC(7, 7) = 1\nC(20, 10) = 184756\n\nTesting binomial_coefficient_factorial function:\nC(5, 2) = 10\nC(10, 3) = 120\nC(6, 0) = 1\nC(7, 7) = 1\nC(20, 10) = 184756\n\nTesting binomial_coefficient_comb function:\nC(5, 2) = 10\nC(10, 3) = 120\nC(6, 0) = 1\nC(7, 7) = 1\nC(20, 10) = 184756\n\nTesting error handling:\nError: k cannot be greater than n\n```\n\n**Key Features:**\n\n1. **`binomial_coefficient(n, k)`** - Most efficient iterative approach, avoids factorial overflow\n2. **`binomial_coefficient_factorial(n, k)`** - Uses factorial function for clarity\n3. **`binomial_coefficient_comb(n, k)`** - Uses built-in `math.comb()` (Python 3.8+)\n\n**Time Complexity:** O(k) for the iterative approach\n**Space Complexity:** O(1)"}
{"task_id": "mbpp_17", "prompt": "Write a python function to find binomial co-efficient.", "model": "openai/gpt-5", "code": "def binomial_coefficient(n, k):\n    \"\"\"\n    Compute C(n, k) = n choose k as a non-negative integer.\n    Returns 0 if k < 0 or n < 0 or k > n.\n    \"\"\"\n    if not isinstance(n, int) or not isinstance(k, int):\n        raise TypeError(\"n and k must be integers\")\n    if n < 0 or k < 0 or k > n:\n        return 0\n    k = min(k, n - k)\n    result = 1\n    for i in range(1, k + 1):\n        result = result * (n - i + 1) // i\n    return result"}
{"task_id": "mbpp_18", "prompt": "Write a python function to find the element occurring odd number of times.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef find_odd_occurrence(arr):\n    \"\"\"\n    Find the element occurring an odd number of times in an array.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        The element that occurs an odd number of times\n        \n    Note: This function assumes there is exactly one element with odd occurrence.\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test 1: Single element with odd occurrence\n    print(find_odd_occurrence([1, 1, 2, 2, 3]))  # Output: 3\n    \n    # Test 2: Multiple elements, one with odd occurrence\n    print(find_odd_occurrence([4, 4, 4, 5, 5, 6, 6]))  # Output: 4\n    \n    # Test 3: All elements appear odd times (returns XOR of all)\n    print(find_odd_occurrence([1, 2, 3]))  # Output: 0 (1^2^3)\n    \n    # Test 4: Single element\n    print(find_odd_occurrence([7]))  # Output: 7\n    \n    # Test 5: Large numbers\n    print(find_odd_occurrence([100, 100, 200, 200, 300]))  # Output: 300\n```\n\n**Explanation:**\n\nThe function uses the **XOR (exclusive OR) bitwise operator** which has these properties:\n- `a ^ a = 0` (any number XOR'd with itself is 0)\n- `a ^ 0 = a` (any number XOR'd with 0 is itself)\n- XOR is commutative and associative\n\n**How it works:**\n1. When we XOR all elements together, elements occurring an even number of times cancel out to 0\n2. The element occurring an odd number of times remains\n3. Time Complexity: O(n)\n4. Space Complexity: O(1)\n\n**Alternative approach** (using dictionary if you need to find all odd-occurring elements):\n\n```python\ndef find_all_odd_occurrences(arr):\n    \"\"\"\n    Find all elements occurring an odd number of times.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        List of elements that occur an odd number of times\n    \"\"\"\n    count_dict = {}\n    \n    for num in arr:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    return [num for num, count in count_dict.items() if count % 2 == 1]\n\n\n# Test\nprint(find_all_odd_occurrences([1, 1, 2, 2, 2, 3, 3, 4]))  # Output: [2, 4]\n```"}
{"task_id": "mbpp_16", "prompt": "Write a python function to remove all digits from a list of strings.", "model": "openai/gpt-5", "code": "from typing import Iterable\n\ndef remove_digits(strings: Iterable[str]) -> list[str]:\n    return [''.join(ch for ch in s if not ch.isdigit()) for s in strings]"}
{"task_id": "mbpp_19", "prompt": "Write a python function to count all the substrings starting and ending with same characters.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef count_substrings_same_start_end(s):\n    \"\"\"\n    Count all substrings that start and end with the same character.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        int: Count of substrings starting and ending with same characters\n    \"\"\"\n    if not s:\n        return 0\n    \n    count = 0\n    n = len(s)\n    \n    # For each starting position\n    for i in range(n):\n        # For each ending position\n        for j in range(i, n):\n            # Check if first and last characters are same\n            if s[i] == s[j]:\n                count += 1\n    \n    return count\n\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test 1: Simple string\n    print(count_substrings_same_start_end(\"ababa\"))  # Output: 9\n    # Substrings: a, b, a, b, a, aba, bab, aba, ababa\n    \n    # Test 2: All same characters\n    print(count_substrings_same_start_end(\"aaa\"))  # Output: 6\n    # Substrings: a, a, a, aa, aa, aaa\n    \n    # Test 3: All different characters\n    print(count_substrings_same_start_end(\"abc\"))  # Output: 3\n    # Substrings: a, b, c\n    \n    # Test 4: Empty string\n    print(count_substrings_same_start_end(\"\"))  # Output: 0\n    \n    # Test 5: Single character\n    print(count_substrings_same_start_end(\"a\"))  # Output: 1\n    \n    # Test 6: Two same characters\n    print(count_substrings_same_start_end(\"aa\"))  # Output: 3\n    # Substrings: a, a, aa\n```\n\n**Alternative optimized solution using character positions:**\n\n```python\ndef count_substrings_same_start_end_optimized(s):\n    \"\"\"\n    Optimized approach: For each character, count combinations of positions.\n    \n    Args:\n        s (str): Input string\n        \n    Returns:\n        int: Count of substrings starting and ending with same characters\n    \"\"\"\n    if not s:\n        return 0\n    \n    count = 0\n    char_positions = {}\n    \n    # Store positions of each character\n    for i, char in enumerate(s):\n        if char not in char_positions:\n            char_positions[char] = []\n        char_positions[char].append(i)\n    \n    # For each character, count all pairs of positions\n    for char, positions in char_positions.items():\n        n = len(positions)\n        # Number of ways to choose 2 positions (including same position)\n        # is n + C(n, 2) = n + n*(n-1)/2 = n*(n+1)/2\n        count += n * (n + 1) // 2\n    \n    return count\n\n\n# Test cases for optimized version\nif __name__ == \"__main__\":\n    print(\"Optimized version:\")\n    print(count_substrings_same_start_end_optimized(\"ababa\"))  # Output: 9\n    print(count_substrings_same_start_end_optimized(\"aaa\"))    # Output: 6\n    print(count_substrings_same_start_end_optimized(\"abc\"))    # Output: 3\n    print(count_substrings_same_start_end_optimized(\"\"))       # Output: 0\n    print(count_substrings_same_start_end_optimized(\"a\"))      # Output: 1\n    print(count_substrings_same_start_end_optimized(\"aa\"))     # Output: 3\n```\n\n**Explanation:**\n\n1. **Brute Force Approach** (First solution):\n   - Time Complexity: O(n²)\n   - Space Complexity: O(1)\n   - Checks every possible substring and counts those where first and last characters match\n\n2. **Optimized Approach** (Second solution):\n   - Time Complexity: O(n)\n   - Space Complexity: O(k) where k is the number of unique characters\n   - For each character, finds all its positions\n   - Uses combination formula: if a character appears n times, it can form n×(n+1)/2 valid substrings\n\nBoth solutions work correctly. Choose the optimized version for better performance on large strings."}
{"task_id": "mbpp_18", "prompt": "Write a python function to find the element occurring odd number of times.", "model": "openai/gpt-5", "code": "def find_odd_occurrence(nums: list[int]) -> int:\n    \"\"\"\n    Find the element occurring an odd number of times.\n    Assumes exactly one such element exists and nums contains integers.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list must be non-empty.\")\n    x = 0\n    for n in nums:\n        x ^= n\n    return x"}
{"task_id": "mbpp_19", "prompt": "Write a python function to count all the substrings starting and ending with same characters.", "model": "openai/gpt-5", "code": "from collections import Counter\n\ndef count_substrings_same_ends(s: str) -> int:\n    \"\"\"\n    Count substrings that start and end with the same character.\n\n    For each character that appears f times, the number of such substrings\n    contributed is f * (f + 1) // 2 (including single-character substrings).\n\n    Args:\n        s: Input string.\n\n    Returns:\n        Total count of substrings starting and ending with the same character.\n    \"\"\"\n    if not s:\n        return 0\n    return sum(f * (f + 1) // 2 for f in Counter(s).values())"}
