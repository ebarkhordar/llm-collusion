{"task_id": "mbpp_1", "prompt": "Write a function to sort a given matrix in ascending order according to the sum of its rows.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef sort_matrix_by_row_sum(matrix):\n    \"\"\"\n    Sort a matrix in ascending order according to the sum of its rows.\n    \n    Args:\n        matrix: A list of lists representing the matrix\n        \n    Returns:\n        A new matrix sorted by row sums in ascending order\n    \"\"\"\n    return sorted(matrix, key=sum)\n\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test 1: Basic matrix\n    matrix1 = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [1, 1, 1]\n    ]\n    print(\"Original matrix 1:\")\n    for row in matrix1:\n        print(row)\n    print(\"Sorted by row sum:\")\n    result1 = sort_matrix_by_row_sum(matrix1)\n    for row in result1:\n        print(row)\n    print()\n    \n    # Test 2: Matrix with negative numbers\n    matrix2 = [\n        [5, -2, 3],\n        [-1, 0, 1],\n        [10, 10, 10]\n    ]\n    print(\"Original matrix 2:\")\n    for row in matrix2:\n        print(row)\n    print(\"Sorted by row sum:\")\n    result2 = sort_matrix_by_row_sum(matrix2)\n    for row in result2:\n        print(row)\n    print()\n    \n    # Test 3: Single row\n    matrix3 = [[5, 3, 1]]\n    print(\"Original matrix 3:\")\n    for row in matrix3:\n        print(row)\n    print(\"Sorted by row sum:\")\n    result3 = sort_matrix_by_row_sum(matrix3)\n    for row in result3:\n        print(row)\n    print()\n    \n    # Test 4: Matrix with equal row sums\n    matrix4 = [\n        [1, 2, 3],\n        [2, 2, 2],\n        [0, 3, 3]\n    ]\n    print(\"Original matrix 4:\")\n    for row in matrix4:\n        print(row)\n    print(\"Sorted by row sum:\")\n    result4 = sort_matrix_by_row_sum(matrix4)\n    for row in result4:\n        print(row)\n```\n\n**Explanation:**\n\nThe function `sort_matrix_by_row_sum()` uses Python's built-in `sorted()` function with a `key` parameter:\n- `key=sum` tells `sorted()` to calculate the sum of each row and use that as the sorting criterion\n- The function returns a new sorted matrix without modifying the original\n- Time complexity: O(n*m*log(n)) where n is the number of rows and m is the number of columns\n- Space complexity: O(n*m) for the new sorted matrix\n\nThe test cases demonstrate:\n1. Basic sorting with positive integers\n2. Handling negative numbers\n3. Single row matrix\n4. Rows with equal sums (maintains relative order due to stable sort)"}
{"task_id": "mbpp_0", "prompt": "Write a python function to remove first and last occurrence of a given character from the string.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef remove_first_and_last_occurrence(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n        string: The input string\n        char: The character to remove\n    \n    Returns:\n        The modified string with first and last occurrence of char removed\n    \"\"\"\n    if not string or char not in string:\n        return string\n    \n    # Find the index of first occurrence\n    first_index = string.find(char)\n    \n    # Find the index of last occurrence\n    last_index = string.rfind(char)\n    \n    # If first and last are the same (only one occurrence), remove it\n    if first_index == last_index:\n        return string[:first_index] + string[first_index + 1:]\n    \n    # Remove first occurrence\n    string = string[:first_index] + string[first_index + 1:]\n    \n    # Adjust last_index since we removed a character before it\n    last_index -= 1\n    \n    # Remove last occurrence\n    string = string[:last_index] + string[last_index + 1:]\n    \n    return string\n\n\n# Test cases\nif __name__ == \"__main__\":\n    print(remove_first_and_last_occurrence(\"hello\", \"l\"))  # \"heo\"\n    print(remove_first_and_last_occurrence(\"abcabc\", \"a\"))  # \"bcabc\" -> \"bcbc\"\n    print(remove_first_and_last_occurrence(\"programming\", \"g\"))  # \"programmin\"\n    print(remove_first_and_last_occurrence(\"aaa\", \"a\"))  # \"a\"\n    print(remove_first_and_last_occurrence(\"xyz\", \"a\"))  # \"xyz\"\n    print(remove_first_and_last_occurrence(\"\", \"a\"))  # \"\"\n    print(remove_first_and_last_occurrence(\"a\", \"a\"))  # \"\"\n```\n\n**Alternative solution using string methods:**\n\n```python\ndef remove_first_and_last_occurrence_v2(string, char):\n    \"\"\"\n    Alternative approach using replace with count parameter.\n    \"\"\"\n    if not string or char not in string:\n        return string\n    \n    # Remove first occurrence\n    string = string.replace(char, \"\", 1)\n    \n    # Remove last occurrence\n    string = string[::-1].replace(char, \"\", 1)[::-1]\n    \n    return string\n\n\n# Test cases\nif __name__ == \"__main__\":\n    print(remove_first_and_last_occurrence_v2(\"hello\", \"l\"))  # \"heo\"\n    print(remove_first_and_last_occurrence_v2(\"abcabc\", \"a\"))  # \"bcbc\"\n    print(remove_first_and_last_occurrence_v2(\"programming\", \"g\"))  # \"programmin\"\n    print(remove_first_and_last_occurrence_v2(\"aaa\", \"a\"))  # \"a\"\n    print(remove_first_and_last_occurrence_v2(\"xyz\", \"a\"))  # \"xyz\"\n```\n\nBoth solutions work correctly:\n- **Version 1**: Uses `find()` and `rfind()` to locate first and last occurrences, then removes them\n- **Version 2**: Uses `replace()` with count=1 to remove first occurrence, reverses the string to remove the last occurrence, then reverses back\n\nChoose the version that best fits your needs!"}
{"task_id": "mbpp_3", "prompt": "Write a python function to find the volume of a triangular prism.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef triangular_prism_volume(base, height, length):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base: The base of the triangular face (in units)\n        height: The height of the triangular face (in units)\n        length: The length/depth of the prism (in units)\n    \n    Returns:\n        The volume of the triangular prism (in cubic units)\n    \n    Formula: Volume = (1/2 * base * height) * length\n             where (1/2 * base * height) is the area of the triangle\n    \"\"\"\n    triangle_area = 0.5 * base * height\n    volume = triangle_area * length\n    return volume\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Example 1: base=5, height=4, length=10\n    vol1 = triangular_prism_volume(5, 4, 10)\n    print(f\"Volume of triangular prism (base=5, height=4, length=10): {vol1} cubic units\")\n    \n    # Example 2: base=3, height=6, length=8\n    vol2 = triangular_prism_volume(3, 6, 8)\n    print(f\"Volume of triangular prism (base=3, height=6, length=8): {vol2} cubic units\")\n    \n    # Example 3: base=7.5, height=5.2, length=12\n    vol3 = triangular_prism_volume(7.5, 5.2, 12)\n    print(f\"Volume of triangular prism (base=7.5, height=5.2, length=12): {vol3} cubic units\")\n```\n\nThe function calculates the volume of a triangular prism using the formula:\n- **Volume = (1/2 × base × height) × length**\n\nWhere:\n- `base` and `height` are the dimensions of the triangular face\n- `length` is the depth/length of the prism"}
{"task_id": "mbpp_2", "prompt": "Write a function to count the most common words in a dictionary.", "model": "anthropic/claude-haiku-4.5", "code": "```python\nfrom collections import Counter\nfrom typing import List, Tuple\n\ndef count_most_common_words(words: List[str], n: int = 10) -> List[Tuple[str, int]]:\n    \"\"\"\n    Count the most common words in a list.\n    \n    Args:\n        words: List of words to analyze\n        n: Number of most common words to return (default: 10)\n    \n    Returns:\n        List of tuples containing (word, count) sorted by frequency\n    \"\"\"\n    word_counts = Counter(words)\n    return word_counts.most_common(n)\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Example 1: Simple word list\n    words = [\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\", \"apple\", \"date\", \"cherry\", \"cherry\"]\n    result = count_most_common_words(words, n=5)\n    print(\"Most common words:\")\n    for word, count in result:\n        print(f\"  {word}: {count}\")\n    \n    # Example 2: From a text\n    text = \"the quick brown fox jumps over the lazy dog the fox is quick\"\n    words_from_text = text.lower().split()\n    result = count_most_common_words(words_from_text, n=5)\n    print(\"\\nMost common words from text:\")\n    for word, count in result:\n        print(f\"  {word}: {count}\")\n```\n\n**Alternative version with case-insensitivity and punctuation handling:**\n\n```python\nfrom collections import Counter\nfrom typing import List, Tuple\nimport re\n\ndef count_most_common_words(text: str, n: int = 10, remove_stopwords: bool = False) -> List[Tuple[str, int]]:\n    \"\"\"\n    Count the most common words in text.\n    \n    Args:\n        text: Input text to analyze\n        n: Number of most common words to return (default: 10)\n        remove_stopwords: Whether to remove common stopwords (default: False)\n    \n    Returns:\n        List of tuples containing (word, count) sorted by frequency\n    \"\"\"\n    # Convert to lowercase and remove punctuation\n    words = re.findall(r'\\b[a-z]+\\b', text.lower())\n    \n    # Optional: remove common stopwords\n    if remove_stopwords:\n        stopwords = {'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'is', 'was'}\n        words = [w for w in words if w not in stopwords]\n    \n    word_counts = Counter(words)\n    return word_counts.most_common(n)\n\n\n# Example usage\nif __name__ == \"__main__\":\n    text = \"\"\"\n    The quick brown fox jumps over the lazy dog. \n    The fox is quick and clever. The dog is lazy but friendly.\n    \"\"\"\n    \n    print(\"Top 5 most common words (with stopwords):\")\n    result = count_most_common_words(text, n=5, remove_stopwords=False)\n    for word, count in result:\n        print(f\"  {word}: {count}\")\n    \n    print(\"\\nTop 5 most common words (without stopwords):\")\n    result = count_most_common_words(text, n=5, remove_stopwords=True)\n    for word, count in result:\n        print(f\"  {word}: {count}\")\n```\n\nBoth versions use Python's `Counter` from the `collections` module, which is optimized for counting hashable objects. The first version is simpler and works with a list of words, while the second version handles raw text with preprocessing options."}
{"task_id": "mbpp_4", "prompt": "Write a function to split a string at lowercase letters.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef split_at_lowercase(s):\n    \"\"\"\n    Split a string at lowercase letters.\n    \n    Args:\n        s: Input string\n        \n    Returns:\n        List of substrings split at lowercase letters\n    \"\"\"\n    result = []\n    current = \"\"\n    \n    for char in s:\n        if char.islower():\n            if current:\n                result.append(current)\n            result.append(char)\n            current = \"\"\n        else:\n            current += char\n    \n    if current:\n        result.append(current)\n    \n    return result\n\n\n# Test cases\nprint(split_at_lowercase(\"HelloWorld\"))  # ['H', 'e', 'llo', 'W', 'o', 'rld']\nprint(split_at_lowercase(\"ABC\"))  # ['ABC']\nprint(split_at_lowercase(\"aBcDeF\"))  # ['', 'a', 'Bc', 'D', 'e', 'F']\nprint(split_at_lowercase(\"123abc456\"))  # ['123', 'a', 'b', 'c', '456']\nprint(split_at_lowercase(\"\"))  # []\n```\n\nThis function:\n1. Iterates through each character in the string\n2. When a lowercase letter is found, it appends the accumulated `current` string (if not empty) and then appends the lowercase letter itself\n3. For non-lowercase characters, it accumulates them in `current`\n4. After the loop, any remaining accumulated string is appended to the result\n5. Returns a list of all split segments"}
{"task_id": "mbpp_1", "prompt": "Write a function to sort a given matrix in ascending order according to the sum of its rows.", "model": "openai/gpt-5", "code": "from typing import Iterable, List, Sequence\n\ndef sort_matrix_by_row_sum(matrix: Iterable[Sequence[float]]) -> List[Sequence[float]]:\n    \"\"\"\n    Return a new matrix with rows sorted in ascending order by the sum of their elements.\n    The original matrix is not modified.\n\n    Args:\n        matrix: An iterable of row sequences (e.g., lists/tuples) containing numeric values.\n\n    Returns:\n        A list of rows sorted by ascending row sum.\n    \"\"\"\n    return sorted(matrix, key=sum)"}
{"task_id": "mbpp_2", "prompt": "Write a function to count the most common words in a dictionary.", "model": "openai/gpt-5", "code": "from typing import Dict, List, Tuple\n\ndef most_common_words(freq: Dict[str, int]) -> Tuple[List[str], int]:\n    \"\"\"\n    Given a dictionary mapping words to their counts, return a tuple of:\n    - list of the most common word(s) (ties included, sorted alphabetically)\n    - the maximum count\n    \n    Examples:\n        >>> most_common_words({\"a\": 2, \"b\": 5, \"c\": 5, \"d\": 1})\n        (['b', 'c'], 5)\n        >>> most_common_words({})\n        ([], 0)\n    \"\"\"\n    if not freq:\n        return [], 0\n    max_count = max(freq.values())\n    words = sorted([w for w, c in freq.items() if c == max_count])\n    return words, max_count"}
{"task_id": "mbpp_3", "prompt": "Write a python function to find the volume of a triangular prism.", "model": "openai/gpt-5", "code": "def triangular_prism_volume(base: float, triangle_height: float, length: float) -> float:\n    \"\"\"\n    Compute the volume of a triangular prism.\n\n    V = 0.5 * base * triangle_height * length\n\n    Args:\n        base: Base of the triangular face.\n        triangle_height: Height of the triangular face (perpendicular to base).\n        length: Length (or depth) of the prism.\n\n    Returns:\n        The volume of the triangular prism.\n\n    Raises:\n        ValueError: If any dimension is negative.\n    \"\"\"\n    if base < 0 or triangle_height < 0 or length < 0:\n        raise ValueError(\"Dimensions must be non-negative.\")\n    return 0.5 * base * triangle_height * length"}
{"task_id": "mbpp_0", "prompt": "Write a python function to remove first and last occurrence of a given character from the string.", "model": "openai/gpt-5", "code": "def remove_first_last_char(s: str, ch: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of 'ch' from the string 's'.\n    If 'ch' occurs once, removes that single occurrence.\n    If 'ch' does not occur, returns 's' unchanged.\n    'ch' must be a non-empty string (character or substring).\n    \"\"\"\n    if not isinstance(s, str) or not isinstance(ch, str):\n        raise TypeError(\"Both s and ch must be strings.\")\n    if ch == \"\":\n        raise ValueError(\"ch must be a non-empty string.\")\n\n    first = s.find(ch)\n    if first == -1:\n        return s\n\n    last = s.rfind(ch)\n    if first == last:\n        return s[:first] + s[first + len(ch):]\n\n    return s[:first] + s[first + len(ch):last] + s[last + len(ch):]\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    print(remove_first_last_char(\"abracadabra\", \"a\"))  # -> \"bracadabr\"\n    print(remove_first_last_char(\"banana\", \"a\"))       # -> \"bnan\"\n    print(remove_first_last_char(\"hello\", \"z\"))        # -> \"hello\"\n    print(remove_first_last_char(\"aaaa\", \"a\"))         # -> \"aa\""}
{"task_id": "mbpp_4", "prompt": "Write a function to split a string at lowercase letters.", "model": "openai/gpt-5", "code": "import re\nfrom typing import List\n\ndef split_at_lowercase(s: str, keep_empty: bool = False) -> List[str]:\n    \"\"\"\n    Split the string at one or more lowercase ASCII letters (a-z).\n    Lowercase letters act as delimiters and are not included in the result.\n    \n    Args:\n        s: Input string.\n        keep_empty: If True, keep empty strings resulting from leading/trailing\n                    or consecutive delimiters. If False, remove them.\n    Returns:\n        List of substrings split at lowercase letters.\n    \"\"\"\n    parts = re.split(r'[a-z]+', s)\n    return parts if keep_empty else [p for p in parts if p]"}
