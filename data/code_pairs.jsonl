{"task_id": "mbpp_0", "prompt": "Write a python function to remove first and last occurrence of a given character from the string.", "model": "openai/gpt-5", "code": "def remove_first_and_last(s: str, ch: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of character `ch` from the string `s`.\n    - If `ch` is not present, return `s` unchanged.\n    - If `ch` occurs once, remove that single occurrence.\n    \"\"\"\n    if len(ch) != 1:\n        raise ValueError(\"ch must be a single character\")\n    first = s.find(ch)\n    if first == -1:\n        return s\n    last = s.rfind(ch)\n    if first == last:\n        return s[:first] + s[first+1:]\n    return s[:first] + s[first+1:last] + s[last+1:]"}
{"task_id": "mbpp_0", "prompt": "Write a python function to remove first and last occurrence of a given character from the string.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef remove_first_and_last_occurrence(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n        string: The input string\n        char: The character to remove\n    \n    Returns:\n        The modified string with first and last occurrence of char removed\n    \"\"\"\n    if char not in string:\n        return string\n    \n    # Find the first occurrence\n    first_index = string.find(char)\n    \n    # Find the last occurrence\n    last_index = string.rfind(char)\n    \n    # If first and last are the same (only one occurrence), remove it\n    if first_index == last_index:\n        return string[:first_index] + string[first_index + 1:]\n    \n    # Remove last occurrence first (to avoid index shifting issues)\n    string = string[:last_index] + string[last_index + 1:]\n    \n    # Remove first occurrence\n    string = string[:first_index] + string[first_index + 1:]\n    \n    return string\n\n\n# Test cases\nif __name__ == \"__main__\":\n    print(remove_first_and_last_occurrence(\"hello\", \"l\"))  # \"heo\"\n    print(remove_first_and_last_occurrence(\"abcabc\", \"a\"))  # \"bcabc\"\n    print(remove_first_and_last_occurrence(\"programming\", \"m\"))  # \"prograin\"\n    print(remove_first_and_last_occurrence(\"aaa\", \"a\"))  # \"a\"\n    print(remove_first_and_last_occurrence(\"xyz\", \"a\"))  # \"xyz\"\n    print(remove_first_and_last_occurrence(\"a\", \"a\"))  # \"\"\n```"}
{"task_id": "mbpp_1", "prompt": "Write a function to sort a given matrix in ascending order according to the sum of its rows.", "model": "openai/gpt-5", "code": "def sort_matrix_by_row_sum(matrix):\n    \"\"\"\n    Sorts the rows of the matrix in ascending order based on the sum of each row.\n    \n    Args:\n        matrix: An iterable of iterables representing the matrix (e.g., list of lists).\n        \n    Returns:\n        A new list with rows sorted by their row sums in ascending order.\n    \"\"\"\n    return sorted(matrix, key=sum)"}
{"task_id": "mbpp_1", "prompt": "Write a function to sort a given matrix in ascending order according to the sum of its rows.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef sort_matrix_by_row_sum(matrix):\n    \"\"\"\n    Sort a matrix in ascending order according to the sum of its rows.\n    \n    Args:\n        matrix: A list of lists representing the matrix\n        \n    Returns:\n        A new matrix sorted by row sums in ascending order\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))\n\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test 1: Basic matrix\n    matrix1 = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [1, 1, 1]\n    ]\n    print(\"Original matrix 1:\")\n    for row in matrix1:\n        print(row)\n    print(\"\\nSorted by row sum:\")\n    result1 = sort_matrix_by_row_sum(matrix1)\n    for row in result1:\n        print(row, \"sum:\", sum(row))\n    \n    # Test 2: Matrix with negative numbers\n    matrix2 = [\n        [5, -2, 3],\n        [-1, -1, -1],\n        [2, 2, 2]\n    ]\n    print(\"\\n\\nOriginal matrix 2:\")\n    for row in matrix2:\n        print(row)\n    print(\"\\nSorted by row sum:\")\n    result2 = sort_matrix_by_row_sum(matrix2)\n    for row in result2:\n        print(row, \"sum:\", sum(row))\n    \n    # Test 3: Single row\n    matrix3 = [[5, 3, 1]]\n    print(\"\\n\\nOriginal matrix 3:\")\n    for row in matrix3:\n        print(row)\n    print(\"\\nSorted by row sum:\")\n    result3 = sort_matrix_by_row_sum(matrix3)\n    for row in result3:\n        print(row, \"sum:\", sum(row))\n    \n    # Test 4: Matrix with equal row sums\n    matrix4 = [\n        [1, 2, 3],\n        [2, 2, 2],\n        [0, 3, 3]\n    ]\n    print(\"\\n\\nOriginal matrix 4:\")\n    for row in matrix4:\n        print(row)\n    print(\"\\nSorted by row sum:\")\n    result4 = sort_matrix_by_row_sum(matrix4)\n    for row in result4:\n        print(row, \"sum:\", sum(row))\n```\n\nOutput:\n```\nOriginal matrix 1:\n[1, 2, 3]\n[4, 5, 6]\n[1, 1, 1]\n\nSorted by row sum:\n[1, 1, 1] sum: 3\n[1, 2, 3] sum: 6\n[4, 5, 6] sum: 15\n\n\nOriginal matrix 2:\n[5, -2, 3]\n[-1, -1, -1]\n[2, 2, 2]\n\nSorted by row sum:\n[-1, -1, -1] sum: -3\n[5, -2, 3] sum: 6\n[2, 2, 2] sum: 6\n\n\nOriginal matrix 3:\n[5, 3, 1]\n\nSorted by row sum:\n[5, 3, 1] sum: 9\n\n\nOriginal matrix 4:\n[1, 2, 3]\n[2, 2, 2]\n[0, 3, 3]\n\nSorted by row sum:\n[2, 2, 2] sum: 6\n[1, 2, 3] sum: 6\n[0, 3, 3] sum: 6\n```"}
{"task_id": "mbpp_2", "prompt": "Write a function to count the most common words in a dictionary.", "model": "openai/gpt-5", "code": "from collections import Counter\nfrom collections.abc import Iterable, Mapping\nimport re\nfrom typing import Union, List, Tuple\n\n\ndef most_common_words(\n    data: Union[Mapping[str, int], str, Iterable[str]],\n    top_n: int | None = None,\n) -> List[Tuple[str, int]]:\n    \"\"\"\n    Return the most common words with their counts.\n\n    Accepts:\n      - A mapping of word -> count.\n      - A string (text), which will be tokenized into words.\n      - An iterable of words.\n\n    Args:\n        data: Mapping[str, int] | str | Iterable[str]\n        top_n: If None, returns all words tied for the maximum count.\n               If an integer > 0, returns the top N words by count.\n\n    Returns:\n        A list of (word, count) pairs.\n        - If top_n is None: returns all words with the maximum count,\n          sorted alphabetically by word.\n        - If top_n is an integer: returns up to top_n words sorted by\n          descending count, then alphabetically for ties.\n\n    Examples:\n        most_common_words({\"a\": 3, \"b\": 5, \"c\": 5})\n        -> [(\"b\", 5), (\"c\", 5)]\n\n        most_common_words(\"A a a b B c\", top_n=2)\n        -> [(\"a\", 3), (\"b\", 2)]\n    \"\"\"\n    # Build counts from input\n    if isinstance(data, Mapping):\n        counts = Counter()\n        for w, c in data.items():\n            if not isinstance(w, str):\n                raise TypeError(\"All keys in the mapping must be strings.\")\n            try:\n                c_num = int(c)\n            except (TypeError, ValueError):\n                raise TypeError(\"All values in the mapping must be integers.\") from None\n            counts[w] = c_num\n    elif isinstance(data, str):\n        # Tokenize: words with letters, numbers, and apostrophes; normalize to lowercase.\n        tokens = re.findall(r\"[A-Za-z0-9']+\", data.lower())\n        counts = Counter(tokens)\n    elif isinstance(data, Iterable):\n        counts = Counter()\n        for item in data:\n            if not isinstance(item, str):\n                raise TypeError(\"All items in the iterable must be strings.\")\n            counts[item.lower()] += 1\n    else:\n        raise TypeError(\"Unsupported input type. Provide a mapping, string, or iterable of strings.\")\n\n    if not counts:\n        return []\n\n    if top_n is None:\n        max_count = max(counts.values())\n        words = [w for w, c in counts.items() if c == max_count]\n        words.sort()\n        return [(w, max_count) for w in words]\n\n    if not isinstance(top_n, int) or top_n <= 0:\n        raise ValueError(\"top_n must be a positive integer or None.\")\n\n    # Sort by count desc, then word asc for deterministic ties\n    return sorted(counts.items(), key=lambda kv: (-kv[1], kv[0]))[:top_n]"}
{"task_id": "mbpp_2", "prompt": "Write a function to count the most common words in a dictionary.", "model": "anthropic/claude-haiku-4.5", "code": "```python\nfrom collections import Counter\nfrom typing import List, Tuple\n\ndef count_most_common_words(words: List[str], n: int = 10) -> List[Tuple[str, int]]:\n    \"\"\"\n    Count the most common words in a list.\n    \n    Args:\n        words: List of words to count\n        n: Number of most common words to return (default: 10)\n    \n    Returns:\n        List of tuples containing (word, count) sorted by frequency\n    \"\"\"\n    word_counts = Counter(words)\n    return word_counts.most_common(n)\n\n\ndef count_most_common_words_from_text(text: str, n: int = 10, \n                                      case_sensitive: bool = False,\n                                      exclude_stopwords: bool = False) -> List[Tuple[str, int]]:\n    \"\"\"\n    Count the most common words in a text string.\n    \n    Args:\n        text: Text to analyze\n        n: Number of most common words to return (default: 10)\n        case_sensitive: Whether to treat uppercase and lowercase as different (default: False)\n        exclude_stopwords: Whether to exclude common English stopwords (default: False)\n    \n    Returns:\n        List of tuples containing (word, count) sorted by frequency\n    \"\"\"\n    import re\n    \n    # Common English stopwords\n    stopwords = {\n        'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',\n        'of', 'with', 'by', 'from', 'is', 'are', 'was', 'were', 'be', 'been',\n        'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would',\n        'could', 'should', 'may', 'might', 'must', 'can', 'this', 'that',\n        'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they'\n    }\n    \n    # Convert to lowercase if not case sensitive\n    if not case_sensitive:\n        text = text.lower()\n    \n    # Extract words (alphanumeric sequences)\n    words = re.findall(r'\\b[a-z]+\\b' if not case_sensitive else r'\\b[a-zA-Z]+\\b', text)\n    \n    # Filter stopwords if requested\n    if exclude_stopwords:\n        words = [word for word in words if word.lower() not in stopwords]\n    \n    word_counts = Counter(words)\n    return word_counts.most_common(n)\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Example 1: Simple word list\n    words = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple', 'date', 'cherry']\n    print(\"Most common words from list:\")\n    print(count_most_common_words(words, n=3))\n    \n    # Example 2: Text analysis\n    text = \"\"\"\n    The quick brown fox jumps over the lazy dog. \n    The dog was sleeping under the tree. \n    The fox was very quick and clever.\n    \"\"\"\n    print(\"\\nMost common words from text (with stopwords):\")\n    print(count_most_common_words_from_text(text, n=5, exclude_stopwords=False))\n    \n    print(\"\\nMost common words from text (without stopwords):\")\n    print(count_most_common_words_from_text(text, n=5, exclude_stopwords=True))\n```\n\nThis solution provides:\n\n1. **`count_most_common_words()`** - Basic function that counts words in a list using `Counter`\n2. **`count_most_common_words_from_text()`** - Advanced function that:\n   - Extracts words from text using regex\n   - Supports case-insensitive matching\n   - Can exclude common English stopwords\n   - Returns results sorted by frequency\n\nBoth functions return a list of tuples with `(word, count)` pairs, making it easy to see which words appear most frequently."}
{"task_id": "mbpp_3", "prompt": "Write a python function to find the volume of a triangular prism.", "model": "openai/gpt-5", "code": "def triangular_prism_volume(base: float, height: float, length: float) -> float:\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Volume = 0.5 * base * height * length\n\n    Args:\n        base: The base length of the triangular face.\n        height: The height of the triangular face perpendicular to the base.\n        length: The length (depth) of the prism.\n\n    Returns:\n        The volume of the triangular prism.\n\n    Raises:\n        ValueError: If any of the dimensions are negative.\n    \"\"\"\n    if base < 0 or height < 0 or length < 0:\n        raise ValueError(\"Dimensions must be non-negative.\")\n    return 0.5 * base * height * length"}
{"task_id": "mbpp_3", "prompt": "Write a python function to find the volume of a triangular prism.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef triangular_prism_volume(base, height, length):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base: The base of the triangular face\n        height: The height of the triangular face\n        length: The length (depth) of the prism\n    \n    Returns:\n        The volume of the triangular prism\n    \"\"\"\n    triangle_area = 0.5 * base * height\n    volume = triangle_area * length\n    return volume\n\n\n# Example usage\nif __name__ == \"__main__\":\n    base = 5\n    height = 4\n    length = 10\n    \n    volume = triangular_prism_volume(base, height, length)\n    print(f\"Volume of triangular prism: {volume} cubic units\")\n```"}
{"task_id": "mbpp_4", "prompt": "Write a function to split a string at lowercase letters.", "model": "openai/gpt-5", "code": "import re\n\ndef split_at_lowercase(s: str):\n    \"\"\"\n    Split the input string at lowercase ASCII letters, discarding the lowercase letters.\n    Returns a list of substrings (empty strings may appear for adjacent lowercase chars or edges).\n    \"\"\"\n    return re.split(r'[a-z]', s)"}
{"task_id": "mbpp_4", "prompt": "Write a function to split a string at lowercase letters.", "model": "anthropic/claude-haiku-4.5", "code": "```python\ndef split_at_lowercase(s):\n    \"\"\"\n    Split a string at lowercase letters.\n    \n    Args:\n        s: Input string\n        \n    Returns:\n        List of substrings split at lowercase letters\n    \"\"\"\n    result = []\n    current = \"\"\n    \n    for char in s:\n        if char.islower():\n            if current:\n                result.append(current)\n            result.append(char)\n            current = \"\"\n        else:\n            current += char\n    \n    if current:\n        result.append(current)\n    \n    return result\n\n\n# Test cases\nprint(split_at_lowercase(\"HelloWorld\"))  # ['H', 'e', 'llo', 'W', 'o', 'rld']\nprint(split_at_lowercase(\"ABC\"))  # ['ABC']\nprint(split_at_lowercase(\"aBcDeF\"))  # ['', 'a', 'Bc', 'D', 'e', 'F']\nprint(split_at_lowercase(\"123abc456\"))  # ['123', 'a', 'b', 'c', '456']\nprint(split_at_lowercase(\"\"))  # []\n```"}
