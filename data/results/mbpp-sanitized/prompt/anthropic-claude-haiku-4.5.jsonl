{"benchmark": "mbpp", "task_id": "8", "prompt": "Write a function to find squares of individual elements in a list.", "reference_code": "def square_nums(nums):\n square_nums = list(map(lambda x: x ** 2, nums))\n return square_nums", "test_imports": [], "test_list": ["assert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]", "assert square_nums([10,20,30])==([100,400,900])", "assert square_nums([12,15])==([144,225])"], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "def square_nums(nums):\n    \"\"\"\n    Find squares of individual elements in a list.\n    \n    Args:\n        nums: A list of numbers\n        \n    Returns:\n        A list containing the squares of each element\n    \"\"\"\n    return [num ** 2 for num in nums]"}
{"benchmark": "mbpp", "task_id": "7", "prompt": "Write a function to find all words which are at least 4 characters long in a string.", "reference_code": "import re\ndef find_char_long(text):\n  return (re.findall(r\"\\b\\w{4,}\\b\", text))", "test_imports": [], "test_list": ["assert set(find_char_long('Please move back to stream')) == set(['Please', 'move', 'back', 'stream'])", "assert set(find_char_long('Jing Eco and Tech')) == set(['Jing', 'Tech'])", "assert set(find_char_long('Jhingai wulu road Zone 3')) == set(['Jhingai', 'wulu', 'road', 'Zone'])"], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "def find_char_long(text):\n    \"\"\"\n    Find all words which are at least 4 characters long in a string.\n    \n    Args:\n        text: A string containing words separated by spaces\n        \n    Returns:\n        A list of words that are at least 4 characters long\n    \"\"\"\n    words = text.split()\n    return [word for word in words if len(word) >= 4]"}
{"benchmark": "mbpp", "task_id": "4", "prompt": "Write a function to find the n largest integers from a given list of numbers, returned in descending order.", "reference_code": "import heapq as hq\ndef heap_queue_largest(nums,n):\n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "test_imports": [], "test_list": ["assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65]", "assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],2)==[85, 75]", "assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],5)==[85, 75, 65, 58, 35]"], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "import heapq\n\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers.\n    \n    Args:\n        numbers: A list of numbers\n        n: The number of largest elements to find\n    \n    Returns:\n        A list of the n largest integers in descending order\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    if n >= len(numbers):\n        return sorted(numbers, reverse=True)\n    \n    # Use nlargest from heapq to get n largest elements\n    largest = heapq.nlargest(n, numbers)\n    return largest"}
{"benchmark": "mbpp", "task_id": "2", "prompt": "Write a function to find the shared elements from the given two lists.", "reference_code": "def similar_elements(test_tup1, test_tup2):\n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ", "test_imports": [], "test_list": ["assert set(similar_elements((3, 4, 5, 6),(5, 7, 4, 10))) == set((4, 5))", "assert set(similar_elements((1, 2, 3, 4),(5, 4, 3, 7))) == set((3, 4))", "assert set(similar_elements((11, 12, 14, 13),(17, 15, 14, 13))) == set((13, 14))"], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "def similar_elements(list1, list2):\n    \"\"\"\n    Find the shared elements from two lists.\n    \n    Args:\n        list1: First list\n        list2: Second list\n    \n    Returns:\n        A list of shared elements, sorted in ascending order\n    \"\"\"\n    shared = list(set(list1) & set(list2))\n    return sorted(shared)"}
{"benchmark": "mbpp", "task_id": "3", "prompt": "Write a python function to identify non-prime numbers.", "reference_code": "import math\ndef is_not_prime(n):\n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "test_imports": [], "test_list": ["assert is_not_prime(2) == False", "assert is_not_prime(10) == True", "assert is_not_prime(35) == True", "assert is_not_prime(37) == False"], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n    \n    Args:\n        n: An integer to check\n        \n    Returns:\n        True if n is not prime, False if n is prime\n    \"\"\"\n    if n < 2:\n        return True\n    \n    if n == 2:\n        return False\n    \n    if n % 2 == 0:\n        return True\n    \n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    \n    return False"}
{"benchmark": "mbpp", "task_id": "9", "prompt": "Write a python function to find the minimum number of rotations (greater than 0) required to get the same string.", "reference_code": "def find_Rotations(str): \n    tmp = str + str\n    n = len(str) \n    for i in range(1,n + 1): \n        substring = tmp[i: i+n] \n        if (str == substring): \n            return i \n    return n ", "test_imports": [], "test_list": ["assert find_Rotations(\"aaaa\") == 1", "assert find_Rotations(\"ab\") == 2", "assert find_Rotations(\"abc\") == 3"], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    A rotation means moving the first character to the end.\n    For example, \"abcd\" -> \"bcda\" -> \"cdab\" -> \"dabc\" -> \"abcd\"\n    \n    Args:\n        s: A string\n        \n    Returns:\n        The minimum number of rotations needed to get back to the original string.\n        Returns the length of the string if no rotation before that gives the same string.\n    \"\"\"\n    if not s:\n        return 0\n    \n    n = len(s)\n    rotated = s\n    \n    # Try rotating the string from 1 to n times\n    for i in range(1, n + 1):\n        # Rotate by moving first character to the end\n        rotated = rotated[1:] + rotated[0]\n        \n        # Check if we got back to the original string\n        if rotated == s:\n            return i\n    \n    # If no rotation gives the same string, return n\n    return n"}
{"benchmark": "mbpp", "task_id": "6", "prompt": "Write a python function to check whether the two numbers differ at one bit position only or not.", "reference_code": "def is_Power_Of_Two (x): \n    return x and (not(x & (x - 1))) \ndef differ_At_One_Bit_Pos(a,b): \n    return is_Power_Of_Two(a ^ b)", "test_imports": [], "test_list": ["assert differ_At_One_Bit_Pos(13,9) == True", "assert differ_At_One_Bit_Pos(15,8) == False", "assert differ_At_One_Bit_Pos(2,4) == False", "assert differ_At_One_Bit_Pos(2, 3) == True", "assert differ_At_One_Bit_Pos(5, 1) == True", "assert differ_At_One_Bit_Pos(1, 5) == True"], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "def differ_At_One_Bit_Pos(a, b):\n    \"\"\"\n    Check whether two numbers differ at one bit position only.\n    \n    Args:\n        a: First integer\n        b: Second integer\n    \n    Returns:\n        True if the numbers differ at exactly one bit position, False otherwise\n    \"\"\"\n    # XOR the two numbers to find differing bits\n    xor_result = a ^ b\n    \n    # Check if xor_result is a power of 2 (has exactly one bit set)\n    # A number is a power of 2 if it has exactly one bit set\n    # This can be checked using: n & (n-1) == 0 and n != 0\n    if xor_result == 0:\n        return False\n    \n    return (xor_result & (xor_result - 1)) == 0"}
