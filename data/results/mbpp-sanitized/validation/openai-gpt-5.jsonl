{"benchmark": "mbpp", "task_id": "587", "prompt": "Write a function to convert a list to a tuple.", "reference_code": "def list_tuple(listx):\n  tuplex = tuple(listx)\n  return tuplex", "test_imports": [], "test_list": ["assert list_tuple([5, 10, 7, 4, 15, 3])==(5, 10, 7, 4, 15, 3)", "assert list_tuple([2, 4, 5, 6, 2, 3, 4, 4, 7])==(2, 4, 5, 6, 2, 3, 4, 4, 7)", "assert list_tuple([58,44,56])==(58,44,56)"], "model_name": "openai/gpt-5", "generated_code": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: A tuple containing the elements of the input list.\n    \"\"\"\n    return tuple(lst)"}
{"benchmark": "mbpp", "task_id": "557", "prompt": "Write a function to toggle the case of all characters in a string.", "reference_code": "def toggle_string(string):\n string1 = string.swapcase()\n return string1", "test_imports": [], "test_list": ["assert toggle_string(\"Python\")==(\"pYTHON\")", "assert toggle_string(\"Pangram\")==(\"pANGRAM\")", "assert toggle_string(\"LIttLE\")==(\"liTTle\")"], "model_name": "openai/gpt-5", "generated_code": "def toggle_string(s: str) -> str:\n    \"\"\"\n    Toggle the case of all characters in the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string with the case of each character toggled.\n    \"\"\"\n    return s.swapcase()"}
{"benchmark": "mbpp", "task_id": "555", "prompt": "Write a python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.", "reference_code": "def difference(n) :  \n    S = (n*(n + 1))//2;  \n    res = S*(S-1);  \n    return res;  ", "test_imports": [], "test_list": ["assert difference(3) == 30", "assert difference(5) == 210", "assert difference(2) == 6"], "model_name": "openai/gpt-5", "generated_code": "def difference(n):\n    \"\"\"\n    Compute the difference between the sum of cubes of the first n natural numbers\n    and the sum of the first n natural numbers.\n    \n    For n <= 0, returns 0.\n    \"\"\"\n    if n <= 0:\n        return 0\n    s = n * (n + 1) // 2  # Sum of first n natural numbers\n    return s * s - s      # (sum of cubes) - (sum)"}
{"benchmark": "mbpp", "task_id": "564", "prompt": "Write a python function which takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.", "reference_code": "def count_Pairs(arr,n): \n    cnt = 0; \n    for i in range(n): \n        for j in range(i + 1,n): \n            if (arr[i] != arr[j]): \n                cnt += 1; \n    return cnt; ", "test_imports": [], "test_list": ["assert count_Pairs([1,2,1],3) == 2", "assert count_Pairs([1,1,1,1],4) == 0", "assert count_Pairs([1,2,3,4,5],5) == 10"], "model_name": "openai/gpt-5", "generated_code": "from collections import Counter\nfrom typing import List\n\ndef count_Pairs(nums: List[int]) -> int:\n    \"\"\"\n    Count the number of unordered pairs (i, j) with i < j such that nums[i] != nums[j].\n    \"\"\"\n    n = len(nums)\n    if n < 2:\n        return 0\n    total_pairs = n * (n - 1) // 2\n    freq = Counter(nums)\n    equal_pairs = sum(c * (c - 1) // 2 for c in freq.values())\n    return total_pairs - equal_pairs"}
{"benchmark": "mbpp", "task_id": "569", "prompt": "Write a function to sort each sublist of strings in a given list of lists.", "reference_code": "def sort_sublists(list1):\n    result = list(map(sorted,list1)) \n    return result", "test_imports": [], "test_list": ["assert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']])==[['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]", "assert sort_sublists([['green', 'orange'], ['black'], ['green', 'orange'], ['white']])==[['green', 'orange'], ['black'], ['green', 'orange'], ['white']]", "assert sort_sublists([['a','b'],['d','c'],['g','h'] , ['f','e']])==[['a', 'b'], ['c', 'd'], ['g', 'h'], ['e', 'f']]"], "model_name": "openai/gpt-5", "generated_code": "from typing import List\n\n\ndef sort_sublists(lists: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Sort each sublist of strings in the given list of lists.\n\n    Args:\n        lists: A list containing sublists of strings.\n\n    Returns:\n        A new list where each sublist is sorted in ascending lexicographical order.\n    \"\"\"\n    return [sorted(sublist) for sublist in lists]"}
{"benchmark": "mbpp", "task_id": "566", "prompt": "Write a function to get the sum of the digits of a non-negative integer.", "reference_code": "def sum_digits(n):\n  if n == 0:\n    return 0\n  else:\n    return n % 10 + sum_digits(int(n / 10))", "test_imports": [], "test_list": ["assert sum_digits(345)==12", "assert sum_digits(12)==3", "assert sum_digits(97)==16"], "model_name": "openai/gpt-5", "generated_code": "def sum_digits(n: int) -> int:\n    \"\"\"\n    Return the sum of the digits of a non-negative integer n.\n\n    Parameters:\n        n (int): A non-negative integer.\n\n    Returns:\n        int: Sum of the digits of n.\n\n    Raises:\n        TypeError: If n is not an integer.\n        ValueError: If n is negative.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n\n    total = 0\n    while n:\n        total += n % 10\n        n //= 10\n    return total"}
{"benchmark": "mbpp", "task_id": "565", "prompt": "Write a python function to split a string into characters.", "reference_code": "def split(word): \n    return [char for char in word] ", "test_imports": [], "test_list": ["assert split('python') == ['p','y','t','h','o','n']", "assert split('Name') == ['N','a','m','e']", "assert split('program') == ['p','r','o','g','r','a','m']"], "model_name": "openai/gpt-5", "generated_code": "def split(s):\n    \"\"\"\n    Split a string into a list of its characters.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        list: A list of characters from the input string.\n    \"\"\"\n    return list(s)"}
{"benchmark": "mbpp", "task_id": "554", "prompt": "Write a python function which takes a list of integers and only returns the odd ones.", "reference_code": "def Split(list): \n    od_li = [] \n    for i in list: \n        if (i % 2 != 0): \n            od_li.append(i)  \n    return od_li", "test_imports": [], "test_list": ["assert Split([1,2,3,4,5,6]) == [1,3,5]", "assert Split([10,11,12,13]) == [11,13]", "assert Split([7,8,9,1]) == [7,9,1]"], "model_name": "openai/gpt-5", "generated_code": "from typing import List\n\ndef Split(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Return a list containing only the odd integers from the input list.\n    Booleans (which are subclasses of int) are excluded.\n    \"\"\"\n    return [n for n in numbers if isinstance(n, int) and not isinstance(n, bool) and n % 2 != 0]"}
{"benchmark": "mbpp", "task_id": "600", "prompt": "Write a python function to check whether the given number is even or not.", "reference_code": "def is_Even(n) : \n    if (n^1 == n+1) :\n        return True; \n    else :\n        return False; ", "test_imports": [], "test_list": ["assert is_Even(1) == False", "assert is_Even(2) == True", "assert is_Even(3) == False"], "model_name": "openai/gpt-5", "generated_code": "def is_Even(n):\n    \"\"\"\n    Check whether the given number is even.\n\n    Parameters:\n    n: A number. Typically an integer. Floats that are mathematically integers are supported.\n\n    Returns:\n    bool: True if n is even, False otherwise.\n    \"\"\"\n    # Handle floats that represent integer values (e.g., 4.0)\n    if isinstance(n, float):\n        if not n.is_integer():\n            return False\n        n = int(n)\n    try:\n        return n % 2 == 0\n    except Exception:\n        # For non-numeric types, return False\n        return False"}
{"benchmark": "mbpp", "task_id": "579", "prompt": "Write a function to find the dissimilar elements in the given two tuples.", "reference_code": "def find_dissimilar(test_tup1, test_tup2):\n  res = tuple(set(test_tup1) ^ set(test_tup2))\n  return (res) ", "test_imports": [], "test_list": ["assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)", "assert find_dissimilar((1, 2, 3, 4), (7, 2, 3, 9)) == (1, 4, 7, 9)", "assert find_dissimilar((21, 11, 25, 26), (26, 34, 21, 36)) == (34, 36, 11, 25)"], "model_name": "openai/gpt-5", "generated_code": "from typing import Tuple, Any\n\ndef find_dissimilar(tup1: Tuple[Any, ...], tup2: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    \"\"\"\n    Return a tuple of elements that are present in exactly one of the input tuples.\n    The result is sorted in ascending order.\n    \"\"\"\n    return tuple(sorted(set(tup1).symmetric_difference(set(tup2))))"}
{"benchmark": "mbpp", "task_id": "582", "prompt": "Write a function to check if a dictionary is empty", "reference_code": "def my_dict(dict1):\n  if bool(dict1):\n     return False\n  else:\n     return True", "test_imports": [], "test_list": ["assert my_dict({10})==False", "assert my_dict({11})==False", "assert my_dict({})==True"], "model_name": "openai/gpt-5", "generated_code": "def my_dict(d):\n    \"\"\"\n    Check if the provided argument is an empty dictionary.\n\n    Returns:\n        bool: True if 'd' is a dict and has no items, False otherwise.\n    \"\"\"\n    return isinstance(d, dict) and not d"}
{"benchmark": "mbpp", "task_id": "574", "prompt": "Write a function to find the surface area of a cylinder.", "reference_code": "def surfacearea_cylinder(r,h):\n  surfacearea=((2*3.1415*r*r) +(2*3.1415*r*h))\n  return surfacearea", "test_imports": [], "test_list": ["assert surfacearea_cylinder(10,5)==942.45", "assert surfacearea_cylinder(4,5)==226.18800000000002", "assert surfacearea_cylinder(4,10)==351.848"], "model_name": "openai/gpt-5", "generated_code": "import math\n\ndef surfacearea_cylinder(radius, height):\n    \"\"\"\n    Calculate the total surface area of a closed right circular cylinder.\n\n    Parameters:\n    - radius: The radius of the cylinder's base.\n    - height: The height of the cylinder.\n\n    Returns:\n    - The total surface area as a float.\n    \"\"\"\n    return 2 * math.pi * radius * (radius + height)"}
{"benchmark": "mbpp", "task_id": "581", "prompt": "Write a python function to find the surface area of a square pyramid with a given base edge and height.", "reference_code": "def surface_Area(b,s): \n    return 2 * b * s + pow(b,2) ", "test_imports": [], "test_list": ["assert surface_Area(3,4) == 33", "assert surface_Area(4,5) == 56", "assert surface_Area(1,2) == 5"], "model_name": "openai/gpt-5", "generated_code": "import math\n\ndef surface_Area(base_edge, height):\n    \"\"\"\n    Calculate the surface area of a square pyramid given the base edge and height.\n    \n    Surface Area = base^2 + 2 * base * slant_height\n    where slant_height = sqrt((base/2)^2 + height^2)\n    \"\"\"\n    b = float(base_edge)\n    h = float(height)\n    slant_height = math.sqrt((b / 2) ** 2 + h ** 2)\n    return b * b + 2 * b * slant_height"}
{"benchmark": "mbpp", "task_id": "591", "prompt": "Write a python function to interchange the first and last elements in a list.", "reference_code": "def swap_List(newList): \n    size = len(newList) \n    temp = newList[0] \n    newList[0] = newList[size - 1] \n    newList[size - 1] = temp  \n    return newList ", "test_imports": [], "test_list": ["assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]", "assert swap_List([1, 2, 3]) == [3, 2, 1]", "assert swap_List([4, 5, 6]) == [6, 5, 4]"], "model_name": "openai/gpt-5", "generated_code": "def swap_List(lst):\n    \"\"\"\n    Interchange the first and last elements of a list in place.\n\n    Parameters:\n    lst (list): The list whose first and last elements are to be swapped.\n\n    Returns:\n    list: The list after swapping the first and last elements.\n    \"\"\"\n    if len(lst) < 2:\n        return lst\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst"}
{"benchmark": "mbpp", "task_id": "559", "prompt": "Write a function to find the sum of the largest contiguous sublist in the given list.", "reference_code": "def max_sub_array_sum(a, size):\n  max_so_far = 0\n  max_ending_here = 0\n  for i in range(0, size):\n    max_ending_here = max_ending_here + a[i]\n    if max_ending_here < 0:\n      max_ending_here = 0\n    elif (max_so_far < max_ending_here):\n      max_so_far = max_ending_here\n  return max_so_far", "test_imports": [], "test_list": ["assert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7", "assert max_sub_array_sum([-3, -4, 5, -2, -3, 2, 6, -4], 8) == 8", "assert max_sub_array_sum([-4, -5, 6, -3, -4, 3, 7, -5], 8) == 10"], "model_name": "openai/gpt-5", "generated_code": "def max_sub_array_sum(arr):\n    \"\"\"\n    Returns the sum of the largest contiguous sublist (maximum subarray sum).\n    For an empty list, returns 0.\n    \"\"\"\n    if not arr:\n        return 0\n    max_ending_here = max_so_far = arr[0]\n    for x in arr[1:]:\n        max_ending_here = x if x > max_ending_here + x else max_ending_here + x\n        if max_ending_here > max_so_far:\n            max_so_far = max_ending_here\n    return max_so_far"}
{"benchmark": "mbpp", "task_id": "568", "prompt": "Write a function to create a list of N empty dictionaries.", "reference_code": "def empty_list(length):\n empty_list = [{} for _ in range(length)]\n return empty_list", "test_imports": [], "test_list": ["assert empty_list(5)==[{},{},{},{},{}]", "assert empty_list(6)==[{},{},{},{},{},{}]", "assert empty_list(7)==[{},{},{},{},{},{},{}]"], "model_name": "openai/gpt-5", "generated_code": "def empty_list(n):\n    \"\"\"\n    Create and return a list of n distinct empty dictionaries.\n\n    Args:\n        n (int): The number of empty dictionaries to create.\n\n    Returns:\n        list: A list containing n empty dictionary instances.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        n = 0\n    return [{} for _ in range(n)]"}
{"benchmark": "mbpp", "task_id": "586", "prompt": "Write a python function to split a list at the nth eelment and add the first part to the end.", "reference_code": "def split_Arr(l, n):\n  return l[n:] + l[:n]", "test_imports": [], "test_list": ["assert split_Arr([12,10,5,6,52,36],2) == [5,6,52,36,12,10]", "assert split_Arr([1,2,3,4],1) == [2,3,4,1]", "assert split_Arr([0,1,2,3,4,5,6,7],3) == [3,4,5,6,7,0,1,2]"], "model_name": "openai/gpt-5", "generated_code": "def split_Arr(arr, n):\n    \"\"\"\n    Split a list at the nth element and move the first part to the end.\n\n    This effectively performs a left rotation by n positions.\n    - If n is greater than the list length, it wraps using modulo.\n    - If n is negative, it rotates right by abs(n) positions.\n    - Returns a new list; does not modify the input list.\n\n    Examples:\n    - split_Arr([1,2,3,4,5], 2) -> [3,4,5,1,2]\n    - split_Arr([1,2,3,4,5], -1) -> [5,1,2,3,4]\n    \"\"\"\n    length = len(arr)\n    if length == 0:\n        return []\n    k = n % length\n    return arr[k:] + arr[:k]"}
{"benchmark": "mbpp", "task_id": "576", "prompt": "Write a python function to check whether a list is sublist of another or not.", "reference_code": "def is_Sub_Array(A,B): \n    n = len(A)\n    m = len(B)\n    i = 0; j = 0; \n    while (i < n and j < m):  \n        if (A[i] == B[j]): \n            i += 1; \n            j += 1; \n            if (j == m): \n                return True;  \n        else: \n            i = i - j + 1; \n            j = 0;       \n    return False; ", "test_imports": [], "test_list": ["assert is_Sub_Array([1,4,3,5],[1,2]) == False", "assert is_Sub_Array([1,2,1],[1,2,1]) == True", "assert is_Sub_Array([1,0,2,2],[2,2,0]) ==False"], "model_name": "openai/gpt-5", "generated_code": "from typing import List, Any\n\ndef is_Sub_Array(sub: List[Any], main: List[Any]) -> bool:\n    \"\"\"\n    Check whether 'sub' is a contiguous sublist (subarray) of 'main'.\n\n    Args:\n        sub: The candidate sublist.\n        main: The list in which to search.\n\n    Returns:\n        True if 'sub' appears contiguously and in order within 'main', else False.\n    \"\"\"\n    n, m = len(sub), len(main)\n    if n == 0:\n        return True\n    if n > m:\n        return False\n    # Slide a window of length n across main and compare slices\n    for i in range(m - n + 1):\n        if main[i:i + n] == sub:\n            return True\n    return False"}
{"benchmark": "mbpp", "task_id": "567", "prompt": "Write a function to check whether a specified list is sorted or not.", "reference_code": "def issort_list(list1):\n    result = all(list1[i] <= list1[i+1] for i in range(len(list1)-1))\n    return result", "test_imports": [], "test_list": ["assert issort_list([1,2,4,6,8,10,12,14,16,17])==True", "assert issort_list([1, 2, 4, 6, 8, 10, 12, 14, 20, 17])==False", "assert issort_list([1, 2, 4, 6, 8, 10,15,14,20])==False"], "model_name": "openai/gpt-5", "generated_code": "def issort_list(lst):\n    \"\"\"\n    Check whether the specified list is sorted in non-decreasing (ascending) order.\n\n    Returns:\n        bool: True if the list is sorted, False otherwise.\n    \"\"\"\n    try:\n        return all(lst[i] <= lst[i + 1] for i in range(len(lst) - 1))\n    except TypeError:\n        # If elements are not comparable, consider list not sorted\n        return False"}
{"benchmark": "mbpp", "task_id": "562", "prompt": "Write a python function to find the length of the longest sublists.", "reference_code": "def Find_Max_Length(lst):  \n    maxLength = max(len(x) for x in lst )\n    return maxLength ", "test_imports": [], "test_list": ["assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4", "assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3", "assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5"], "model_name": "openai/gpt-5", "generated_code": "def Find_Max_Length(lst):\n    \"\"\"\n    Returns the length of the longest sublist in the given list.\n    If the list is empty or contains no sublists, returns 0.\n    Only immediate sublists (elements that are lists) are considered.\n    \"\"\"\n    max_len = 0\n    for item in lst:\n        if isinstance(item, list):\n            l = len(item)\n            if l > max_len:\n                max_len = l\n    return max_len"}
{"benchmark": "mbpp", "task_id": "588", "prompt": "Write a python function to find the difference between largest and smallest value in a given list.", "reference_code": "def big_diff(nums):\n     diff= max(nums)-min(nums)\n     return diff", "test_imports": [], "test_list": ["assert big_diff([1,2,3,4]) == 3", "assert big_diff([4,5,12]) == 8", "assert big_diff([9,2,3]) == 7"], "model_name": "openai/gpt-5", "generated_code": "def big_diff(nums):\n    \"\"\"\n    Return the difference between the largest and smallest values in a given list.\n    If the list is empty, return 0.\n    \"\"\"\n    if not nums:\n        return 0\n    mn = mx = nums[0]\n    for v in nums[1:]:\n        if v < mn:\n            mn = v\n        elif v > mx:\n            mx = v\n    return mx - mn"}
{"benchmark": "mbpp", "task_id": "596", "prompt": "Write a function to find the size in bytes of the given tuple.", "reference_code": "import sys \ndef tuple_size(tuple_list):\n  return (sys.getsizeof(tuple_list)) ", "test_imports": [], "test_list": ["assert tuple_size((\"A\", 1, \"B\", 2, \"C\", 3) ) == sys.getsizeof((\"A\", 1, \"B\", 2, \"C\", 3))", "assert tuple_size((1, \"Raju\", 2, \"Nikhil\", 3, \"Deepanshu\") ) == sys.getsizeof((1, \"Raju\", 2, \"Nikhil\", 3, \"Deepanshu\"))", "assert tuple_size(((1, \"Lion\"), ( 2, \"Tiger\"), (3, \"Fox\"), (4, \"Wolf\"))  ) == sys.getsizeof(((1, \"Lion\"), ( 2, \"Tiger\"), (3, \"Fox\"), (4, \"Wolf\")))"], "model_name": "openai/gpt-5", "generated_code": "import sys\n\ndef tuple_size(t):\n    \"\"\"\n    Return the size in bytes of the given tuple object, as reported by sys.getsizeof.\n    This measures the memory consumed by the tuple container itself, not including\n    the sizes of the referenced elements.\n    \"\"\"\n    return sys.getsizeof(t)"}
{"benchmark": "mbpp", "task_id": "578", "prompt": "Write a function to interleave 3 lists of the same length into a single flat list.", "reference_code": "def interleave_lists(list1,list2,list3):\n    result = [el for pair in zip(list1, list2, list3) for el in pair]\n    return result", "test_imports": [], "test_list": ["assert interleave_lists([1,2,3,4,5,6,7],[10,20,30,40,50,60,70],[100,200,300,400,500,600,700])==[1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]", "assert interleave_lists([10,20],[15,2],[5,10])==[10,15,5,20,2,10]", "assert interleave_lists([11,44], [10,15], [20,5])==[11,10,20,44,15,5]"], "model_name": "openai/gpt-5", "generated_code": "from typing import Iterable, List, Any\n\n\ndef interleave_lists(list1: Iterable[Any], list2: Iterable[Any], list3: Iterable[Any]) -> List[Any]:\n    \"\"\"\n    Interleave three lists (or iterables) of the same length into a single flat list.\n\n    Example:\n        interleave_lists([1, 2], [3, 4], [5, 6]) -> [1, 3, 5, 2, 4, 6]\n    \"\"\"\n    a = list(list1)\n    b = list(list2)\n    c = list(list3)\n\n    if not (len(a) == len(b) == len(c)):\n        raise ValueError(\"All input lists must have the same length\")\n\n    # Interleave elements: a1, b1, c1, a2, b2, c2, ...\n    result: List[Any] = []\n    for x, y, z in zip(a, b, c):\n        result.extend((x, y, z))\n    return result"}
{"benchmark": "mbpp", "task_id": "577", "prompt": "Write a python function to find the last digit in factorial of a given number.", "reference_code": "def last_Digit_Factorial(n): \n    if (n == 0): return 1\n    elif (n <= 2): return n  \n    elif (n == 3): return 6\n    elif (n == 4): return 4 \n    else: \n      return 0", "test_imports": [], "test_list": ["assert last_Digit_Factorial(4) == 4", "assert last_Digit_Factorial(21) == 0", "assert last_Digit_Factorial(30) == 0"], "model_name": "openai/gpt-5", "generated_code": "def last_Digit_Factorial(n):\n    \"\"\"\n    Return the last digit of n! for a non-negative integer n.\n    For n >= 5, the last digit is always 0 due to factors 2 and 5.\n    \"\"\"\n    try:\n        k = int(n)\n    except Exception as e:\n        raise TypeError(\"Input must be an integer\") from e\n\n    if k < 0:\n        raise ValueError(\"Factorial is not defined for negative integers\")\n\n    if k >= 5:\n        return 0\n\n    # Exact last digits for 0! to 4!: 1, 1, 2, 6, 4\n    last_digits = [1, 1, 2, 6, 24]\n    return last_digits[k] % 10"}
{"benchmark": "mbpp", "task_id": "599", "prompt": "Write a function to find sum and average of first n natural numbers.", "reference_code": "def sum_average(number):\n total = 0\n for value in range(1, number + 1):\n    total = total + value\n average = total / number\n return (total,average)", "test_imports": [], "test_list": ["assert sum_average(10)==(55, 5.5)", "assert sum_average(15)==(120, 8.0)", "assert sum_average(20)==(210, 10.5)"], "model_name": "openai/gpt-5", "generated_code": "def sum_average(n):\n    \"\"\"\n    Compute the sum and average of the first n natural numbers (1 through n).\n    For n <= 0, returns (0, 0).\n    \n    Parameters:\n        n (int): The count of natural numbers to consider.\n    \n    Returns:\n        tuple: (sum, average) where sum is int and average is float.\n    \"\"\"\n    if n <= 0:\n        return 0, 0\n    s = n * (n + 1) // 2\n    avg = s / n\n    return s, avg"}
{"benchmark": "mbpp", "task_id": "584", "prompt": "Write a function to find the first adverb ending with ly and its positions in a given string.", "reference_code": "import re\ndef find_adverbs(text):\n  for m in re.finditer(r\"\\w+ly\", text):\n    return ('%d-%d: %s' % (m.start(), m.end(), m.group(0)))", "test_imports": [], "test_list": ["assert find_adverbs(\"Clearly, he has no excuse for such behavior.\") == '0-7: Clearly'", "assert find_adverbs(\"Please handle the situation carefuly\") == '28-36: carefuly'", "assert find_adverbs(\"Complete the task quickly\") == '18-25: quickly'"], "model_name": "openai/gpt-5", "generated_code": "import re\nfrom typing import Optional, Tuple\n\n\ndef find_adverbs(s: str) -> Optional[Tuple[str, Tuple[int, int]]]:\n    \"\"\"\n    Find the first adverb ending with 'ly' and its positions in the given string.\n\n    Returns:\n        - A tuple (adverb, (start, end)) where start and end are the indices as per Python's slice semantics\n          (start inclusive, end exclusive), or\n        - None if no such adverb is found.\n    \"\"\"\n    match = re.search(r'\\b[A-Za-z]+ly\\b', s)\n    if not match:\n        return None\n    return match.group(0), match.span()"}
{"benchmark": "mbpp", "task_id": "589", "prompt": "Write a function to find perfect squares between two given numbers.", "reference_code": "def perfect_squares(a, b):\n    lists=[]\n    for i in range (a,b+1):\n        j = 1;\n        while j*j <= i:\n            if j*j == i:\n                 lists.append(i)  \n            j = j+1\n        i = i+1\n    return lists", "test_imports": [], "test_list": ["assert perfect_squares(1,30)==[1, 4, 9, 16, 25]", "assert perfect_squares(50,100)==[64, 81, 100]", "assert perfect_squares(100,200)==[100, 121, 144, 169, 196]"], "model_name": "openai/gpt-5", "generated_code": "from math import isqrt\nfrom typing import List\n\ndef perfect_squares(start: int, end: int) -> List[int]:\n    \"\"\"\n    Return a list of perfect squares between start and end (inclusive).\n    If start > end, the values are swapped. Negative ranges yield an empty list,\n    except that 0 is included if within the range.\n    \"\"\"\n    # Normalize order\n    if start > end:\n        start, end = end, start\n\n    # If the end is negative, no non-negative perfect squares exist\n    if end < 0:\n        return []\n\n    # Clamp start to at least 0 since negative numbers can't be perfect squares\n    start = max(start, 0)\n\n    # Find the smallest integer whose square is >= start\n    low_root = isqrt(start)\n    if low_root * low_root < start:\n        low_root += 1\n\n    # Find the largest integer whose square is <= end\n    high_root = isqrt(end)\n\n    if low_root > high_root:\n        return []\n\n    return [i * i for i in range(low_root, high_root + 1)]"}
{"benchmark": "mbpp", "task_id": "558", "prompt": "Write a python function to find the sum of the per-digit difference between two integers.", "reference_code": "def digit_distance_nums(n1, n2):\n         return sum(map(int,str(abs(n1-n2))))", "test_imports": [], "test_list": ["assert digit_distance_nums(1,2) == 1", "assert digit_distance_nums(23,56) == 6", "assert digit_distance_nums(123,256) == 7"], "model_name": "openai/gpt-5", "generated_code": "def digit_distance_nums(n1, n2):\n    \"\"\"\n    Compute the sum of per-digit absolute differences between two integers.\n    Digits are compared from least significant to most, padding the shorter\n    number with leading zeros as needed. Negative signs are ignored.\n\n    Examples:\n    - digit_distance_nums(121, 39) -> 10  (|1-9| + |2-3| + |1-0| = 8 + 1 + 1)\n    - digit_distance_nums(123, 256) -> 7   (|3-6| + |2-5| + |1-2| = 3 + 3 + 1)\n    \"\"\"\n    a, b = abs(n1), abs(n2)\n    total = 0\n    while a > 0 or b > 0:\n        total += abs((a % 10) - (b % 10))\n        a //= 10\n        b //= 10\n    return total"}
{"benchmark": "mbpp", "task_id": "573", "prompt": "Write a python function to calculate the product of the unique numbers in a given list.", "reference_code": "def unique_product(list_data):\n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p", "test_imports": [], "test_list": ["assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) ==  720000000", "assert unique_product([1, 2, 3, 1,]) == 6", "assert unique_product([7, 8, 9, 0, 1, 1]) == 0"], "model_name": "openai/gpt-5", "generated_code": "from collections import Counter\nfrom typing import Iterable, Union\n\nNumber = Union[int, float]\n\ndef unique_product(numbers: Iterable[Number]) -> Number:\n    \"\"\"\n    Calculate the product of numbers that appear exactly once in the input iterable.\n    If there are no such numbers, returns 1 (the multiplicative identity).\n    \"\"\"\n    counts = Counter(numbers)\n    product = 1\n    for value, cnt in counts.items():\n        if cnt == 1:\n            product *= value\n    return product"}
{"benchmark": "mbpp", "task_id": "583", "prompt": "Write a function which returns nth catalan number.", "reference_code": "def catalan_number(num):\n    if num <=1:\n         return 1   \n    res_num = 0\n    for i in range(num):\n        res_num += catalan_number(i) * catalan_number(num-i-1)\n    return res_num", "test_imports": [], "test_list": ["assert catalan_number(10)==16796", "assert catalan_number(9)==4862", "assert catalan_number(7)==429"], "model_name": "openai/gpt-5", "generated_code": "def catalan_number(n):\n    \"\"\"\n    Return the nth Catalan number (0-indexed).\n    Uses the closed-form relation: Cn = binom(2n, n) // (n + 1).\n    Computed via an integer-safe multiplicative formula in O(n) time.\n\n    Parameters:\n        n (int): non-negative index\n\n    Returns:\n        int: nth Catalan number\n\n    Raises:\n        ValueError: if n is negative\n        TypeError: if n is not an integer\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    # Compute binom(2n, n) iteratively: res = product_{k=1..n} (2n - k + 1) / k\n    res = 1\n    for k in range(1, n + 1):\n        res = (res * (2 * n - k + 1)) // k\n    return res // (n + 1)"}
{"benchmark": "mbpp", "task_id": "560", "prompt": "Write a function to find the union of the elements of two given tuples and output them in sorted order.", "reference_code": "def union_elements(test_tup1, test_tup2):\n  res = tuple(set(test_tup1 + test_tup2))\n  return (res) ", "test_imports": [], "test_list": ["assert union_elements((3, 4, 5, 6),(5, 7, 4, 10) ) == (3, 4, 5, 6, 7, 10)", "assert union_elements((1, 2, 3, 4),(3, 4, 5, 6) ) == (1, 2, 3, 4, 5, 6)", "assert union_elements((11, 12, 13, 14),(13, 15, 16, 17) ) == (11, 12, 13, 14, 15, 16, 17)"], "model_name": "openai/gpt-5", "generated_code": "from typing import Tuple, Any\n\ndef union_elements(t1: Tuple[Any, ...], t2: Tuple[Any, ...]):\n    \"\"\"\n    Return the union of elements from two tuples in sorted order.\n    If elements are not hashable or not mutually comparable for sorting,\n    the function falls back to a deduplicated sequence preserving original order.\n    \"\"\"\n    if t1 is None:\n        t1 = ()\n    if t2 is None:\n        t2 = ()\n    try:\n        unified = set(t1).union(t2)\n        try:\n            return tuple(sorted(unified))\n        except TypeError:\n            # Incomparable elements; preserve original order without sorting\n            combined = list(t1) + list(t2)\n            result = []\n            for item in combined:\n                if item not in result:\n                    result.append(item)\n            return tuple(result)\n    except TypeError:\n        # Elements may be unhashable; deduplicate preserving order\n        combined = list(t1) + list(t2)\n        unique = []\n        for item in combined:\n            exists = False\n            for u in unique:\n                if u == item:\n                    exists = True\n                    break\n            if not exists:\n                unique.append(item)\n        try:\n            return tuple(sorted(unique))\n        except TypeError:\n            return tuple(unique)"}
{"benchmark": "mbpp", "task_id": "556", "prompt": "Write a python function to count the number of pairs whose xor value is odd.", "reference_code": "def find_Odd_Pair(A,N) : \n    oddPair = 0\n    for i in range(0,N) :  \n        for j in range(i+1,N) :  \n            if ((A[i] ^ A[j]) % 2 != 0):  \n                oddPair+=1  \n    return oddPair  ", "test_imports": [], "test_list": ["assert find_Odd_Pair([5,4,7,2,1],5) == 6", "assert find_Odd_Pair([7,2,8,1,0,5,11],7) == 12", "assert find_Odd_Pair([1,2,3],3) == 2"], "model_name": "openai/gpt-5", "generated_code": "def find_Odd_Pair(arr, n=None):\n    \"\"\"\n    Count the number of pairs (i, j) with i < j such that (arr[i] ^ arr[j]) is odd.\n    An XOR is odd iff one number is even and the other is odd, so the count is:\n    count_odds * count_evens over the considered portion of the array.\n    \"\"\"\n    # Ensure we can take len and index; also support iterables\n    if not isinstance(arr, list):\n        arr = list(arr)\n\n    # Determine the portion length to consider\n    if n is None:\n        n = len(arr)\n    else:\n        # Normalize n to be within bounds\n        if n < 0:\n            n = 0\n        elif n > len(arr):\n            n = len(arr)\n\n    count_odd = 0\n    count_even = 0\n\n    for i in range(n):\n        if arr[i] & 1:\n            count_odd += 1\n        else:\n            count_even += 1\n\n    return count_odd * count_even"}
{"benchmark": "mbpp", "task_id": "590", "prompt": "Write a function to convert polar coordinates to rectangular coordinates.", "reference_code": "import cmath\ndef polar_rect(x,y):\n cn = complex(x,y)\n cn=cmath.polar(cn)\n cn1 = cmath.rect(2, cmath.pi)\n return (cn,cn1)", "test_imports": [], "test_list": ["assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))", "assert polar_rect(4,7)==((8.06225774829855, 1.0516502125483738), (-2+2.4492935982947064e-16j))", "assert polar_rect(15,17)==((22.67156809750927, 0.8478169733934057), (-2+2.4492935982947064e-16j))"], "model_name": "openai/gpt-5", "generated_code": "import math\n\ndef polar_rect(r, theta, degrees=False):\n    \"\"\"\n    Convert polar coordinates (r, theta) to rectangular coordinates (x, y).\n\n    Parameters:\n        r (float): Radius (distance from origin).\n        theta (float): Angle. Radians by default; set degrees=True if in degrees.\n        degrees (bool): If True, interpret theta as degrees. Default is False.\n\n    Returns:\n        tuple: (x, y) rectangular coordinates as floats.\n    \"\"\"\n    if degrees:\n        theta = math.radians(theta)\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    return (x, y)"}
{"benchmark": "mbpp", "task_id": "594", "prompt": "Write a function to find the difference of the first even and first odd number of a given list.", "reference_code": "def diff_even_odd(list1):\n    first_even = next((el for el in list1 if el%2==0),-1)\n    first_odd = next((el for el in list1 if el%2!=0),-1)\n    return (first_even-first_odd)", "test_imports": [], "test_list": ["assert diff_even_odd([1,3,5,7,4,1,6,8])==3", "assert diff_even_odd([1,2,3,4,5,6,7,8,9,10])==1", "assert diff_even_odd([1,5,7,9,10])==9"], "model_name": "openai/gpt-5", "generated_code": "from typing import Iterable, Optional\n\ndef diff_even_odd(nums: Iterable[int]) -> Optional[int]:\n    \"\"\"\n    Return the difference between the first even and the first odd integers in nums:\n    first_even - first_odd.\n    Ignores non-integer values and booleans. Returns None if either is not found.\n    \"\"\"\n    first_even = None\n    first_odd = None\n\n    for x in nums:\n        # Consider only plain integers, ignore booleans and non-integers\n        if isinstance(x, bool) or not isinstance(x, int):\n            continue\n\n        if (x % 2 == 0) and first_even is None:\n            first_even = x\n        elif (x % 2 != 0) and first_odd is None:\n            first_odd = x\n\n        if first_even is not None and first_odd is not None:\n            break\n\n    if first_even is None or first_odd is None:\n        return None\n\n    return first_even - first_odd"}
{"benchmark": "mbpp", "task_id": "593", "prompt": "Write a function to remove leading zeroes from an ip address.", "reference_code": "import re\ndef removezero_ip(ip):\n string = re.sub('\\.[0]*', '.', ip)\n return string\n", "test_imports": [], "test_list": ["assert removezero_ip(\"216.08.094.196\")==('216.8.94.196')", "assert removezero_ip(\"12.01.024\")==('12.1.24')", "assert removezero_ip(\"216.08.094.0196\")==('216.8.94.196')"], "model_name": "openai/gpt-5", "generated_code": "from typing import Optional\n\ndef removezero_ip(ip: Optional[str]) -> Optional[str]:\n    \"\"\"\n    Remove leading zeroes from each octet of an IPv4 address string.\n    Examples:\n    - \"216.08.094.196\" -> \"216.8.94.196\"\n    - \"001.002.003.004\" -> \"1.2.3.4\"\n    - \"00.010.0.000\" -> \"0.10.0.0\"\n    Non-digit octets are left unchanged.\n    \"\"\"\n    if ip is None:\n        return None\n\n    parts = ip.split('.')\n    cleaned_parts = []\n    for part in parts:\n        if part.isdigit():\n            stripped = part.lstrip('0')\n            cleaned_parts.append(stripped if stripped != \"\" else \"0\")\n        else:\n            # If the part contains non-digit characters, leave it unchanged\n            cleaned_parts.append(part)\n    return \".\".join(cleaned_parts)"}
{"benchmark": "mbpp", "task_id": "592", "prompt": "Write a python function to find the sum of the product of consecutive binomial co-efficients.", "reference_code": "def binomial_Coeff(n,k): \n    C = [0] * (k + 1); \n    C[0] = 1; # nC0 is 1 \n    for i in range(1,n + 1):  \n        for j in range(min(i, k),0,-1): \n            C[j] = C[j] + C[j - 1]; \n    return C[k]; \ndef sum_Of_product(n): \n    return binomial_Coeff(2 * n,n - 1); ", "test_imports": [], "test_list": ["assert sum_Of_product(3) == 15", "assert sum_Of_product(4) == 56", "assert sum_Of_product(1) == 1"], "model_name": "openai/gpt-5", "generated_code": "import math\n\ndef sum_Of_product(n: int) -> int:\n    \"\"\"\n    Returns the sum of the product of consecutive binomial coefficients:\n    S = sum_{k=0}^{n-1} C(n, k) * C(n, k+1)\n    Using identity: S = C(2n, n-1)\n\n    For n <= 0, returns 0.\n    \"\"\"\n    if n <= 0:\n        return 0\n    return math.comb(2 * n, n - 1)"}
{"benchmark": "mbpp", "task_id": "585", "prompt": "Write a function to find the n most expensive items in a given dataset.", "reference_code": "import heapq\ndef expensive_items(items,n):\n  expensive_items = heapq.nlargest(n, items, key=lambda s: s['price'])\n  return expensive_items", "test_imports": [], "test_list": ["assert expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}],1)==[{'name': 'Item-2', 'price': 555.22}]", "assert expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}, {'name': 'Item-3', 'price': 45.09}],2)==[{'name': 'Item-2', 'price': 555.22},{'name': 'Item-1', 'price': 101.1}]", "assert expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}, {'name': 'Item-3', 'price': 45.09},{'name': 'Item-4', 'price': 22.75}],1)==[{'name': 'Item-2', 'price': 555.22}]"], "model_name": "openai/gpt-5", "generated_code": ""}
{"benchmark": "mbpp", "task_id": "563", "prompt": "Write a function to extract values between quotation marks from a string.", "reference_code": "import re\ndef extract_values(text):\n return (re.findall(r'\"(.*?)\"', text))", "test_imports": [], "test_list": ["assert extract_values('\"Python\", \"PHP\", \"Java\"')==['Python', 'PHP', 'Java']", "assert extract_values('\"python\",\"program\",\"language\"')==['python','program','language']", "assert extract_values('\"red\",\"blue\",\"green\",\"yellow\"')==['red','blue','green','yellow']"], "model_name": "openai/gpt-5", "generated_code": "def extract_values(text):\n    \"\"\"\n    Extract values enclosed in single or double quotation marks from a string.\n\n    - Supports both single (') and double (\") quotes.\n    - Handles standard backslash escapes inside quotes: \\\", \\', \\\\, \\n, \\t, \\r.\n    - A quote preceded by an odd number of backslashes outside quotes is treated as escaped\n      and will not start a quoted segment.\n    - Unclosed quotes are ignored.\n\n    Returns:\n        list: A list of substrings found between matching quotes, with escapes unescaped.\n    \"\"\"\n    if text is None:\n        return []\n    if not isinstance(text, str):\n        text = str(text)\n\n    result = []\n    in_quote = False\n    quote_char = None\n    buf = []\n    i = 0\n    n = len(text)\n\n    while i < n:\n        ch = text[i]\n\n        if not in_quote:\n            if ch in (\"'\", '\"'):\n                # Check if this quote is escaped by an odd number of backslashes\n                bs_count = 0\n                j = i - 1\n                while j >= 0 and text[j] == '\\\\':\n                    bs_count += 1\n                    j -= 1\n                if bs_count % 2 == 0:\n                    # Not escaped: start quoted segment\n                    in_quote = True\n                    quote_char = ch\n                    buf = []\n                # else: escaped quote outside quotes -> ignore as a starter\n            # else: normal character outside quotes; ignore\n        else:\n            if ch == '\\\\':\n                # Handle escape sequences inside quotes\n                i += 1\n                if i < n:\n                    nxt = text[i]\n                    if nxt == 'n':\n                        buf.append('\\n')\n                    elif nxt == 't':\n                        buf.append('\\t')\n                    elif nxt == 'r':\n                        buf.append('\\r')\n                    else:\n                        # For any other escape (including quote chars and backslash), keep literal next char\n                        buf.append(nxt)\n                else:\n                    # Trailing backslash inside quotes; treat as literal backslash\n                    buf.append('\\\\')\n            elif ch == quote_char:\n                # End of quoted segment\n                result.append(''.join(buf))\n                in_quote = False\n                quote_char = None\n                buf = []\n            else:\n                buf.append(ch)\n\n        i += 1\n\n    # Ignore unterminated quoted buffer\n    return result"}
{"benchmark": "mbpp", "task_id": "572", "prompt": "Write a python function to remove duplicate numbers from a given number of lists.", "reference_code": "def two_unique_nums(nums):\n  return [i for i in nums if nums.count(i)==1]", "test_imports": [], "test_list": ["assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]", "assert two_unique_nums([1,2,3,2,4,5]) == [1, 3, 4, 5]", "assert two_unique_nums([1,2,3,4,5]) == [1, 2, 3, 4, 5]"], "model_name": "openai/gpt-5", "generated_code": "from collections import Counter\nfrom typing import List, Iterable\n\n\ndef two_unique_nums(list1: Iterable[int], list2: Iterable[int]) -> List[int]:\n    \"\"\"\n    Remove duplicate numbers across two lists and return the numbers that appear exactly once\n    across both lists combined, sorted in ascending order.\n\n    Example:\n        two_unique_nums([1, 2, 3, 2], [3, 4, 5, 4]) -> [1, 5]\n    \"\"\"\n    counter = Counter()\n    counter.update(list1)\n    counter.update(list2)\n    # Keep elements that appear exactly once overall\n    unique = [num for num, count in counter.items() if count == 1]\n    return sorted(unique)"}
{"benchmark": "mbpp", "task_id": "595", "prompt": "Write a python function to count minimum number of swaps required to convert one binary number represented as a string to another.", "reference_code": "def min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") ", "test_imports": [], "test_list": ["assert min_Swaps(\"1101\",\"1110\") == 1", "assert min_Swaps(\"111\",\"000\") == \"Not Possible\"", "assert min_Swaps(\"111\",\"110\") == \"Not Possible\""], "model_name": "openai/gpt-5", "generated_code": "def min_Swaps(a: str, b: str) -> int:\n    \"\"\"\n    Returns the minimum number of swaps required to convert binary string 'a' into 'b'\n    by swapping any two positions in 'a'. If it's impossible, returns -1.\n\n    A swap can fix one '01' mismatch and one '10' mismatch simultaneously.\n    Therefore, the minimum swaps equal the number of '01' mismatches (which must\n    equal the number of '10' mismatches). If counts of '1's differ, conversion\n    is impossible.\n    \"\"\"\n    if len(a) != len(b):\n        return -1\n\n    # If the count of '1's differs, it's impossible to transform with swaps\n    if a.count('1') != b.count('1'):\n        return -1\n\n    c01 = 0  # positions where a has '0' and b has '1'\n    c10 = 0  # positions where a has '1' and b has '0'\n\n    for ch_a, ch_b in zip(a, b):\n        if ch_a != ch_b:\n            if ch_a == '0' and ch_b == '1':\n                c01 += 1\n            elif ch_a == '1' and ch_b == '0':\n                c10 += 1\n            else:\n                # Non-binary characters; treat as impossible\n                return -1\n\n    # For equal number of '1's, c01 must equal c10; otherwise impossible\n    if c01 != c10:\n        return -1\n\n    # Each swap fixes one pair of mismatches\n    return c01"}
{"benchmark": "mbpp", "task_id": "580", "prompt": "Write a function to remove uneven elements in the nested mixed tuple.", "reference_code": "def even_ele(test_tuple, even_fnc): \n\tres = tuple() \n\tfor ele in test_tuple: \n\t\tif isinstance(ele, tuple): \n\t\t\tres += (even_ele(ele, even_fnc), ) \n\t\telif even_fnc(ele): \n\t\t\tres += (ele, ) \n\treturn res \ndef extract_even(test_tuple):\n  res = even_ele(test_tuple, lambda x: x % 2 == 0)\n  return (res) ", "test_imports": [], "test_list": ["assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)", "assert extract_even((5, 6, (8, 7, (4, 8)), 7, 9)) == (6, (8, (4, 8)))", "assert extract_even((5, 6, (9, 8, (4, 6)), 8, 10)) == (6, (8, (4, 6)), 8, 10)"], "model_name": "openai/gpt-5", "generated_code": "from typing import Any, Tuple, List\n\ndef extract_even(nested: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    \"\"\"\n    Remove odd integer elements from a nested mixed tuple structure.\n    - Preserves the original structure and order.\n    - Processes nested tuples and lists recursively.\n    - Non-integer elements (including bool) are kept unchanged.\n    \"\"\"\n    def is_odd_int(x: Any) -> bool:\n        return isinstance(x, int) and not isinstance(x, bool) and (x % 2 != 0)\n\n    def is_even_int(x: Any) -> bool:\n        return isinstance(x, int) and not isinstance(x, bool) and (x % 2 == 0)\n\n    def rec(obj: Any) -> Any:\n        if isinstance(obj, tuple):\n            result: List[Any] = []\n            for item in obj:\n                if is_even_int(item):\n                    result.append(item)\n                elif isinstance(item, (tuple, list)):\n                    processed = rec(item)\n                    # Ensure we keep container types\n                    result.append(processed)\n                elif is_odd_int(item):\n                    # Skip odd ints\n                    continue\n                else:\n                    result.append(item)\n            return tuple(result)\n        elif isinstance(obj, list):\n            result_list: List[Any] = []\n            for item in obj:\n                if is_even_int(item):\n                    result_list.append(item)\n                elif isinstance(item, (tuple, list)):\n                    processed = rec(item)\n                    result_list.append(processed)\n                elif is_odd_int(item):\n                    continue\n                else:\n                    result_list.append(item)\n            return result_list\n        else:\n            # Atomic non-container: return as is\n            return obj\n\n    # Assume input is a tuple as per problem; still process generically\n    return rec(nested) if isinstance(nested, (tuple, list)) else tuple()"}
{"benchmark": "mbpp", "task_id": "597", "prompt": "Write a function to find kth element from the given two sorted arrays.", "reference_code": "def find_kth(arr1, arr2, k):\n\tm = len(arr1)\n\tn = len(arr2)\n\tsorted1 = [0] * (m + n)\n\ti = 0\n\tj = 0\n\td = 0\n\twhile (i < m and j < n):\n\t\tif (arr1[i] < arr2[j]):\n\t\t\tsorted1[d] = arr1[i]\n\t\t\ti += 1\n\t\telse:\n\t\t\tsorted1[d] = arr2[j]\n\t\t\tj += 1\n\t\td += 1\n\twhile (i < m):\n\t\tsorted1[d] = arr1[i]\n\t\td += 1\n\t\ti += 1\n\twhile (j < n):\n\t\tsorted1[d] = arr2[j]\n\t\td += 1\n\t\tj += 1\n\treturn sorted1[k - 1]", "test_imports": [], "test_list": ["assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6", "assert find_kth([100, 112, 256, 349, 770], [72, 86, 113, 119, 265, 445, 892], 7) == 256", "assert find_kth([3, 4, 7, 8, 10], [2, 5, 9, 11], 6) == 8"], "model_name": "openai/gpt-5", "generated_code": ""}
{"benchmark": "mbpp", "task_id": "598", "prompt": "Write a function to check whether the given number is armstrong or not.", "reference_code": "def armstrong_number(number):\n sum = 0\n times = 0\n temp = number\n while temp > 0:\n           times = times + 1\n           temp = temp // 10\n temp = number\n while temp > 0:\n           reminder = temp % 10\n           sum = sum + (reminder ** times)\n           temp //= 10\n if number == sum:\n           return True\n else:\n           return False", "test_imports": [], "test_list": ["assert armstrong_number(153)==True", "assert armstrong_number(259)==False", "assert armstrong_number(4458)==False"], "model_name": "openai/gpt-5", "generated_code": "def armstrong_number(num: int) -> bool:\n    \"\"\"\n    Check whether the given non-negative integer is an Armstrong (narcissistic) number.\n    An Armstrong number is equal to the sum of its own digits each raised to the\n    power of the number of digits.\n\n    Returns True if num is an Armstrong number, otherwise False.\n    \"\"\"\n    if not isinstance(num, int):\n        raise TypeError(\"Input must be an integer\")\n\n    if num < 0:\n        return False\n    if num == 0:\n        return True\n\n    # Count digits\n    temp = num\n    digits_count = 0\n    while temp > 0:\n        digits_count += 1\n        temp //= 10\n\n    # Sum of digits each raised to the power of digits_count\n    total = 0\n    temp = num\n    while temp > 0:\n        digit = temp % 10\n        total += digit ** digits_count\n        temp //= 10\n\n    return total == num"}
