{"benchmark": "mbpp", "task_id": "11", "prompt": "Write a python function to remove first and last occurrence of a given character from the string.", "reference_code": "def remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s ", "test_imports": [], "test_list": ["assert remove_Occ(\"hello\",\"l\") == \"heo\"", "assert remove_Occ(\"abcda\",\"a\") == \"bcd\"", "assert remove_Occ(\"PHP\",\"P\") == \"H\""], "model_name": "openai/gpt-5", "generated_code": "```python\ndef remove_Occ(s: str, ch: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n\n    - If the character appears only once, that occurrence is removed.\n    - If the character does not appear, the original string is returned.\n    - If 'ch' is longer than one character, only its first character is considered.\n\n    Parameters:\n        s (str): The input string.\n        ch (str): The character whose first and last occurrences will be removed.\n\n    Returns:\n        str: The string after removing the first and last occurrence of the character.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"s must be a string\")\n    if not ch:\n        return s  # Nothing to remove if empty target\n    c = ch[0]\n\n    first = s.find(c)\n    if first == -1:\n        return s  # Character not found\n\n    last = s.rfind(c)\n    if first == last:\n        # Only one occurrence\n        return s[:first] + s[first + 1:]\n    else:\n        # Remove both first and last occurrences\n        return s[:first] + s[first + 1:last] + s[last + 1:]\n```"}
{"benchmark": "mbpp", "task_id": "17", "prompt": "Write a function that returns the perimeter of a square given its side length as input.", "reference_code": "def square_perimeter(a):\n  perimeter=4*a\n  return perimeter", "test_imports": [], "test_list": ["assert square_perimeter(10)==40", "assert square_perimeter(5)==20", "assert square_perimeter(4)==16"], "model_name": "openai/gpt-5", "generated_code": "```python\ndef square_perimeter(side):\n    \"\"\"\n    Calculate the perimeter of a square given its side length.\n\n    Parameters:\n        side: A numeric value representing the length of one side of the square.\n              Can be int, float, Fraction, Decimal, or any type supporting multiplication.\n\n    Returns:\n        The perimeter of the square, computed as 4 * side.\n    \"\"\"\n    return side * 4\n```"}
{"benchmark": "mbpp", "task_id": "12", "prompt": "Write a function to sort a given matrix in ascending order according to the sum of its rows.", "reference_code": "def sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result", "test_imports": [], "test_list": ["assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]", "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]", "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"], "model_name": "openai/gpt-5", "generated_code": "```python\nfrom typing import Iterable, List, Sequence, Any\n\ndef sort_matrix(matrix: Iterable[Iterable[float]]) -> List[Sequence[Any]]:\n    \"\"\"\n    Sort the rows of a matrix in ascending order based on the sum of each row.\n\n    The sort is stable: rows with equal sums retain their original relative order.\n\n    Parameters:\n        matrix: An iterable of iterables representing the rows of the matrix.\n                Each row should be an iterable of numeric values.\n\n    Returns:\n        A new list containing the rows sorted by their row sums.\n    \"\"\"\n    rows = list(matrix)\n    return sorted(rows, key=lambda row: sum(row))\n```"}
{"benchmark": "mbpp", "task_id": "16", "prompt": "Write a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.", "reference_code": "import re\ndef text_lowercase_underscore(text):\n        patterns = '^[a-z]+_[a-z]+$'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False", "test_imports": [], "test_list": ["assert text_lowercase_underscore(\"aab_cbbbc\")==(True)", "assert text_lowercase_underscore(\"aab_Abbbc\")==(False)", "assert text_lowercase_underscore(\"Aaab_abbbc\")==(False)"], "model_name": "openai/gpt-5", "generated_code": "```python\nimport re\nfrom typing import Any\n\ndef text_lowercase_underscore(text: Any) -> bool:\n    \"\"\"\n    Return True if the input string consists of two sequences of lowercase letters\n    joined by a single underscore (e.g., 'abc_def'), and False otherwise.\n    \"\"\"\n    if not isinstance(text, str):\n        return False\n    return re.fullmatch(r'[a-z]+_[a-z]+', text) is not None\n```"}
{"benchmark": "mbpp", "task_id": "14", "prompt": "Write a python function to find the volume of a triangular prism.", "reference_code": "def find_Volume(l,b,h) : \n    return ((l * b * h) / 2) ", "test_imports": [], "test_list": ["assert find_Volume(10,8,6) == 240", "assert find_Volume(3,2,2) == 6", "assert find_Volume(1,2,1) == 1"], "model_name": "openai/gpt-5", "generated_code": "```python\nfrom typing import Any, Iterable, Optional\n\n\ndef find_Volume(*args, **kwargs):\n    \"\"\"\n    Compute the volume of a triangular prism.\n\n    Accepted usages:\n    - find_Volume(base, height, length) -> 0.5 * base * height * length\n    - find_Volume(length, base, height) -> order doesn't matter (multiplication is commutative)\n    - find_Volume(base_area, length)    -> base_area * length\n    - find_Volume([base, height, length]) or (base, height, length)\n    - Keyword arguments supported:\n        base/base_area/b, height/h, length/l, area\n\n    Returns a float (numerically equal to an int where applicable).\n    \"\"\"\n\n    def _to_number(x: Any) -> float:\n        try:\n            return float(x)\n        except Exception as exc:\n            raise TypeError(f\"Non-numeric value encountered: {x!r}\") from exc\n\n    def _from_iterable(x: Any) -> Optional[Iterable]:\n        if isinstance(x, (str, bytes)):\n            return None\n        try:\n            itr = list(x)\n        except TypeError:\n            return None\n        return itr\n\n    # If provided via keywords as area/base_area and length\n    if any(k in kwargs for k in (\"base_area\", \"area\")):\n        area = kwargs.get(\"base_area\", kwargs.get(\"area\"))\n        length = kwargs.get(\"length\", kwargs.get(\"l\"))\n        if length is None and args:\n            # allow length to be provided positionally\n            length = args"}
