{"benchmark": "mbpp", "task_id": "12", "prompt": "Write a function to sort a given matrix in ascending order according to the sum of its rows.", "reference_code": "def sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result", "test_imports": [], "test_list": ["assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]", "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]", "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "```python\ndef sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n        matrix: A list of lists representing a matrix\n        \n    Returns:\n        A new matrix sorted by row sums in ascending order\n    \"\"\"\n    return sorted(matrix, key=sum)\n```"}
{"benchmark": "mbpp", "task_id": "14", "prompt": "Write a python function to find the volume of a triangular prism.", "reference_code": "def find_Volume(l,b,h) : \n    return ((l * b * h) / 2) ", "test_imports": [], "test_list": ["assert find_Volume(10,8,6) == 240", "assert find_Volume(3,2,2) == 6", "assert find_Volume(1,2,1) == 1"], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "```python\ndef find_Volume(base, height, length):\n    \"\"\"\n    Find the volume of a triangular prism.\n    \n    Args:\n        base: The base of the triangular face\n        height: The height of the triangular face\n        length: The length (depth) of the prism\n    \n    Returns:\n        The volume of the triangular prism\n    \"\"\"\n    # Volume of triangular prism = (1/2 * base * height) * length\n    # where (1/2 * base * height) is the area of the triangular face\n    triangle_area = 0.5 * base * height\n    volume = triangle_area * length\n    return volume\n```"}
{"benchmark": "mbpp", "task_id": "11", "prompt": "Write a python function to remove first and last occurrence of a given character from the string.", "reference_code": "def remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s ", "test_imports": [], "test_list": ["assert remove_Occ(\"hello\",\"l\") == \"heo\"", "assert remove_Occ(\"abcda\",\"a\") == \"bcd\"", "assert remove_Occ(\"PHP\",\"P\") == \"H\""], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "```python\ndef remove_Occ(s, ch):\n    \"\"\"\n    Remove first and last occurrence of a given character from the string.\n    \n    Args:\n        s: The input string\n        ch: The character to remove\n    \n    Returns:\n        The string with first and last occurrence of ch removed\n    \"\"\"\n    if ch not in s:\n        return s\n    \n    # Find the first occurrence\n    first_index = s.find(ch)\n    \n    # Find the last occurrence\n    last_index = s.rfind(ch)\n    \n    # If first and last are the same (only one occurrence), remove it\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    # Remove both first and last occurrences\n    # Build the result by concatenating parts before first, between first and last, and after last\n    result = s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]\n    \n    return result\n```"}
{"benchmark": "mbpp", "task_id": "16", "prompt": "Write a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.", "reference_code": "import re\ndef text_lowercase_underscore(text):\n        patterns = '^[a-z]+_[a-z]+$'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False", "test_imports": [], "test_list": ["assert text_lowercase_underscore(\"aab_cbbbc\")==(True)", "assert text_lowercase_underscore(\"aab_Abbbc\")==(False)", "assert text_lowercase_underscore(\"Aaab_abbbc\")==(False)"], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "```python\ndef text_lowercase_underscore(s: str) -> bool:\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \n    Valid patterns:\n    - lowercase letters only: \"abc\"\n    - lowercase letters joined by underscore: \"abc_def\"\n    - multiple underscores joining sequences: \"abc_def_ghi\"\n    \n    Invalid patterns:\n    - uppercase letters\n    - digits\n    - special characters (except underscore)\n    - underscore at start or end\n    - consecutive underscores\n    - empty string\n    \"\"\"\n    if not s:\n        return False\n    \n    # Check if string matches pattern: lowercase letters separated by underscores\n    # Pattern: one or more lowercase letters, optionally followed by (underscore + one or more lowercase letters)\n    import re\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, s))\n```"}
{"benchmark": "mbpp", "task_id": "17", "prompt": "Write a function that returns the perimeter of a square given its side length as input.", "reference_code": "def square_perimeter(a):\n  perimeter=4*a\n  return perimeter", "test_imports": [], "test_list": ["assert square_perimeter(10)==40", "assert square_perimeter(5)==20", "assert square_perimeter(4)==16"], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "```python\ndef square_perimeter(side_length):\n    \"\"\"\n    Returns the perimeter of a square given its side length.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square (4 * side_length)\n    \"\"\"\n    return 4 * side_length\n```"}
{"benchmark": "mbpp", "task_id": "18", "prompt": "Write a function to remove characters from the first string which are present in the second string.", "reference_code": "NO_OF_CHARS = 256\ndef str_to_list(string): \n\ttemp = [] \n\tfor x in string: \n\t\ttemp.append(x) \n\treturn temp \ndef lst_to_string(List): \n\treturn ''.join(List) \ndef get_char_count_array(string): \n\tcount = [0] * NO_OF_CHARS \n\tfor i in string: \n\t\tcount[ord(i)] += 1\n\treturn count \ndef remove_dirty_chars(string, second_string): \n\tcount = get_char_count_array(second_string) \n\tip_ind = 0\n\tres_ind = 0\n\ttemp = '' \n\tstr_list = str_to_list(string) \n\twhile ip_ind != len(str_list): \n\t\ttemp = str_list[ip_ind] \n\t\tif count[ord(temp)] == 0: \n\t\t\tstr_list[res_ind] = str_list[ip_ind] \n\t\t\tres_ind += 1\n\t\tip_ind+=1\n\treturn lst_to_string(str_list[0:res_ind]) ", "test_imports": [], "test_list": ["assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'", "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'", "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles'"], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "```python\ndef remove_dirty_chars(s1, s2):\n    \"\"\"\n    Remove characters from the first string which are present in the second string.\n    \n    Args:\n        s1: The first string (to remove characters from)\n        s2: The second string (characters to remove)\n    \n    Returns:\n        A new string with characters from s1 that are not in s2\n    \"\"\"\n    # Create a set of characters from s2 for O(1) lookup\n    chars_to_remove = set(s2)\n    \n    # Keep only characters from s1 that are not in s2\n    return ''.join(char for char in s1 if char not in chars_to_remove)\n```"}
{"benchmark": "mbpp", "task_id": "19", "prompt": "Write a function to find whether a given array of integers contains any duplicate element.", "reference_code": "def test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)     ", "test_imports": [], "test_list": ["assert test_duplicate(([1,2,3,4,5]))==False", "assert test_duplicate(([1,2,3,4, 4]))==True", "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "```python\ndef test_duplicate(arr):\n    \"\"\"\n    Find whether a given array of integers contains any duplicate element.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        True if the array contains any duplicate element, False otherwise\n    \"\"\"\n    return len(arr) != len(set(arr))\n```"}
{"benchmark": "mbpp", "task_id": "20", "prompt": "Write a function to check if the given number is woodball or not.", "reference_code": "def is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False", "test_imports": [], "test_list": ["assert is_woodall(383) == True", "assert is_woodall(254) == False", "assert is_woodall(200) == False"], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "```python\ndef is_woodall(n):\n    \"\"\"\n    Check if the given number is a Woodall number.\n    \n    A Woodall number is a natural number of the form n * 2^n - 1,\n    where n is a positive integer.\n    \n    Args:\n        n: The number to check\n        \n    Returns:\n        True if n is a Woodall number, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    # Check if n + 1 is divisible by powers of 2 times increasing integers\n    # We need to find if there exists a positive integer k such that:\n    # n = k * 2^k - 1\n    # Which means: n + 1 = k * 2^k\n    \n    target = n + 1\n    \n    # k can be at most around log2(n) in most cases, but we need to check\n    # up to a reasonable limit. Since k * 2^k grows very fast,\n    # we don't need to check very large k values.\n    k = 1\n    while k * (1 << k) <= target * 2:  # 1 << k is 2^k\n        if k * (1 << k) == target:\n            return True\n        k += 1\n    \n    return False\n```"}
{"benchmark": "mbpp", "task_id": "56", "prompt": "Write a python function to check if a given number is one less than twice its reverse.", "reference_code": "def rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \ndef check(n):    \n    return (2 * rev(n) == n + 1)  ", "test_imports": [], "test_list": ["assert check(70) == False", "assert check(23) == False", "assert check(73) == True"], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "```python\ndef check(n):\n    \"\"\"\n    Check if a given number is one less than twice its reverse.\n    \n    Args:\n        n: An integer to check\n        \n    Returns:\n        True if n == 2 * reverse(n) - 1, False otherwise\n    \"\"\"\n    # Handle negative numbers by working with absolute value\n    abs_n = abs(n)\n    \n    # Reverse the digits of the absolute value\n    reversed_n = int(str(abs_n)[::-1])\n    \n    # If original number was negative, make reversed negative too\n    if n < 0:\n        reversed_n = -reversed_n\n    \n    # Check if n is one less than twice its reverse\n    return n == 2 * reversed_n - 1\n```"}
{"benchmark": "mbpp", "task_id": "57", "prompt": "Write a python function to find the largest number that can be formed with the given list of digits.", "reference_code": "def find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num ", "test_imports": [], "test_list": ["assert find_Max_Num([1,2,3]) == 321", "assert find_Max_Num([4,5,6,1]) == 6541", "assert find_Max_Num([1,2,3,9]) == 9321"], "model_name": "anthropic/claude-haiku-4.5", "generated_code": "```python\ndef find_Max_Num(digits):\n    \"\"\"\n    Find the largest number that can be formed with the given list of digits.\n    \n    Args:\n        digits: A list of integers (digits)\n    \n    Returns:\n        An integer representing the largest number that can be formed\n    \"\"\"\n    if not digits:\n        return 0\n    \n    # Convert digits to strings for custom sorting\n    digit_strings = [str(d) for d in digits]\n    \n    # Sort using a custom comparator\n    # For two numbers a and b, if ab > ba, then a should come before b\n    from functools import cmp_to_key\n    \n    def compare(a, b):\n        # Compare concatenations: a+b vs b+a\n        if a + b > b + a:\n            return -1  # a should come before b (descending order)\n        elif a + b < b + a:\n            return 1   # b should come before a\n        else:\n            return 0   # they are equal\n    \n    digit_strings.sort(key=cmp_to_key(compare))\n    \n    # Join the sorted digits to form the largest number\n    result = ''.join(digit_strings)\n    \n    # Handle the case where all digits are 0\n    if result[0] == '0':\n        return 0\n    \n    return int(result)\n```"}
